# 简述configure、pkg-config、pkg_config_path三者的关系




##一、什么是configure
源码安装过程中大多会用到configure这个程序，一般的configure都是一个script，执行时可以传入必要参数告知配置项目。
　　configure程序它会根据传入的配置项目检查程序编译时所依赖的环境以及对程序编译安装进行配置，最终生成编译所需的Makefile文件供程序Make读入使用进而调用相关编译程式(通常调用编译程序都是gcc)来编译最终的二进制程序。而configure脚本在检查相应依赖环境时(例：所依赖软件的版本、相应库版本等)，通常会通过pkg-config的工具来检测相应依赖环境。
##二、什么是pkg-config
###1、pkg-config介绍
　　pkg-config用来检索系统中安装库文件的信息。典型的是用作库的编译和连接。如在Makefile中：
program: program.c

cc program.c \`pkg-config --cflags --libs gnomeui\`

###2、pkg-config功能
一般来说，如果库的头文件不在/usr/include目录中，那么在编译的时候需要用-I参数指定其路径。由于同一个库在不同系统上可能位于不同的目录下，用户安装库的时候也可以将库安装在不同的目录下，所以即使使用同一个库，由于库的路径的不同，造成了用-I参数指定的头文件的路径和在连接时使用-L参数指定lib库的路径都可能不同，其结果就是造成了编译命令界面的不统一。可能由于编译，连接的不一致，造成同一份程序从一台机器copy到另一台机器时就可能会出现问题。
　　pkg-config 就是用来解决编译连接界面不统一问题的一个工具。
　　它的基本思想：pkg-config是通过库提供的一个.pc文件获得库的各种必要信息的，包括版本信息、编译和连接需要的参数等。需要的时候可以通过pkg-config提供的参数(–cflags, –libs)，将所需信息提取出来供编译和连接使用。这样，不管库文件安装在哪，通过库对应的.pc文件就可以准确定位,可以使用相同的编译和连接命令，使得编译和连接界面统一。
　　它提供的主要功能有:
```
<1> 检查库的版本号。如果所需库的版本不满足要求，打印出错误信息，避免连接错误版本的库文件。
<2> 获得编译预处理参数，如宏定义，头文件的路径。
<3> 获得编译参数，如库及其依赖的其他库的位置，文件名及其他一些连接参数。
<4> 自动加入所依赖的其他库的设置。
```
###3、glib-2.0的.pc文件内容举例
　　
在默认情况下，每个支持 pkg-config 的库对应的.pc文件在安装后都位于安装目录中的lib/pkgconfig目录下。例如，我们在上面已经将Glib安装在/opt/gtk目录下了，那么这个Glib库对应的.pc文件是 /opt/gtk/lib/pkgconfig目录下一个叫glib-2.0.pc的文件：
```sh
prefix=/opt/gtk/
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

glib_genmarshal=glib-genmarshal
gobject_query=gobject-query
glib_mkenums=glib-mkenums

Name: GLib
Description: C Utility Library
Version: 2.12.13
Libs: -L${libdir} -lglib-2.0
Cflags: -I${includedir}/glib-2.0 -I${libdir}/glib-2.0/include
```

```sh
pkg-config –list-all
```

列出所有可使用的包，位置在/usr/lib/pkgconfig ,此目录下都是各种.pc文件。/usr/local/lib/pkgconfig下面的libname.pc文件，新软件一般都会安装.pc文件，没有可以自己创建，并且设置环境变量PKG_CONFIG_PATH寻找.pc文件路径。
使用 pkg-config 的 –cflags 参数可以给出在编译时所需要的选项，而 –libs 参数可以给出连接时的选项。例如，假设一个 sample.c 的程序用到了 Glib 库，就可以这样编译：

```sh
$ gcc -c `pkg-config --cflags glib-2.0` sample.c
```
　　然后这样连接：
```sh
$ gcc sample.o -o sample `pkg-config --libs glib-2.0`
```
　　或者上面两步也可以合并为以下一步：
```sh
$ gcc sample.c -o sample `pkg-config --cflags --libs glib-2.0`
```
　　可以看到：由于使用了pkg-config工具来获得库的选项，所以不论库安装在什么目录下，都可以使用相同的编译和连接命令，带来了编译和连接界面的统一。<br>
　　使用pkg-config工具提取库的编译和连接参数有两个基本的前提：
```
<1> 库本身在安装的时候必须提供一个相应的.pc文件。不这样做的库说明不支持pkg-config工具的使用。
<2> pkg-config必须知道要到哪里去寻找此.pc 文件。
```

###4、 环境变量PKG_CONFIG_PATH

环境变量PKG_CONFIG_PATH是用来设置.pc文件的搜索路径的，pkg-config按照设置路径的先后顺序进行搜索，直到找到指定的.pc 文件为止。这样，库的头文件的搜索路径的设置实际上就变成了对.pc文件搜索路径的设置。<br>

在安装完一个需要使用的库后，比如Glib，一是将相应的.pc文件，如glib-2.0.pc拷贝到/usr/lib/pkgconfig目录下，二是通过设置环境变量PKG_CONFIG_PATH添加glib-2.0.pc文件的搜索路径。<br>
添加环境变量PKG_CONFIG_PATH，在bash中应该进行如下设置：
```
$ export PKG_CONFIG_PATH=/opt/gtk/lib/pkgconfig:$PKG_CONFIG_PATH
```
可以执行下面的命令检查是否 /opt/gtk/lib/pkgconfig 路径已经设置在PKG_CONFIG_PATH环境变量中：
```
$ echo $PKG_CONFIG_PATH
```

这样设置之后，使用Glib库的其它程序或库在编译的时候pkg-config就知道首先要到/opt/gtk/lib/pkgconfig这个目录中去寻找glib-2.0.pc了(GTK+和其它的依赖库的.pc文件也将拷贝到这里，也会首先到这里搜索它们对应的.pc文件)。之后，通过pkg-config就可以把其中库的编译和连接参数提取出来供程序在编译和连接时使用。<br>

另外还需要注意的是：环境变量的设置只对当前的终端窗口有效。如果到了没有进行上述设置的终端窗口中，pkg-config将找不到新安装的glib-2.0.pc文件、从而可能使后面进行的安装(如Glib之后的Atk的安装)无法进行。<br>

在我们采用的安装方案中，由于是使用环境变量对GTK+及其依赖库进行的设置，所以当系统重新启动、或者新开一个终端窗口之后，如果想使用新安装的GTK+库，需要如上面那样重新设置PKG_CONFIG_PATH和LD_LIBRARY_PATH环境变量。<br>

这种使用GTK+的方法，在使用之前多了一个对库进行设置的过程。虽然显得稍微繁琐了一些，但却是一种最安全的使用GTK+库的方式，不会对系统上已经存在的使用了GTK+库的程序(比如GNOME桌面)带来任何冲击。<br>
为了使库的设置变得简单一些，可以把下面的这两句设置保存到一个文件中(比如set_gtk-2.10 文件):
```
export PKG_CONFIG_PATH=/opt/gtk/lib/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH
```
其中的环境变量LD_LIBRARY_PATH变量主要是添加新安装库的搜索路径。之后，就可以用下面的方法进行库的设置了(其中的source命令也可以用.代替)：

```
$ source set_gtk-2.10
```

只有在用新版的GTK+库开发应用程序、或者运行使用了新版GTK+库的程序的时候，才有必要进行上述设置。

如果想避免使用GTK+库之前上述设置的麻烦，可以把上面两个环境变量的设置在系统的配置文件中(如 /etc/profile)或者自己的用户配置文件中(如 ~/.bash_profile) ；库的搜索路径也可以设置在 /etc/ld.so.conf
文件中，等等。这种设置在系统启动时会生效，从而会导致使用 GTK+ 的程序使用新版的 GTK+ 运行库，这有可能会带来一些问题。当然，如果你发现用新版的GTK+代替旧版没有什么问题的话，使用这种设置方式是比较方便的。加入到~/.bashrc中，例如：
```
PKG_CONFIG_PATH=/opt/gtk/lib/pkgconfig
```
重启之后：
```
[root@localhost ~]# echo $PKG_CONFIG_PATH
/opt/gtk/lib/pkgconfig
```
##三、运行时库的连接
　　库文件在连接(静态库和共享库)和运行(仅限于使用共享库的程序)时被使用，其搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib两个目录作为默认的库搜索路径，所以使用这两个目录中的库是不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到 库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其一使用：
```
<1> 在环境变量 LD_LIBRARY_PATH 中指明库的搜索路径。
<2> 在/etc/ld.so.conf 文件中添加库的搜索路径。
```
将自己可能存放库文件的路径都加入到/etc/ld.so.conf中是明智的选择 ^_^
添加方法也极其简单，将库文件的绝对路径直接写进去就OK了，一行一个。例如：

```
/usr/X11R6/lib
/usr/local/lib
/opt/lib
```
需要注意的是：第二种搜索路径的设置方式对于程序连接时的库(包括共享库和静态库)的定位已经足够了，但是对于使用了共享库的程序的执行还是不够的。这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache从中进行搜索的。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，它是根据/etc/ld.so.conf中设置的搜索路径由/sbin/ldconfig命令将这些搜索路径下的共享库文件集中在一起而生成的(ldconfig命令要以root权限执行)。因此，为了保证程序执行时对库的定位，在/etc/ld.so.conf中进行了库搜索路径的设置之后，还必须要运行/sbin/ldconfig命令更新/etc/ld.so.cache文件之后才可以。ldconfig简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。因此当安装完一些库文件(例如刚安装好glib)，或者修改ld.so.conf增加新的库路径后，需要运行一下 /sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中，如果没做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果编译过程中抱错，缺少xxx库，去查看发现明明就在那放着，搞的想大骂computer蠢猪一个。 ^_^ <br>

在程序连接时，对于库文件(静态库和共享库)的搜索路径，除了上面的设置方式之外，还可以通过-L参数显式指定。因为用-L设置的路径将被优先搜索，所以在连接的时候通常都会以这种方式直接指定要连接的库的路径。<br>

前面已经说明过了，库搜索路径的设置有两种方式：在环境变量LD_LIBRARY_PATH中设置以及在/etc/ld.so.conf文件中设置。其中，第二种设置方式需要root权限，以改变/etc/ld.so.conf文件并执行/sbin/ldconfig命令。而且，当系统重新启动后，所有的基于GTK2的程序在运行时都将使用新安装的GTK+库。不幸的是，由于GTK+版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在GTK+及其依赖库的安装过程中对于库的搜索路径的设置将采用第一种方式进行。这种设置方式不需要root权限，设置也简单：
```
$ export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH
```
可以用下面的命令查看 LD_LIBRAY_PATH 的设置内容：
```
$ echo $LD_LIBRARY_PATH
```
至此，库的两种设置就完成了。
##四、参考文章
ld.so.conf 文件与PKG_CONFIG_PATH变量<br>
pkg-config使用

