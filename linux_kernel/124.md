# 分析oops的機器碼


內核2.6.39.4多個USB插拔時出現oops，死在機器碼49 f2 8b 5d d4 89 f2 <8b> 33 89 75 d4 0f 18 06 90中。
使用文章oops調試的方法，製作了兩個文件：

- get_next_timer_interrupt.gdb

```sh
(gdb) disassemble get_next_timer_interrupt
Dump of assembler code for function get_next_timer_interrupt:
0xc103c738 <get_next_timer_interrupt+0>:	push   %ebp
0xc103c739 <get_next_timer_interrupt+1>:	mov    %esp,%ebp
0xc103c73b <get_next_timer_interrupt+3>:	push   %edi
0xc103c73c <get_next_timer_interrupt+4>:	push   %esi
0xc103c73d <get_next_timer_interrupt+5>:	push   %ebx
0xc103c73e <get_next_timer_interrupt+6>:	sub    $0x2c,%esp
0xc103c741 <get_next_timer_interrupt+9>:	mov    %eax,-0x20(%ebp)
0xc103c744 <get_next_timer_interrupt+12>:	mov    %fs:0xc1798d44,%ebx
0xc103c74b <get_next_timer_interrupt+19>:	call   0xc11d4410 <debug_smp_processor_id>
0xc103c750 <get_next_timer_interrupt+24>:	mov    0xc14d8cac,%edx
0xc103c756 <get_next_timer_interrupt+30>:	bt     %eax,(%edx)
0xc103c759 <get_next_timer_interrupt+33>:	sbb    %eax,%eax
0xc103c75b <get_next_timer_interrupt+35>:	test   %eax,%eax
0xc103c75d <get_next_timer_interrupt+37>:	jne    0xc103c76b <get_next_timer_interrupt+51>
0xc103c75f <get_next_timer_interrupt+39>:	addl   $0x3fffffff,-0x20(%ebp)
0xc103c766 <get_next_timer_interrupt+46>:	jmp    0xc103c8fc <get_next_timer_interrupt+452>
0xc103c76b <get_next_timer_interrupt+51>:	mov    %ebx,%eax
0xc103c76d <get_next_timer_interrupt+53>:	call   0xc14ce789 <_raw_spin_lock>
0xc103c772 <get_next_timer_interrupt+58>:	mov    0x8(%ebx),%eax
0xc103c775 <get_next_timer_interrupt+61>:	cmp    0xc(%ebx),%eax
0xc103c778 <get_next_timer_interrupt+64>:	js     0xc103c890 <get_next_timer_interrupt+344>
0xc103c77e <get_next_timer_interrupt+70>:	movzbl %al,%ecx
0xc103c781 <get_next_timer_interrupt+73>:	mov    %ecx,%esi
0xc103c783 <get_next_timer_interrupt+75>:	lea    0x10(%ebx,%esi,8),%edi
0xc103c787 <get_next_timer_interrupt+79>:	mov    0x10(%ebx,%esi,8),%edx
0xc103c78b <get_next_timer_interrupt+83>:	mov    %edi,-0x24(%ebp)
0xc103c78e <get_next_timer_interrupt+86>:	jmp    0xc103c7b0 <get_next_timer_interrupt+120>
0xc103c790 <get_next_timer_interrupt+88>:	testb  $0x1,0xc(%edx)
0xc103c794 <get_next_timer_interrupt+92>:	je     0xc103c79a <get_next_timer_interrupt+98>
0xc103c796 <get_next_timer_interrupt+94>:	mov    %edi,%edx
0xc103c798 <get_next_timer_interrupt+96>:	jmp    0xc103c7b0 <get_next_timer_interrupt+120>
0xc103c79a <get_next_timer_interrupt+98>:	cmp    %ecx,%esi
0xc103c79c <get_next_timer_interrupt+100>:	mov    0x8(%edx),%edx
0xc103c79f <get_next_timer_interrupt+103>:	jl     0xc103c7a9 <get_next_timer_interrupt+113>
0xc103c7a1 <get_next_timer_interrupt+105>:	test   %ecx,%ecx
0xc103c7a3 <get_next_timer_interrupt+107>:	jne    0xc103c88d <get_next_timer_interrupt+341>
0xc103c7a9 <get_next_timer_interrupt+113>:	mov    $0x1,%edi
0xc103c7ae <get_next_timer_interrupt+118>:	jmp    0xc103c7ce <get_next_timer_interrupt+150>
0xc103c7b0 <get_next_timer_interrupt+120>:	mov    (%edx),%edi
0xc103c7b2 <get_next_timer_interrupt+122>:	lea    0x0(%esi,%eiz,1),%esi
0xc103c7b6 <get_next_timer_interrupt+126>:	cmp    -0x24(%ebp),%edx
0xc103c7b9 <get_next_timer_interrupt+129>:	jne    0xc103c790 <get_next_timer_interrupt+88>
0xc103c7bb <get_next_timer_interrupt+131>:	inc    %esi
0xc103c7bc <get_next_timer_interrupt+132>:	and    $0xff,%esi
0xc103c7c2 <get_next_timer_interrupt+138>:	cmp    %ecx,%esi
0xc103c7c4 <get_next_timer_interrupt+140>:	jne    0xc103c783 <get_next_timer_interrupt+75>
0xc103c7c6 <get_next_timer_interrupt+142>:	lea    0x3fffffff(%eax),%edx
0xc103c7cc <get_next_timer_interrupt+148>:	xor    %edi,%edi
0xc103c7ce <get_next_timer_interrupt+150>:	test   %ecx,%ecx
0xc103c7d0 <get_next_timer_interrupt+152>:	je     0xc103c7d9 <get_next_timer_interrupt+161>
0xc103c7d2 <get_next_timer_interrupt+154>:	add    $0x100,%eax
0xc103c7d7 <get_next_timer_interrupt+159>:	sub    %ecx,%eax
0xc103c7d9 <get_next_timer_interrupt+161>:	shr    $0x8,%eax
0xc103c7dc <get_next_timer_interrupt+164>:	mov    %eax,-0x24(%ebp)
0xc103c7df <get_next_timer_interrupt+167>:	lea    0x810(%ebx),%eax
0xc103c7e5 <get_next_timer_interrupt+173>:	mov    %eax,-0x1c(%ebp)
0xc103c7e8 <get_next_timer_interrupt+176>:	lea    0xa10(%ebx),%eax
0xc103c7ee <get_next_timer_interrupt+182>:	mov    %eax,-0x18(%ebp)
0xc103c7f1 <get_next_timer_interrupt+185>:	lea    0xc10(%ebx),%eax
0xc103c7f7 <get_next_timer_interrupt+191>:	mov    %eax,-0x14(%ebp)
0xc103c7fa <get_next_timer_interrupt+194>:	lea    0xe10(%ebx),%eax
0xc103c800 <get_next_timer_interrupt+200>:	mov    %eax,-0x10(%ebp)
0xc103c803 <get_next_timer_interrupt+203>:	movl   $0x0,-0x28(%ebp)
0xc103c80a <get_next_timer_interrupt+210>:	mov    %ebx,-0x34(%ebp)
0xc103c80d <get_next_timer_interrupt+213>:	mov    -0x28(%ebp),%eax
0xc103c810 <get_next_timer_interrupt+216>:	mov    -0x24(%ebp),%ecx
0xc103c813 <get_next_timer_interrupt+219>:	mov    -0x1c(%ebp,%eax,4),%eax
0xc103c817 <get_next_timer_interrupt+223>:	and    $0x3f,%ecx
0xc103c81a <get_next_timer_interrupt+226>:	mov    %eax,-0x30(%ebp)
0xc103c81d <get_next_timer_interrupt+229>:	mov    %ecx,%eax
0xc103c81f <get_next_timer_interrupt+231>:	mov    -0x30(%ebp),%esi
0xc103c822 <get_next_timer_interrupt+234>:	mov    (%esi,%eax,8),%ebx
0xc103c825 <get_next_timer_interrupt+237>:	lea    (%esi,%eax,8),%esi
0xc103c828 <get_next_timer_interrupt+240>:	mov    %esi,-0x38(%ebp)
0xc103c82b <get_next_timer_interrupt+243>:	jmp    0xc103c847 <get_next_timer_interrupt+271>
0xc103c82d <get_next_timer_interrupt+245>:	testb  $0x1,0xc(%ebx)
0xc103c831 <get_next_timer_interrupt+249>:	mov    %edx,%esi
0xc103c833 <get_next_timer_interrupt+251>:	jne    0xc103c842 <get_next_timer_interrupt+266>
0xc103c835 <get_next_timer_interrupt+253>:	mov    0x8(%ebx),%esi
0xc103c838 <get_next_timer_interrupt+256>:	mov    $0x1,%edi
0xc103c83d <get_next_timer_interrupt+261>:	cmp    %edx,%esi
0xc103c83f <get_next_timer_interrupt+263>:	cmovns %edx,%esi
0xc103c842 <get_next_timer_interrupt+266>:	mov    -0x2c(%ebp),%ebx
0xc103c845 <get_next_timer_interrupt+269>:	mov    %esi,%edx
0xc103c847 <get_next_timer_interrupt+271>:	mov    (%ebx),%esi
0xc103c849 <get_next_timer_interrupt+273>:	mov    %esi,-0x2c(%ebp)
0xc103c84c <get_next_timer_interrupt+276>:	lea    0x0(%esi,%eiz,1),%esi
0xc103c850 <get_next_timer_interrupt+280>:	cmp    -0x38(%ebp),%ebx
0xc103c853 <get_next_timer_interrupt+283>:	jne    0xc103c82d <get_next_timer_interrupt+245>
0xc103c855 <get_next_timer_interrupt+285>:	test   %edi,%edi
0xc103c857 <get_next_timer_interrupt+287>:	je     0xc103c868 <get_next_timer_interrupt+304>
0xc103c859 <get_next_timer_interrupt+289>:	cmp    %ecx,%eax
0xc103c85b <get_next_timer_interrupt+291>:	jl     0xc103c861 <get_next_timer_interrupt+297>
0xc103c85d <get_next_timer_interrupt+293>:	test   %ecx,%ecx
0xc103c85f <get_next_timer_interrupt+295>:	jne    0xc103c88a <get_next_timer_interrupt+338>
0xc103c861 <get_next_timer_interrupt+297>:	mov    $0x1,%edi
0xc103c866 <get_next_timer_interrupt+302>:	jmp    0xc103c870 <get_next_timer_interrupt+312>
0xc103c868 <get_next_timer_interrupt+304>:	inc    %eax
0xc103c869 <get_next_timer_interrupt+305>:	and    $0x3f,%eax
0xc103c86c <get_next_timer_interrupt+308>:	cmp    %ecx,%eax
0xc103c86e <get_next_timer_interrupt+310>:	jne    0xc103c81f <get_next_timer_interrupt+231>
0xc103c870 <get_next_timer_interrupt+312>:	test   %ecx,%ecx
0xc103c872 <get_next_timer_interrupt+314>:	je     0xc103c87b <get_next_timer_interrupt+323>
0xc103c874 <get_next_timer_interrupt+316>:	addl   $0x40,-0x24(%ebp)
0xc103c878 <get_next_timer_interrupt+320>:	sub    %ecx,-0x24(%ebp)
0xc103c87b <get_next_timer_interrupt+323>:	incl   -0x28(%ebp)
0xc103c87e <get_next_timer_interrupt+326>:	cmpl   $0x4,-0x28(%ebp)
0xc103c882 <get_next_timer_interrupt+330>:	je     0xc103c88a <get_next_timer_interrupt+338>
0xc103c884 <get_next_timer_interrupt+332>:	shrl   $0x6,-0x24(%ebp)
0xc103c888 <get_next_timer_interrupt+336>:	jmp    0xc103c80d <get_next_timer_interrupt+213>
0xc103c88a <get_next_timer_interrupt+338>:	mov    -0x34(%ebp),%ebx
0xc103c88d <get_next_timer_interrupt+341>:	mov    %edx,0xc(%ebx)
0xc103c890 <get_next_timer_interrupt+344>:	mov    0xc(%ebx),%esi
0xc103c893 <get_next_timer_interrupt+347>:	mov    %ebx,%eax
0xc103c895 <get_next_timer_interrupt+349>:	call   0xc14ce8e2 <_raw_spin_unlock>
0xc103c89a <get_next_timer_interrupt+354>:	cmp    %esi,-0x20(%ebp)
0xc103c89d <get_next_timer_interrupt+357>:	jns    0xc103c8fc <get_next_timer_interrupt+452>
0xc103c89f <get_next_timer_interrupt+359>:	call   0xc104b26f <hrtimer_get_next_event>
0xc103c8a4 <get_next_timer_interrupt+364>:	cmp    $0x7fffffff,%edx
0xc103c8aa <get_next_timer_interrupt+370>:	jne    0xc103c8b3 <get_next_timer_interrupt+379>
0xc103c8ac <get_next_timer_interrupt+372>:	cmp    $0xffffffff,%eax
0xc103c8af <get_next_timer_interrupt+375>:	jne    0xc103c8c4 <get_next_timer_interrupt+396>
0xc103c8b1 <get_next_timer_interrupt+377>:	jmp    0xc103c8f9 <get_next_timer_interrupt+449>
0xc103c8b3 <get_next_timer_interrupt+379>:	cmp    $0x0,%edx
0xc103c8b6 <get_next_timer_interrupt+382>:	jg     0xc103c8c4 <get_next_timer_interrupt+396>
0xc103c8b8 <get_next_timer_interrupt+384>:	jl     0xc103c8bf <get_next_timer_interrupt+391>
0xc103c8ba <get_next_timer_interrupt+386>:	cmp    $0x0,%eax
0xc103c8bd <get_next_timer_interrupt+389>:	ja     0xc103c8c4 <get_next_timer_interrupt+396>
0xc103c8bf <get_next_timer_interrupt+391>:	incl   -0x20(%ebp)
0xc103c8c2 <get_next_timer_interrupt+394>:	jmp    0xc103c8fc <get_next_timer_interrupt+452>
0xc103c8c4 <get_next_timer_interrupt+396>:	call   0xc10359c4 <ns_to_timespec>
0xc103c8c9 <get_next_timer_interrupt+401>:	mov    %eax,-0x1c(%ebp)
0xc103c8cc <get_next_timer_interrupt+404>:	lea    -0x1c(%ebp),%eax
0xc103c8cf <get_next_timer_interrupt+407>:	mov    %edx,-0x18(%ebp)
0xc103c8d2 <get_next_timer_interrupt+410>:	call   0xc10357b9 <timespec_to_jiffies>
0xc103c8d7 <get_next_timer_interrupt+415>:	cmp    $0x3fffffff,%eax
0xc103c8dc <get_next_timer_interrupt+420>:	jbe    0xc103c8e5 <get_next_timer_interrupt+429>
0xc103c8de <get_next_timer_interrupt+422>:	mov    $0x3fffffff,%eax
0xc103c8e3 <get_next_timer_interrupt+427>:	jmp    0xc103c8ef <get_next_timer_interrupt+439>
0xc103c8e5 <get_next_timer_interrupt+429>:	test   %eax,%eax
0xc103c8e7 <get_next_timer_interrupt+431>:	mov    $0x1,%edx
0xc103c8ec <get_next_timer_interrupt+436>:	cmove  %edx,%eax
0xc103c8ef <get_next_timer_interrupt+439>:	add    -0x20(%ebp),%eax
0xc103c8f2 <get_next_timer_interrupt+442>:	cmp    %esi,%eax
0xc103c8f4 <get_next_timer_interrupt+444>:	mov    %eax,-0x20(%ebp)
0xc103c8f7 <get_next_timer_interrupt+447>:	js     0xc103c8fc <get_next_timer_interrupt+452>
0xc103c8f9 <get_next_timer_interrupt+449>:	mov    %esi,-0x20(%ebp)
0xc103c8fc <get_next_timer_interrupt+452>:	mov    -0x20(%ebp),%eax
0xc103c8ff <get_next_timer_interrupt+455>:	add    $0x2c,%esp
0xc103c902 <get_next_timer_interrupt+458>:	pop    %ebx
0xc103c903 <get_next_timer_interrupt+459>:	pop    %esi
0xc103c904 <get_next_timer_interrupt+460>:	pop    %edi
0xc103c905 <get_next_timer_interrupt+461>:	pop    %ebp
0xc103c906 <get_next_timer_interrupt+462>:	ret
End of assembler dump.
(gdb)

```

- get_next_timer_interrupt.objdump

```sh

kernel/timer.o:     file format elf32-i386


Disassembly of section .text:

c103ab38 <round_jiffies_common>:
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab38:	55                   	push   %ebp
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab39:	89 e5                	mov    %esp,%ebp
 * It's not worth to care about 3dnow prefetches for the K6
 * because they are microcoded there and very slow.
 */
static inline void prefetch(const void *x)
{
	alternative_input(BASE_PREFETCH,
c103ab3b:	57                   	push   %edi
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab3c:	bf e8 03 00 00       	mov    $0x3e8,%edi
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab41:	56                   	push   %esi
signed long __sched schedule_timeout(signed long timeout)
{
	struct timer_list timer;
	unsigned long expire;

	switch (timeout)
c103ab42:	89 c6                	mov    %eax,%esi
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab44:	53                   	push   %ebx
c103ab45:	89 d3                	mov    %edx,%ebx
c103ab47:	83 ec 04             	sub    $0x4,%esp
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab4a:	88 4d f3             	mov    %cl,-0xd(%ebp)
	 * 3 jiffies. This 3 jiffies came originally from the mm/ code which
	 * already did this.
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;
c103ab4d:	8d 0c 52             	lea    (%edx,%edx,2),%ecx

	rem = j % HZ;
c103ab50:	31 d2                	xor    %edx,%edx
	 * 3 jiffies. This 3 jiffies came originally from the mm/ code which
	 * already did this.
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;
c103ab52:	01 c1                	add    %eax,%ecx

	rem = j % HZ;
c103ab54:	89 c8                	mov    %ecx,%eax
c103ab56:	f7 f7                	div    %edi
	 * due to delays of the timer irq, long irq off times etc etc) then
	 * we should round down to the whole second, not up. Use 1/4th second
	 * as cutoff for this rounding as an extreme upper bound for this.
	 * But never round down if @force_up is set.
	 */
	if (rem < HZ/4 && !force_up) /* round down */
c103ab58:	81 fa f9 00 00 00    	cmp    $0xf9,%edx
	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
				(void *)(long)smp_processor_id());

	init_timer_stats();

	BUG_ON(err != NOTIFY_OK);
c103ab5e:	7f 06                	jg     c103ab66 <round_jiffies_common+0x2e>
	register_cpu_notifier(&timers_nb);
c103ab60:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return percpu_read_stable(current_task);
c103ab64:	74 06                	je     c103ab6c <round_jiffies_common+0x34>
	 * But never round down if @force_up is set.
	 */
	if (rem < HZ/4 && !force_up) /* round down */
		j = j - rem;
	else /* round up */
		j = j - rem + HZ;
c103ab66:	81 c1 e8 03 00 00    	add    $0x3e8,%ecx

	/* now that we have rounded, subtract the extra skew again */
	j -= cpu * 3;
c103ab6c:	6b db fd             	imul   $0xfffffffd,%ebx,%ebx

	if (j <= jiffies) /* rounding ate our timeout entirely; */
c103ab6f:	a1 00 00 00 00       	mov    0x0,%eax
	 * But never round down if @force_up is set.
	 */
	if (rem < HZ/4 && !force_up) /* round down */
		j = j - rem;
	else /* round up */
		j = j - rem + HZ;
c103ab74:	29 d1                	sub    %edx,%ecx
	j -= cpu * 3;

	if (j <= jiffies) /* rounding ate our timeout entirely; */
		return original;
	return j;
}
c103ab76:	5a                   	pop    %edx
		j = j - rem;
	else /* round up */
		j = j - rem + HZ;

	/* now that we have rounded, subtract the extra skew again */
	j -= cpu * 3;
c103ab77:	01 d9                	add    %ebx,%ecx

	if (j <= jiffies) /* rounding ate our timeout entirely; */
c103ab79:	39 c1                	cmp    %eax,%ecx
c103ab7b:	89 c8                	mov    %ecx,%eax
c103ab7d:	0f 46 c6             	cmovbe %esi,%eax
		return original;
	return j;
}
c103ab80:	5b                   	pop    %ebx
c103ab81:	5e                   	pop    %esi
c103ab82:	5f                   	pop    %edi
c103ab83:	5d                   	pop    %ebp
			return kmalloc_large(size, flags);

		if (!(flags & SLUB_DMA)) {
			struct kmem_cache *s = kmalloc_slab(size);

			if (!s)
c103ab84:	c3                   	ret

c103ab85 <__round_jiffies>:
 * to lock contention or spurious cache line bouncing.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies(unsigned long j, int cpu)
{
c103ab85:	55                   	push   %ebp
	return round_jiffies_common(j, cpu, false);
c103ab86:	31 c9                	xor    %ecx,%ecx
 * to lock contention or spurious cache line bouncing.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies(unsigned long j, int cpu)
{
c103ab88:	89 e5                	mov    %esp,%ebp
	return round_jiffies_common(j, cpu, false);
c103ab8a:	e8 a9 ff ff ff       	call   c103ab38 <round_jiffies_common>
}
c103ab8f:	5d                   	pop    %ebp
c103ab90:	c3                   	ret

c103ab91 <__round_jiffies_relative>:
 * to lock contention or spurious cache line bouncing.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
c103ab91:	55                   	push   %ebp
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
c103ab92:	31 c9                	xor    %ecx,%ecx
 * to lock contention or spurious cache line bouncing.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
c103ab94:	89 e5                	mov    %esp,%ebp
c103ab96:	53                   	push   %ebx
	unsigned long j0 = jiffies;
c103ab97:	8b 1d 00 00 00 00    	mov    0x0,%ebx

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
c103ab9d:	01 d8                	add    %ebx,%eax
			 * The APs use this path later in boot
			 */
			base = kmalloc_node(sizeof(*base),
						GFP_KERNEL | __GFP_ZERO,
						cpu_to_node(cpu));
			if (!base)
c103ab9f:	e8 94 ff ff ff       	call   c103ab38 <round_jiffies_common>
c103aba4:	29 d8                	sub    %ebx,%eax
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
}
c103aba6:	5b                   	pop    %ebx
c103aba7:	5d                   	pop    %ebp
c103aba8:	c3                   	ret

c103aba9 <round_jiffies>:
 * of this is to have the CPU wake up less, which saves power.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies(unsigned long j)
{
c103aba9:	55                   	push   %ebp
	return round_jiffies_common(j, raw_smp_processor_id(), false);
c103abaa:	31 c9                	xor    %ecx,%ecx
 * of this is to have the CPU wake up less, which saves power.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies(unsigned long j)
{
c103abac:	89 e5                	mov    %esp,%ebp
	return round_jiffies_common(j, raw_smp_processor_id(), false);
c103abae:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
			if (!base)
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
c103abb5:	e8 7e ff ff ff       	call   c103ab38 <round_jiffies_common>
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), false);
}
c103abba:	5d                   	pop    %ebp
c103abbb:	c3                   	ret

c103abbc <round_jiffies_relative>:
 * of this is to have the CPU wake up less, which saves power.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
c103abbc:	55                   	push   %ebp
c103abbd:	89 e5                	mov    %esp,%ebp
	return __round_jiffies_relative(j, raw_smp_processor_id());
c103abbf:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
				kfree(base);
c103abc6:	e8 fc ff ff ff       	call   c103abc7 <round_jiffies_relative+0xb>
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
	return __round_jiffies_relative(j, raw_smp_processor_id());
}
c103abcb:	5d                   	pop    %ebp
c103abcc:	c3                   	ret

c103abcd <__round_jiffies_up>:
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up(unsigned long j, int cpu)
{
c103abcd:	55                   	push   %ebp
	return round_jiffies_common(j, cpu, true);
c103abce:	b9 01 00 00 00       	mov    $0x1,%ecx
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up(unsigned long j, int cpu)
{
c103abd3:	89 e5                	mov    %esp,%ebp
	return round_jiffies_common(j, cpu, true);
c103abd5:	e8 5e ff ff ff       	call   c103ab38 <round_jiffies_common>
}
c103abda:	5d                   	pop    %ebp
c103abdb:	c3                   	ret

c103abdc <__round_jiffies_up_relative>:
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
c103abdc:	55                   	push   %ebp
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
c103abdd:	b9 01 00 00 00       	mov    $0x1,%ecx
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
c103abe2:	89 e5                	mov    %esp,%ebp
c103abe4:	53                   	push   %ebx
	unsigned long j0 = jiffies;
c103abe5:	8b 1d 00 00 00 00    	mov    0x0,%ebx

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
c103abeb:	01 d8                	add    %ebx,%eax
c103abed:	e8 46 ff ff ff       	call   c103ab38 <round_jiffies_common>
			 * initialised either.
			 */
			boot_done = 1;
			base = &boot_tvec_bases;
		}
		tvec_base_done[cpu] = 1;
c103abf2:	29 d8                	sub    %ebx,%eax
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
}
c103abf4:	5b                   	pop    %ebx
c103abf5:	5d                   	pop    %ebp
/*
 * We can use __set_current_state() here because schedule_timeout() calls
 * schedule() unconditionally.
 */
signed long __sched schedule_timeout_interruptible(signed long timeout)
{
c103abf6:	c3                   	ret

c103abf7 <round_jiffies_up>:
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long round_jiffies_up(unsigned long j)
{
c103abf7:	55                   	push   %ebp
	return round_jiffies_common(j, raw_smp_processor_id(), true);
c103abf8:	b9 01 00 00 00       	mov    $0x1,%ecx
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long round_jiffies_up(unsigned long j)
{
c103abfd:	89 e5                	mov    %esp,%ebp
	return round_jiffies_common(j, raw_smp_processor_id(), true);
c103abff:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
 * schedule() unconditionally.
 */
signed long __sched schedule_timeout_interruptible(signed long timeout)
{
	__set_current_state(TASK_INTERRUPTIBLE);
	return schedule_timeout(timeout);
c103ac06:	e8 2d ff ff ff       	call   c103ab38 <round_jiffies_common>
 * early.
 */
unsigned long round_jiffies_up(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), true);
}
c103ac0b:	5d                   	pop    %ebp
c103ac0c:	c3                   	ret

c103ac0d <round_jiffies_up_relative>:
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long round_jiffies_up_relative(unsigned long j)
{
c103ac0d:	55                   	push   %ebp
c103ac0e:	89 e5                	mov    %esp,%ebp
	return __round_jiffies_up_relative(j, raw_smp_processor_id());
c103ac10:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
	}

	spin_lock_init(&base->lock);

	for (j = 0; j < TVN_SIZE; j++) {
		INIT_LIST_HEAD(base->tv5.vec + j);
c103ac17:	e8 fc ff ff ff       	call   c103ac18 <round_jiffies_up_relative+0xb>
 * early.
 */
unsigned long round_jiffies_up_relative(unsigned long j)
{
	return __round_jiffies_up_relative(j, raw_smp_processor_id());
}
c103ac1c:	5d                   	pop    %ebp
c103ac1d:	c3                   	ret

c103ac1e <set_timer_slack>:
 *
 * By setting the slack to -1, a percentage of the delay is used
 * instead.
 */
void set_timer_slack(struct timer_list *timer, int slack_hz)
{
c103ac1e:	55                   	push   %ebp
c103ac1f:	89 e5                	mov    %esp,%ebp
	timer->slack = slack_hz;
c103ac21:	89 50 18             	mov    %edx,0x18(%eax)
}
c103ac24:	5d                   	pop    %ebp
c103ac25:	c3                   	ret

c103ac26 <internal_add_timer>:
EXPORT_SYMBOL_GPL(set_timer_slack);

static void internal_add_timer(struct tvec_base *base, struct timer_list *timer)
{
c103ac26:	55                   	push   %ebp
	unsigned long expires = timer->expires;
c103ac27:	8b 4a 08             	mov    0x8(%edx),%ecx
	timer->slack = slack_hz;
}
EXPORT_SYMBOL_GPL(set_timer_slack);

static void internal_add_timer(struct tvec_base *base, struct timer_list *timer)
{
c103ac2a:	89 e5                	mov    %esp,%ebp
c103ac2c:	56                   	push   %esi
c103ac2d:	53                   	push   %ebx
	unsigned long expires = timer->expires;
	unsigned long idx = expires - base->timer_jiffies;
c103ac2e:	8b 70 08             	mov    0x8(%eax),%esi
c103ac31:	89 cb                	mov    %ecx,%ebx
c103ac33:	29 f3                	sub    %esi,%ebx
	struct list_head *vec;

	if (idx < TVR_SIZE) {
c103ac35:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
c103ac3b:	77 0c                	ja     c103ac49 <internal_add_timer+0x23>
		int i = expires & TVR_MASK;
		vec = base->tv1.vec + i;
c103ac3d:	81 e1 ff 00 00 00    	and    $0xff,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac43:	8d 44 c8 10          	lea    0x10(%eax,%ecx,8),%eax
c103ac47:	eb 5f                	jmp    c103aca8 <internal_add_timer+0x82>
	} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {
c103ac49:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
	list->prev = list;
c103ac4f:	77 0f                	ja     c103ac60 <internal_add_timer+0x3a>
		int i = (expires >> TVR_BITS) & TVN_MASK;
		vec = base->tv2.vec + i;
c103ac51:	c1 e9 08             	shr    $0x8,%ecx
c103ac54:	83 e1 3f             	and    $0x3f,%ecx
c103ac57:	8d 84 c8 10 08 00 00 	lea    0x810(%eax,%ecx,8),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac5e:	eb 48                	jmp    c103aca8 <internal_add_timer+0x82>
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
c103ac60:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
		base = per_cpu(tvec_bases, cpu);
	}

	spin_lock_init(&base->lock);

	for (j = 0; j < TVN_SIZE; j++) {
c103ac66:	77 0f                	ja     c103ac77 <internal_add_timer+0x51>
	} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {
		int i = (expires >> TVR_BITS) & TVN_MASK;
		vec = base->tv2.vec + i;
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
c103ac68:	c1 e9 0e             	shr    $0xe,%ecx
c103ac6b:	83 e1 3f             	and    $0x3f,%ecx
		INIT_LIST_HEAD(base->tv4.vec + j);
		INIT_LIST_HEAD(base->tv3.vec + j);
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
		INIT_LIST_HEAD(base->tv1.vec + j);
c103ac6e:	8d 84 c8 10 0a 00 00 	lea    0xa10(%eax,%ecx,8),%eax
c103ac75:	eb 31                	jmp    c103aca8 <internal_add_timer+0x82>
		int i = (expires >> TVR_BITS) & TVN_MASK;
		vec = base->tv2.vec + i;
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
	} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {
c103ac77:	81 fb ff ff ff 03    	cmp    $0x3ffffff,%ebx
		INIT_LIST_HEAD(base->tv5.vec + j);
		INIT_LIST_HEAD(base->tv4.vec + j);
		INIT_LIST_HEAD(base->tv3.vec + j);
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
c103ac7d:	77 0f                	ja     c103ac8e <internal_add_timer+0x68>
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
	} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + 2 * TVN_BITS)) & TVN_MASK;
		vec = base->tv4.vec + i;
c103ac7f:	c1 e9 14             	shr    $0x14,%ecx
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
		INIT_LIST_HEAD(base->tv1.vec + j);

	base->timer_jiffies = jiffies;
c103ac82:	83 e1 3f             	and    $0x3f,%ecx
c103ac85:	8d 84 c8 10 0c 00 00 	lea    0xc10(%eax,%ecx,8),%eax
	base->next_timer = base->timer_jiffies;
c103ac8c:	eb 1a                	jmp    c103aca8 <internal_add_timer+0x82>
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
	} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + 2 * TVN_BITS)) & TVN_MASK;
		vec = base->tv4.vec + i;
	} else if ((signed long) idx < 0) {
c103ac8e:	85 db                	test   %ebx,%ebx
c103ac90:	79 0c                	jns    c103ac9e <internal_add_timer+0x78>
		/*
		 * Can happen if you add a timer with expires == jiffies,
		 * or you set a timer to go off in the past
		 */
		vec = base->tv1.vec + (base->timer_jiffies & TVR_MASK);
c103ac92:	81 e6 ff 00 00 00    	and    $0xff,%esi
c103ac98:	8d 44 f0 10          	lea    0x10(%eax,%esi,8),%eax
{
	struct tvec_base *old_base;
	struct tvec_base *new_base;
	int i;

	BUG_ON(cpu_online(cpu));
c103ac9c:	eb 0a                	jmp    c103aca8 <internal_add_timer+0x82>
		if (idx > 0xffffffffUL) {
			idx = 0xffffffffUL;
			expires = idx + base->timer_jiffies;
		}
		i = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;
		vec = base->tv5.vec + i;
c103ac9e:	c1 e9 1a             	shr    $0x1a,%ecx
c103aca1:	8d 84 c8 10 0e 00 00 	lea    0xe10(%eax,%ecx,8),%eax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
c103aca8:	8b 48 04             	mov    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
c103acab:	89 50 04             	mov    %edx,0x4(%eax)
	new->next = next;
c103acae:	89 02                	mov    %eax,(%edx)
	new->prev = prev;
c103acb0:	89 4a 04             	mov    %ecx,0x4(%edx)
	prev->next = new;
c103acb3:	89 11                	mov    %edx,(%ecx)
	}
	/*
	 * Timers are FIFO:
	 */
	list_add_tail(&timer->entry, vec);
}
c103acb5:	5b                   	pop    %ebx
c103acb6:	5e                   	pop    %esi
c103acb7:	5d                   	pop    %ebp
c103acb8:	c3                   	ret

c103acb9 <sys_getuid>:

	return pid;
}

SYSCALL_DEFINE0(getuid)
{
c103acb9:	55                   	push   %ebp
c103acba:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
c103acc0:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
c103acc6:	89 e5                	mov    %esp,%ebp
	/* Only we change this so SMP safe */
	return current_uid();
}
c103acc8:	5d                   	pop    %ebp
c103acc9:	8b 40 04             	mov    0x4(%eax),%eax
c103accc:	c3                   	ret

c103accd <sys_geteuid>:

SYSCALL_DEFINE0(geteuid)
{
c103accd:	55                   	push   %ebp
c103acce:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
c103acd4:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
c103acda:	89 e5                	mov    %esp,%ebp
	/* Only we change this so SMP safe */
	return current_euid();
}
c103acdc:	5d                   	pop    %ebp
c103acdd:	8b 40 14             	mov    0x14(%eax),%eax
c103ace0:	c3                   	ret

c103ace1 <sys_getgid>:

SYSCALL_DEFINE0(getgid)
{
c103ace1:	55                   	push   %ebp
c103ace2:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
	spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
c103ace8:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
	/* Only we change this so SMP safe */
	return current_euid();
}

SYSCALL_DEFINE0(getgid)
{
c103acee:	89 e5                	mov    %esp,%ebp
	/* Only we change this so SMP safe */
	return current_gid();
}
c103acf0:	5d                   	pop    %ebp
c103acf1:	8b 40 08             	mov    0x8(%eax),%eax
c103acf4:	c3                   	ret

c103acf5 <sys_getegid>:

SYSCALL_DEFINE0(getegid)
{
c103acf5:	55                   	push   %ebp
c103acf6:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
c103acfc:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
c103ad02:	89 e5                	mov    %esp,%ebp
	/* Only we change this so SMP safe */
	return  current_egid();
}
c103ad04:	5d                   	pop    %ebp
c103ad05:	8b 40 18             	mov    0x18(%eax),%eax
c103ad08:	c3                   	ret

c103ad09 <cascade>:
}
EXPORT_SYMBOL(del_timer_sync);
#endif

static int cascade(struct tvec_base *base, struct tvec *tv, int index)
{
c103ad09:	55                   	push   %ebp
c103ad0a:	89 e5                	mov    %esp,%ebp

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
		migrate_timer_list(new_base, old_base->tv2.vec + i);
		migrate_timer_list(new_base, old_base->tv3.vec + i);
c103ad0c:	57                   	push   %edi
c103ad0d:	89 c7                	mov    %eax,%edi
c103ad0f:	56                   	push   %esi
c103ad10:	53                   	push   %ebx
c103ad11:	89 cb                	mov    %ecx,%ebx
c103ad13:	83 ec 0c             	sub    $0xc,%esp
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
c103ad16:	8b 34 da             	mov    (%edx,%ebx,8),%esi
	new->next->prev = new;
c103ad19:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
	/* cascade all the timers from tv up one level */
	struct timer_list *timer, *tmp;
	struct list_head tv_list;

	list_replace_init(tv->vec + index, &tv_list);
c103ad1c:	8d 0c ca             	lea    (%edx,%ecx,8),%ecx
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
c103ad1f:	89 75 ec             	mov    %esi,-0x14(%ebp)
	new->next->prev = new;
c103ad22:	89 46 04             	mov    %eax,0x4(%esi)
	new->prev = old->prev;
c103ad25:	8b 74 da 04          	mov    0x4(%edx,%ebx,8),%esi
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
		migrate_timer_list(new_base, old_base->tv2.vec + i);
		migrate_timer_list(new_base, old_base->tv3.vec + i);
		migrate_timer_list(new_base, old_base->tv4.vec + i);
		migrate_timer_list(new_base, old_base->tv5.vec + i);
c103ad29:	89 75 f0             	mov    %esi,-0x10(%ebp)
	new->prev->next = new;
c103ad2c:	89 06                	mov    %eax,(%esi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ad2e:	89 0c da             	mov    %ecx,(%edx,%ebx,8)
	list->prev = list;
c103ad31:	89 4c da 04          	mov    %ecx,0x4(%edx,%ebx,8)

	/*
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
c103ad35:	8b 55 ec             	mov    -0x14(%ebp),%edx

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
c103ad38:	8b 32                	mov    (%edx),%esi
c103ad3a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
c103ad3d:	eb 19                	jmp    c103ad58 <cascade+0x4f>
	/*
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
		BUG_ON(tbase_get_base(timer->base) != base);
c103ad3f:	8b 42 0c             	mov    0xc(%edx),%eax
	raw_spin_unlock_bh(&lock->rlock);
}

static inline void spin_unlock_irq(spinlock_t *lock)
{
	raw_spin_unlock_irq(&lock->rlock);
c103ad42:	83 e0 fe             	and    $0xfffffffe,%eax
c103ad45:	39 c7                	cmp    %eax,%edi
c103ad47:	74 04                	je     c103ad4d <cascade+0x44>
		migrate_timer_list(new_base, old_base->tv5.vec + i);
	}

	spin_unlock(&old_base->lock);
	spin_unlock_irq(&new_base->lock);
	put_cpu_var(tvec_bases);
c103ad49:	0f 0b                	ud2a
c103ad4b:	eb fe                	jmp    c103ad4b <cascade+0x42>
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
		BUG_ON(tbase_get_base(timer->base) != base);
		internal_add_timer(base, timer);
c103ad4d:	89 f8                	mov    %edi,%eax
c103ad4f:	e8 d2 fe ff ff       	call   c103ac26 <internal_add_timer>

	/*
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
c103ad54:	89 f2                	mov    %esi,%edx
c103ad56:	8b 36                	mov    (%esi),%esi
c103ad58:	3b 55 e8             	cmp    -0x18(%ebp),%edx
}

static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr % BITS_PER_LONG)) &
		(addr[nr / BITS_PER_LONG])) != 0;
c103ad5b:	75 e2                	jne    c103ad3f <cascade+0x36>
		BUG_ON(tbase_get_base(timer->base) != base);
		internal_add_timer(base, timer);
	}

	return index;
}
c103ad5d:	83 c4 0c             	add    $0xc,%esp
c103ad60:	89 d8                	mov    %ebx,%eax
c103ad62:	5b                   	pop    %ebx
c103ad63:	5e                   	pop    %esi
c103ad64:	5f                   	pop    %edi
c103ad65:	5d                   	pop    %ebp
c103ad66:	c3                   	ret

c103ad67 <ftrace_raw_output_timer_start>:
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103ad67:	55                   	push   %ebp
c103ad68:	83 e9 14             	sub    $0x14,%ecx
#endif
	default:
		break;
	}
	return NOTIFY_OK;
}
c103ad6b:	89 e5                	mov    %esp,%ebp
c103ad6d:	56                   	push   %esi
c103ad6e:	53                   	push   %ebx
c103ad6f:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103ad75:	0f b7 13             	movzwl (%ebx),%edx
c103ad78:	3b 51 24             	cmp    0x24(%ecx),%edx
c103ad7b:	74 2f                	je     c103adac <ftrace_raw_output_timer_start+0x45>
c103ad7d:	80 3d 40 10 00 00 01 	cmpb   $0x1,0x1040
c103ad84:	b8 02 00 00 00       	mov    $0x2,%eax
c103ad89:	0f 84 80 00 00 00    	je     c103ae0f <ftrace_raw_output_timer_start+0xa8>
c103ad8f:	b8 0f 00 00 00       	mov    $0xf,%eax
c103ad94:	ba 43 00 00 00       	mov    $0x43,%edx
c103ad99:	e8 fc ff ff ff       	call   c103ad9a <ftrace_raw_output_timer_start+0x33>
c103ad9e:	b8 02 00 00 00       	mov    $0x2,%eax
c103ada3:	c6 05 40 10 00 00 01 	movb   $0x1,0x1040
c103adaa:	eb 63                	jmp    c103ae0f <ftrace_raw_output_timer_start+0xa8>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103adac:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103adb3:	00 00 00
c103adb6:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103adbc:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103adc3:	00 00 00
	s->full = 0;
c103adc6:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103adcd:	00 00 00
c103add0:	ff 71 0c             	pushl  0xc(%ecx)
c103add3:	68 2c 00 00 00       	push   $0x2c
c103add8:	56                   	push   %esi
c103add9:	e8 fc ff ff ff       	call   c103adda <ftrace_raw_output_timer_start+0x73>
c103adde:	89 c2                	mov    %eax,%edx
c103ade0:	83 c4 0c             	add    $0xc,%esp
c103ade3:	31 c0                	xor    %eax,%eax
c103ade5:	85 d2                	test   %edx,%edx
c103ade7:	74 26                	je     c103ae0f <ftrace_raw_output_timer_start+0xa8>
c103ade9:	8b 43 14             	mov    0x14(%ebx),%eax
c103adec:	89 c2                	mov    %eax,%edx
c103adee:	2b 53 18             	sub    0x18(%ebx),%edx
c103adf1:	52                   	push   %edx
c103adf2:	50                   	push   %eax
c103adf3:	ff 73 10             	pushl  0x10(%ebx)
c103adf6:	ff 73 0c             	pushl  0xc(%ebx)
c103adf9:	68 31 00 00 00       	push   $0x31
c103adfe:	56                   	push   %esi
c103adff:	e8 fc ff ff ff       	call   c103ae00 <ftrace_raw_output_timer_start+0x99>
c103ae04:	83 c4 18             	add    $0x18,%esp
c103ae07:	85 c0                	test   %eax,%eax
c103ae09:	0f 95 c0             	setne  %al
c103ae0c:	0f b6 c0             	movzbl %al,%eax
c103ae0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103ae12:	5b                   	pop    %ebx
c103ae13:	5e                   	pop    %esi
c103ae14:	5d                   	pop    %ebp
c103ae15:	c3                   	ret

c103ae16 <ftrace_raw_output_timer_expire_entry>:
 * timer_expire_entry - called immediately before the timer callback
 * @timer:	pointer to struct timer_list
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(timer_expire_entry,
c103ae16:	55                   	push   %ebp
c103ae17:	83 e9 14             	sub    $0x14,%ecx
c103ae1a:	89 e5                	mov    %esp,%ebp
c103ae1c:	56                   	push   %esi
c103ae1d:	53                   	push   %ebx
c103ae1e:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103ae24:	0f b7 13             	movzwl (%ebx),%edx
c103ae27:	3b 51 24             	cmp    0x24(%ecx),%edx
c103ae2a:	74 2b                	je     c103ae57 <ftrace_raw_output_timer_expire_entry+0x41>
c103ae2c:	80 3d 41 10 00 00 01 	cmpb   $0x1,0x1041
c103ae33:	b8 02 00 00 00       	mov    $0x2,%eax
c103ae38:	74 79                	je     c103aeb3 <ftrace_raw_output_timer_expire_entry+0x9d>
c103ae3a:	b8 0f 00 00 00       	mov    $0xf,%eax
c103ae3f:	ba 5e 00 00 00       	mov    $0x5e,%edx
c103ae44:	e8 fc ff ff ff       	call   c103ae45 <ftrace_raw_output_timer_expire_entry+0x2f>
c103ae49:	b8 02 00 00 00       	mov    $0x2,%eax
c103ae4e:	c6 05 41 10 00 00 01 	movb   $0x1,0x1041
c103ae55:	eb 5c                	jmp    c103aeb3 <ftrace_raw_output_timer_expire_entry+0x9d>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103ae57:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103ae5e:	00 00 00
c103ae61:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103ae67:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103ae6e:	00 00 00
	s->full = 0;
c103ae71:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103ae78:	00 00 00
c103ae7b:	ff 71 0c             	pushl  0xc(%ecx)
c103ae7e:	68 2c 00 00 00       	push   $0x2c
c103ae83:	56                   	push   %esi
c103ae84:	e8 fc ff ff ff       	call   c103ae85 <ftrace_raw_output_timer_expire_entry+0x6f>
c103ae89:	89 c2                	mov    %eax,%edx
c103ae8b:	83 c4 0c             	add    $0xc,%esp
c103ae8e:	31 c0                	xor    %eax,%eax
c103ae90:	85 d2                	test   %edx,%edx
c103ae92:	74 1f                	je     c103aeb3 <ftrace_raw_output_timer_expire_entry+0x9d>
c103ae94:	ff 73 10             	pushl  0x10(%ebx)
c103ae97:	ff 73 14             	pushl  0x14(%ebx)
c103ae9a:	ff 73 0c             	pushl  0xc(%ebx)
c103ae9d:	68 62 00 00 00       	push   $0x62
c103aea2:	56                   	push   %esi
c103aea3:	e8 fc ff ff ff       	call   c103aea4 <ftrace_raw_output_timer_expire_entry+0x8e>
c103aea8:	83 c4 14             	add    $0x14,%esp
c103aeab:	85 c0                	test   %eax,%eax
c103aead:	0f 95 c0             	setne  %al
c103aeb0:	0f b6 c0             	movzbl %al,%eax
c103aeb3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103aeb6:	5b                   	pop    %ebx
c103aeb7:	5e                   	pop    %esi
c103aeb8:	5d                   	pop    %ebp
c103aeb9:	c3                   	ret

c103aeba <ftrace_raw_output_timer_class>:

#include <linux/tracepoint.h>
#include <linux/hrtimer.h>
#include <linux/timer.h>

DECLARE_EVENT_CLASS(timer_class,
c103aeba:	55                   	push   %ebp
c103aebb:	83 e9 14             	sub    $0x14,%ecx
c103aebe:	89 e5                	mov    %esp,%ebp
c103aec0:	56                   	push   %esi
c103aec1:	53                   	push   %ebx
c103aec2:	8b b0 60 20 00 00    	mov    0x2060(%eax),%esi
c103aec8:	0f b7 16             	movzwl (%esi),%edx
c103aecb:	3b 51 24             	cmp    0x24(%ecx),%edx
c103aece:	74 2b                	je     c103aefb <ftrace_raw_output_timer_class+0x41>
c103aed0:	80 3d 42 10 00 00 01 	cmpb   $0x1,0x1042
c103aed7:	b8 02 00 00 00       	mov    $0x2,%eax
c103aedc:	74 73                	je     c103af51 <ftrace_raw_output_timer_class+0x97>
c103aede:	b8 0f 00 00 00       	mov    $0xf,%eax
c103aee3:	ba 1a 00 00 00       	mov    $0x1a,%edx
c103aee8:	e8 fc ff ff ff       	call   c103aee9 <ftrace_raw_output_timer_class+0x2f>
c103aeed:	b8 02 00 00 00       	mov    $0x2,%eax
c103aef2:	c6 05 42 10 00 00 01 	movb   $0x1,0x1042
c103aef9:	eb 56                	jmp    c103af51 <ftrace_raw_output_timer_class+0x97>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103aefb:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103af02:	00 00 00
c103af05:	8d 98 54 10 00 00    	lea    0x1054(%eax),%ebx
	s->readpos = 0;
c103af0b:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103af12:	00 00 00
	s->full = 0;
c103af15:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103af1c:	00 00 00
c103af1f:	ff 71 0c             	pushl  0xc(%ecx)
c103af22:	68 2c 00 00 00       	push   $0x2c
c103af27:	53                   	push   %ebx
c103af28:	e8 fc ff ff ff       	call   c103af29 <ftrace_raw_output_timer_class+0x6f>
c103af2d:	89 c2                	mov    %eax,%edx
c103af2f:	83 c4 0c             	add    $0xc,%esp
c103af32:	31 c0                	xor    %eax,%eax
c103af34:	85 d2                	test   %edx,%edx
c103af36:	74 19                	je     c103af51 <ftrace_raw_output_timer_class+0x97>
c103af38:	ff 76 0c             	pushl  0xc(%esi)
c103af3b:	68 81 00 00 00       	push   $0x81
c103af40:	53                   	push   %ebx
c103af41:	e8 fc ff ff ff       	call   c103af42 <ftrace_raw_output_timer_class+0x88>
c103af46:	83 c4 0c             	add    $0xc,%esp
c103af49:	85 c0                	test   %eax,%eax
c103af4b:	0f 95 c0             	setne  %al
c103af4e:	0f b6 c0             	movzbl %al,%eax
c103af51:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103af54:	5b                   	pop    %ebx
c103af55:	5e                   	pop    %esi
c103af56:	5d                   	pop    %ebp
c103af57:	c3                   	ret

c103af58 <ftrace_raw_output_hrtimer_init>:
 * hrtimer_init - called when the hrtimer is initialized
 * @timer:	pointer to struct hrtimer
 * @clockid:	the hrtimers clock
 * @mode:	the hrtimers mode
 */
TRACE_EVENT(hrtimer_init,
c103af58:	55                   	push   %ebp
c103af59:	83 e9 14             	sub    $0x14,%ecx
c103af5c:	89 e5                	mov    %esp,%ebp
c103af5e:	56                   	push   %esi
c103af5f:	53                   	push   %ebx
c103af60:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103af66:	0f b7 13             	movzwl (%ebx),%edx
c103af69:	3b 51 24             	cmp    0x24(%ecx),%edx
c103af6c:	74 2f                	je     c103af9d <ftrace_raw_output_hrtimer_init+0x45>
c103af6e:	80 3d 43 10 00 00 01 	cmpb   $0x1,0x1043
c103af75:	b8 02 00 00 00       	mov    $0x2,%eax
c103af7a:	0f 84 97 00 00 00    	je     c103b017 <ftrace_raw_output_hrtimer_init+0xbf>
c103af80:	b8 0f 00 00 00       	mov    $0xf,%eax
c103af85:	ba 9a 00 00 00       	mov    $0x9a,%edx
c103af8a:	e8 fc ff ff ff       	call   c103af8b <ftrace_raw_output_hrtimer_init+0x33>
c103af8f:	b8 02 00 00 00       	mov    $0x2,%eax
c103af94:	c6 05 43 10 00 00 01 	movb   $0x1,0x1043
c103af9b:	eb 7a                	jmp    c103b017 <ftrace_raw_output_hrtimer_init+0xbf>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103af9d:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103afa4:	00 00 00
c103afa7:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103afad:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103afb4:	00 00 00
	s->full = 0;
c103afb7:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103afbe:	00 00 00
c103afc1:	ff 71 0c             	pushl  0xc(%ecx)
c103afc4:	68 2c 00 00 00       	push   $0x2c
c103afc9:	56                   	push   %esi
c103afca:	e8 fc ff ff ff       	call   c103afcb <ftrace_raw_output_hrtimer_init+0x73>
c103afcf:	89 c2                	mov    %eax,%edx
c103afd1:	83 c4 0c             	add    $0xc,%esp
c103afd4:	31 c0                	xor    %eax,%eax
c103afd6:	85 d2                	test   %edx,%edx
c103afd8:	74 3d                	je     c103b017 <ftrace_raw_output_hrtimer_init+0xbf>
c103afda:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
c103afde:	b8 9c 00 00 00       	mov    $0x9c,%eax
c103afe3:	ba 8b 00 00 00       	mov    $0x8b,%edx
c103afe8:	b9 bd 00 00 00       	mov    $0xbd,%ecx
c103afed:	0f 44 d0             	cmove  %eax,%edx
c103aff0:	b8 ad 00 00 00       	mov    $0xad,%eax
c103aff5:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
c103aff9:	52                   	push   %edx
c103affa:	0f 44 c1             	cmove  %ecx,%eax
c103affd:	50                   	push   %eax
c103affe:	ff 73 0c             	pushl  0xc(%ebx)
c103b001:	68 cc 00 00 00       	push   $0xcc
c103b006:	56                   	push   %esi
c103b007:	e8 fc ff ff ff       	call   c103b008 <ftrace_raw_output_hrtimer_init+0xb0>
c103b00c:	83 c4 14             	add    $0x14,%esp
c103b00f:	85 c0                	test   %eax,%eax
c103b011:	0f 95 c0             	setne  %al
c103b014:	0f b6 c0             	movzbl %al,%eax
c103b017:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b01a:	5b                   	pop    %ebx
c103b01b:	5e                   	pop    %esi
c103b01c:	5d                   	pop    %ebp
c103b01d:	c3                   	ret

c103b01e <ftrace_raw_output_hrtimer_start>:

/**
 * hrtimer_start - called when the hrtimer is started
 * @timer: pointer to struct hrtimer
 */
TRACE_EVENT(hrtimer_start,
c103b01e:	55                   	push   %ebp
c103b01f:	83 e9 14             	sub    $0x14,%ecx
c103b022:	89 e5                	mov    %esp,%ebp
c103b024:	56                   	push   %esi
c103b025:	53                   	push   %ebx
c103b026:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103b02c:	0f b7 13             	movzwl (%ebx),%edx
c103b02f:	3b 51 24             	cmp    0x24(%ecx),%edx
c103b032:	74 2f                	je     c103b063 <ftrace_raw_output_hrtimer_start+0x45>
c103b034:	80 3d 44 10 00 00 01 	cmpb   $0x1,0x1044
c103b03b:	b8 02 00 00 00       	mov    $0x2,%eax
c103b040:	0f 84 82 00 00 00    	je     c103b0c8 <ftrace_raw_output_hrtimer_start+0xaa>
c103b046:	b8 0f 00 00 00       	mov    $0xf,%eax
c103b04b:	ba ba 00 00 00       	mov    $0xba,%edx
c103b050:	e8 fc ff ff ff       	call   c103b051 <ftrace_raw_output_hrtimer_start+0x33>
c103b055:	b8 02 00 00 00       	mov    $0x2,%eax
c103b05a:	c6 05 44 10 00 00 01 	movb   $0x1,0x1044
c103b061:	eb 65                	jmp    c103b0c8 <ftrace_raw_output_hrtimer_start+0xaa>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103b063:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103b06a:	00 00 00
c103b06d:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103b073:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103b07a:	00 00 00
	s->full = 0;
c103b07d:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103b084:	00 00 00
c103b087:	ff 71 0c             	pushl  0xc(%ecx)
c103b08a:	68 2c 00 00 00       	push   $0x2c
c103b08f:	56                   	push   %esi
c103b090:	e8 fc ff ff ff       	call   c103b091 <ftrace_raw_output_hrtimer_start+0x73>
c103b095:	89 c2                	mov    %eax,%edx
c103b097:	83 c4 0c             	add    $0xc,%esp
c103b09a:	31 c0                	xor    %eax,%eax
c103b09c:	85 d2                	test   %edx,%edx
c103b09e:	74 28                	je     c103b0c8 <ftrace_raw_output_hrtimer_start+0xaa>
c103b0a0:	ff 73 20             	pushl  0x20(%ebx)
c103b0a3:	ff 73 1c             	pushl  0x1c(%ebx)
c103b0a6:	ff 73 18             	pushl  0x18(%ebx)
c103b0a9:	ff 73 14             	pushl  0x14(%ebx)
c103b0ac:	ff 73 10             	pushl  0x10(%ebx)
c103b0af:	ff 73 0c             	pushl  0xc(%ebx)
c103b0b2:	68 eb 00 00 00       	push   $0xeb
c103b0b7:	56                   	push   %esi
c103b0b8:	e8 fc ff ff ff       	call   c103b0b9 <ftrace_raw_output_hrtimer_start+0x9b>
c103b0bd:	83 c4 20             	add    $0x20,%esp
c103b0c0:	85 c0                	test   %eax,%eax
c103b0c2:	0f 95 c0             	setne  %al
c103b0c5:	0f b6 c0             	movzbl %al,%eax
c103b0c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b0cb:	5b                   	pop    %ebx
c103b0cc:	5e                   	pop    %esi
c103b0cd:	5d                   	pop    %ebp
c103b0ce:	c3                   	ret

c103b0cf <ftrace_raw_output_hrtimer_expire_entry>:
 * @now:	pointer to variable which contains current time of the
 *		timers base.
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(hrtimer_expire_entry,
c103b0cf:	55                   	push   %ebp
c103b0d0:	83 e9 14             	sub    $0x14,%ecx
c103b0d3:	89 e5                	mov    %esp,%ebp
c103b0d5:	56                   	push   %esi
c103b0d6:	53                   	push   %ebx
c103b0d7:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103b0dd:	0f b7 13             	movzwl (%ebx),%edx
c103b0e0:	3b 51 24             	cmp    0x24(%ecx),%edx
c103b0e3:	74 2b                	je     c103b110 <ftrace_raw_output_hrtimer_expire_entry+0x41>
c103b0e5:	80 3d 45 10 00 00 01 	cmpb   $0x1,0x1045
c103b0ec:	b8 02 00 00 00       	mov    $0x2,%eax
c103b0f1:	74 7c                	je     c103b16f <ftrace_raw_output_hrtimer_expire_entry+0xa0>
c103b0f3:	b8 0f 00 00 00       	mov    $0xf,%eax
c103b0f8:	ba d8 00 00 00       	mov    $0xd8,%edx
c103b0fd:	e8 fc ff ff ff       	call   c103b0fe <ftrace_raw_output_hrtimer_expire_entry+0x2f>
c103b102:	b8 02 00 00 00       	mov    $0x2,%eax
c103b107:	c6 05 45 10 00 00 01 	movb   $0x1,0x1045
c103b10e:	eb 5f                	jmp    c103b16f <ftrace_raw_output_hrtimer_expire_entry+0xa0>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103b110:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103b117:	00 00 00
c103b11a:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103b120:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103b127:	00 00 00
	s->full = 0;
c103b12a:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103b131:	00 00 00
c103b134:	ff 71 0c             	pushl  0xc(%ecx)
c103b137:	68 2c 00 00 00       	push   $0x2c
c103b13c:	56                   	push   %esi
c103b13d:	e8 fc ff ff ff       	call   c103b13e <ftrace_raw_output_hrtimer_expire_entry+0x6f>
c103b142:	89 c2                	mov    %eax,%edx
c103b144:	83 c4 0c             	add    $0xc,%esp
c103b147:	31 c0                	xor    %eax,%eax
c103b149:	85 d2                	test   %edx,%edx
c103b14b:	74 22                	je     c103b16f <ftrace_raw_output_hrtimer_expire_entry+0xa0>
c103b14d:	ff 73 14             	pushl  0x14(%ebx)
c103b150:	ff 73 10             	pushl  0x10(%ebx)
c103b153:	ff 73 18             	pushl  0x18(%ebx)
c103b156:	ff 73 0c             	pushl  0xc(%ebx)
c103b159:	68 22 01 00 00       	push   $0x122
c103b15e:	56                   	push   %esi
c103b15f:	e8 fc ff ff ff       	call   c103b160 <ftrace_raw_output_hrtimer_expire_entry+0x91>
c103b164:	83 c4 18             	add    $0x18,%esp
c103b167:	85 c0                	test   %eax,%eax
c103b169:	0f 95 c0             	setne  %al
c103b16c:	0f b6 c0             	movzbl %al,%eax
c103b16f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b172:	5b                   	pop    %ebx
c103b173:	5e                   	pop    %esi
c103b174:	5d                   	pop    %ebp
c103b175:	c3                   	ret

c103b176 <ftrace_raw_output_hrtimer_class>:

	TP_printk("hrtimer=%p function=%pf now=%llu", __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) { .tv64 = __entry->now }))
 );

DECLARE_EVENT_CLASS(hrtimer_class,
c103b176:	55                   	push   %ebp
c103b177:	83 e9 14             	sub    $0x14,%ecx
c103b17a:	89 e5                	mov    %esp,%ebp
c103b17c:	56                   	push   %esi
c103b17d:	53                   	push   %ebx
c103b17e:	8b b0 60 20 00 00    	mov    0x2060(%eax),%esi
c103b184:	0f b7 16             	movzwl (%esi),%edx
c103b187:	3b 51 24             	cmp    0x24(%ecx),%edx
c103b18a:	74 2b                	je     c103b1b7 <ftrace_raw_output_hrtimer_class+0x41>
c103b18c:	80 3d 46 10 00 00 01 	cmpb   $0x1,0x1046
c103b193:	b8 02 00 00 00       	mov    $0x2,%eax
c103b198:	74 73                	je     c103b20d <ftrace_raw_output_hrtimer_class+0x97>
c103b19a:	b8 0f 00 00 00       	mov    $0xf,%eax
c103b19f:	ba e9 00 00 00       	mov    $0xe9,%edx
c103b1a4:	e8 fc ff ff ff       	call   c103b1a5 <ftrace_raw_output_hrtimer_class+0x2f>
c103b1a9:	b8 02 00 00 00       	mov    $0x2,%eax
c103b1ae:	c6 05 46 10 00 00 01 	movb   $0x1,0x1046
c103b1b5:	eb 56                	jmp    c103b20d <ftrace_raw_output_hrtimer_class+0x97>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103b1b7:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103b1be:	00 00 00
c103b1c1:	8d 98 54 10 00 00    	lea    0x1054(%eax),%ebx
	s->readpos = 0;
c103b1c7:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103b1ce:	00 00 00
	s->full = 0;
c103b1d1:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103b1d8:	00 00 00
c103b1db:	ff 71 0c             	pushl  0xc(%ecx)
c103b1de:	68 2c 00 00 00       	push   $0x2c
c103b1e3:	53                   	push   %ebx
c103b1e4:	e8 fc ff ff ff       	call   c103b1e5 <ftrace_raw_output_hrtimer_class+0x6f>
c103b1e9:	89 c2                	mov    %eax,%edx
c103b1eb:	83 c4 0c             	add    $0xc,%esp
c103b1ee:	31 c0                	xor    %eax,%eax
c103b1f0:	85 d2                	test   %edx,%edx
c103b1f2:	74 19                	je     c103b20d <ftrace_raw_output_hrtimer_class+0x97>
c103b1f4:	ff 76 0c             	pushl  0xc(%esi)
c103b1f7:	68 44 01 00 00       	push   $0x144
c103b1fc:	53                   	push   %ebx
c103b1fd:	e8 fc ff ff ff       	call   c103b1fe <ftrace_raw_output_hrtimer_class+0x88>
c103b202:	83 c4 0c             	add    $0xc,%esp
c103b205:	85 c0                	test   %eax,%eax
c103b207:	0f 95 c0             	setne  %al
c103b20a:	0f b6 c0             	movzbl %al,%eax
c103b20d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b210:	5b                   	pop    %ebx
c103b211:	5e                   	pop    %esi
c103b212:	5d                   	pop    %ebp
c103b213:	c3                   	ret

c103b214 <ftrace_raw_output_itimer_state>:
 * @which:	name of the interval timer
 * @value:	the itimers value, itimer is canceled if value->it_value is
 *		zero, otherwise it is started
 * @expires:	the itimers expiry time
 */
TRACE_EVENT(itimer_state,
c103b214:	55                   	push   %ebp
c103b215:	83 e9 14             	sub    $0x14,%ecx
c103b218:	89 e5                	mov    %esp,%ebp
c103b21a:	56                   	push   %esi
c103b21b:	53                   	push   %ebx
c103b21c:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103b222:	0f b7 13             	movzwl (%ebx),%edx
c103b225:	3b 51 24             	cmp    0x24(%ecx),%edx
c103b228:	74 2f                	je     c103b259 <ftrace_raw_output_itimer_state+0x45>
c103b22a:	80 3d 47 10 00 00 01 	cmpb   $0x1,0x1047
c103b231:	b8 02 00 00 00       	mov    $0x2,%eax
c103b236:	0f 84 86 00 00 00    	je     c103b2c2 <ftrace_raw_output_itimer_state+0xae>
c103b23c:	b8 0f 00 00 00       	mov    $0xf,%eax
c103b241:	ba 28 01 00 00       	mov    $0x128,%edx
c103b246:	e8 fc ff ff ff       	call   c103b247 <ftrace_raw_output_itimer_state+0x33>
c103b24b:	b8 02 00 00 00       	mov    $0x2,%eax
c103b250:	c6 05 47 10 00 00 01 	movb   $0x1,0x1047
c103b257:	eb 69                	jmp    c103b2c2 <ftrace_raw_output_itimer_state+0xae>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103b259:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103b260:	00 00 00
c103b263:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103b269:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103b270:	00 00 00
	s->full = 0;
c103b273:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103b27a:	00 00 00
c103b27d:	ff 71 0c             	pushl  0xc(%ecx)
c103b280:	68 2c 00 00 00       	push   $0x2c
c103b285:	56                   	push   %esi
c103b286:	e8 fc ff ff ff       	call   c103b287 <ftrace_raw_output_itimer_state+0x73>
c103b28b:	89 c2                	mov    %eax,%edx
c103b28d:	83 c4 0c             	add    $0xc,%esp
c103b290:	31 c0                	xor    %eax,%eax
c103b292:	85 d2                	test   %edx,%edx
c103b294:	74 2c                	je     c103b2c2 <ftrace_raw_output_itimer_state+0xae>
c103b296:	ff 73 20             	pushl  0x20(%ebx)
c103b299:	31 d2                	xor    %edx,%edx
c103b29b:	ff 73 1c             	pushl  0x1c(%ebx)
c103b29e:	ff 73 18             	pushl  0x18(%ebx)
c103b2a1:	ff 73 14             	pushl  0x14(%ebx)
c103b2a4:	8b 43 10             	mov    0x10(%ebx),%eax
c103b2a7:	52                   	push   %edx
c103b2a8:	50                   	push   %eax
c103b2a9:	ff 73 0c             	pushl  0xc(%ebx)
c103b2ac:	68 50 01 00 00       	push   $0x150
c103b2b1:	56                   	push   %esi
c103b2b2:	e8 fc ff ff ff       	call   c103b2b3 <ftrace_raw_output_itimer_state+0x9f>
c103b2b7:	83 c4 24             	add    $0x24,%esp
c103b2ba:	85 c0                	test   %eax,%eax
c103b2bc:	0f 95 c0             	setne  %al
c103b2bf:	0f b6 c0             	movzbl %al,%eax
c103b2c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b2c5:	5b                   	pop    %ebx
c103b2c6:	5e                   	pop    %esi
c103b2c7:	5d                   	pop    %ebp
c103b2c8:	c3                   	ret

c103b2c9 <ftrace_raw_output_itimer_expire>:
 * itimer_expire - called when itimer expires
 * @which:	type of the interval timer
 * @pid:	pid of the process which owns the timer
 * @now:	current time, used to calculate the latency of itimer
 */
TRACE_EVENT(itimer_expire,
c103b2c9:	55                   	push   %ebp
c103b2ca:	83 e9 14             	sub    $0x14,%ecx
c103b2cd:	89 e5                	mov    %esp,%ebp
c103b2cf:	56                   	push   %esi
c103b2d0:	53                   	push   %ebx
c103b2d1:	8b 98 60 20 00 00    	mov    0x2060(%eax),%ebx
c103b2d7:	0f b7 13             	movzwl (%ebx),%edx
c103b2da:	3b 51 24             	cmp    0x24(%ecx),%edx
c103b2dd:	74 2b                	je     c103b30a <ftrace_raw_output_itimer_expire+0x41>
c103b2df:	80 3d 48 10 00 00 01 	cmpb   $0x1,0x1048
c103b2e6:	b8 02 00 00 00       	mov    $0x2,%eax
c103b2eb:	74 7d                	je     c103b36a <ftrace_raw_output_itimer_expire+0xa1>
c103b2ed:	b8 0f 00 00 00       	mov    $0xf,%eax
c103b2f2:	ba 44 01 00 00       	mov    $0x144,%edx
c103b2f7:	e8 fc ff ff ff       	call   c103b2f8 <ftrace_raw_output_itimer_expire+0x2f>
c103b2fc:	b8 02 00 00 00       	mov    $0x2,%eax
c103b301:	c6 05 48 10 00 00 01 	movb   $0x1,0x1048
c103b308:	eb 60                	jmp    c103b36a <ftrace_raw_output_itimer_expire+0xa1>
};

static inline void
trace_seq_init(struct trace_seq *s)
{
	s->len = 0;
c103b30a:	c7 80 48 10 00 00 00 	movl   $0x0,0x1048(%eax)
c103b311:	00 00 00
c103b314:	8d b0 54 10 00 00    	lea    0x1054(%eax),%esi
	s->readpos = 0;
c103b31a:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
c103b321:	00 00 00
	s->full = 0;
c103b324:	c7 80 50 10 00 00 00 	movl   $0x0,0x1050(%eax)
c103b32b:	00 00 00
c103b32e:	ff 71 0c             	pushl  0xc(%ecx)
c103b331:	68 2c 00 00 00       	push   $0x2c
c103b336:	56                   	push   %esi
c103b337:	e8 fc ff ff ff       	call   c103b338 <ftrace_raw_output_itimer_expire+0x6f>
c103b33c:	89 c2                	mov    %eax,%edx
c103b33e:	83 c4 0c             	add    $0xc,%esp
c103b341:	31 c0                	xor    %eax,%eax
c103b343:	85 d2                	test   %edx,%edx
c103b345:	74 23                	je     c103b36a <ftrace_raw_output_itimer_expire+0xa1>
c103b347:	8b 43 14             	mov    0x14(%ebx),%eax
c103b34a:	31 d2                	xor    %edx,%edx
c103b34c:	52                   	push   %edx
c103b34d:	50                   	push   %eax
c103b34e:	ff 73 10             	pushl  0x10(%ebx)
c103b351:	ff 73 0c             	pushl  0xc(%ebx)
c103b354:	68 8c 01 00 00       	push   $0x18c
c103b359:	56                   	push   %esi
c103b35a:	e8 fc ff ff ff       	call   c103b35b <ftrace_raw_output_itimer_expire+0x92>
c103b35f:	83 c4 18             	add    $0x18,%esp
c103b362:	85 c0                	test   %eax,%eax
c103b364:	0f 95 c0             	setne  %al
c103b367:	0f b6 c0             	movzbl %al,%eax
c103b36a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103b36d:	5b                   	pop    %ebx
c103b36e:	5e                   	pop    %esi
c103b36f:	5d                   	pop    %ebp
c103b370:	c3                   	ret

c103b371 <ftrace_define_fields_timer_class>:

#include <linux/tracepoint.h>
#include <linux/hrtimer.h>
#include <linux/timer.h>

DECLARE_EVENT_CLASS(timer_class,
c103b371:	55                   	push   %ebp
c103b372:	b9 a6 01 00 00       	mov    $0x1a6,%ecx
c103b377:	89 e5                	mov    %esp,%ebp
c103b379:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b37e:	6a 00                	push   $0x0
c103b380:	6a 00                	push   $0x0
c103b382:	6a 04                	push   $0x4
c103b384:	6a 0c                	push   $0xc
c103b386:	e8 fc ff ff ff       	call   c103b387 <ftrace_define_fields_timer_class+0x16>
	TP_fast_assign(
		__entry->timer	= timer;
	),

	TP_printk("timer=%p", __entry->timer)
);
c103b38b:	c9                   	leave
c103b38c:	c3                   	ret

c103b38d <ftrace_define_fields_timer_start>:
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103b38d:	55                   	push   %ebp
c103b38e:	b9 a6 01 00 00       	mov    $0x1a6,%ecx
c103b393:	89 e5                	mov    %esp,%ebp
c103b395:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b39a:	53                   	push   %ebx
c103b39b:	89 c3                	mov    %eax,%ebx
c103b39d:	6a 00                	push   $0x0
c103b39f:	6a 00                	push   $0x0
c103b3a1:	6a 04                	push   $0x4
c103b3a3:	6a 0c                	push   $0xc
c103b3a5:	e8 fc ff ff ff       	call   c103b3a6 <ftrace_define_fields_timer_start+0x19>
c103b3aa:	83 c4 10             	add    $0x10,%esp
c103b3ad:	85 c0                	test   %eax,%eax
c103b3af:	75 5c                	jne    c103b40d <ftrace_define_fields_timer_start+0x80>
c103b3b1:	6a 00                	push   $0x0
c103b3b3:	b9 b3 01 00 00       	mov    $0x1b3,%ecx
c103b3b8:	6a 00                	push   $0x0
c103b3ba:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b3bf:	6a 04                	push   $0x4
c103b3c1:	89 d8                	mov    %ebx,%eax
c103b3c3:	6a 10                	push   $0x10
c103b3c5:	e8 fc ff ff ff       	call   c103b3c6 <ftrace_define_fields_timer_start+0x39>
c103b3ca:	83 c4 10             	add    $0x10,%esp
c103b3cd:	85 c0                	test   %eax,%eax
c103b3cf:	75 3c                	jne    c103b40d <ftrace_define_fields_timer_start+0x80>
c103b3d1:	6a 00                	push   $0x0
c103b3d3:	b9 bc 01 00 00       	mov    $0x1bc,%ecx
c103b3d8:	6a 00                	push   $0x0
c103b3da:	ba c4 01 00 00       	mov    $0x1c4,%edx
c103b3df:	6a 04                	push   $0x4
c103b3e1:	89 d8                	mov    %ebx,%eax
c103b3e3:	6a 14                	push   $0x14
c103b3e5:	e8 fc ff ff ff       	call   c103b3e6 <ftrace_define_fields_timer_start+0x59>
c103b3ea:	83 c4 10             	add    $0x10,%esp
c103b3ed:	85 c0                	test   %eax,%eax
c103b3ef:	75 1c                	jne    c103b40d <ftrace_define_fields_timer_start+0x80>
c103b3f1:	6a 00                	push   $0x0
c103b3f3:	b9 d2 01 00 00       	mov    $0x1d2,%ecx
c103b3f8:	6a 00                	push   $0x0
c103b3fa:	ba c4 01 00 00       	mov    $0x1c4,%edx
c103b3ff:	6a 04                	push   $0x4
c103b401:	89 d8                	mov    %ebx,%eax
c103b403:	6a 18                	push   $0x18
c103b405:	e8 fc ff ff ff       	call   c103b406 <ftrace_define_fields_timer_start+0x79>
c103b40a:	83 c4 10             	add    $0x10,%esp
	),

	TP_printk("timer=%p function=%pf expires=%lu [timeout=%ld]",
		  __entry->timer, __entry->function, __entry->expires,
		  (long)__entry->expires - __entry->now)
);
c103b40d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b410:	c9                   	leave
c103b411:	c3                   	ret

c103b412 <ftrace_define_fields_timer_expire_entry>:
 * timer_expire_entry - called immediately before the timer callback
 * @timer:	pointer to struct timer_list
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(timer_expire_entry,
c103b412:	55                   	push   %ebp
c103b413:	b9 a6 01 00 00       	mov    $0x1a6,%ecx
c103b418:	89 e5                	mov    %esp,%ebp
c103b41a:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b41f:	53                   	push   %ebx
c103b420:	89 c3                	mov    %eax,%ebx
c103b422:	6a 00                	push   $0x0
c103b424:	6a 00                	push   $0x0
c103b426:	6a 04                	push   $0x4
c103b428:	6a 0c                	push   $0xc
c103b42a:	e8 fc ff ff ff       	call   c103b42b <ftrace_define_fields_timer_expire_entry+0x19>
c103b42f:	83 c4 10             	add    $0x10,%esp
c103b432:	85 c0                	test   %eax,%eax
c103b434:	75 3c                	jne    c103b472 <ftrace_define_fields_timer_expire_entry+0x60>
c103b436:	6a 00                	push   $0x0
c103b438:	b9 d2 01 00 00       	mov    $0x1d2,%ecx
c103b43d:	6a 00                	push   $0x0
c103b43f:	ba c4 01 00 00       	mov    $0x1c4,%edx
c103b444:	6a 04                	push   $0x4
c103b446:	89 d8                	mov    %ebx,%eax
c103b448:	6a 10                	push   $0x10
c103b44a:	e8 fc ff ff ff       	call   c103b44b <ftrace_define_fields_timer_expire_entry+0x39>
c103b44f:	83 c4 10             	add    $0x10,%esp
c103b452:	85 c0                	test   %eax,%eax
c103b454:	75 1c                	jne    c103b472 <ftrace_define_fields_timer_expire_entry+0x60>
c103b456:	6a 00                	push   $0x0
c103b458:	b9 b3 01 00 00       	mov    $0x1b3,%ecx
c103b45d:	6a 00                	push   $0x0
c103b45f:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b464:	6a 04                	push   $0x4
c103b466:	89 d8                	mov    %ebx,%eax
c103b468:	6a 14                	push   $0x14
c103b46a:	e8 fc ff ff ff       	call   c103b46b <ftrace_define_fields_timer_expire_entry+0x59>
c103b46f:	83 c4 10             	add    $0x10,%esp
		__entry->now		= jiffies;
		__entry->function	= timer->function;
	),

	TP_printk("timer=%p function=%pf now=%lu", __entry->timer, __entry->function,__entry->now)
);
c103b472:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b475:	c9                   	leave
c103b476:	c3                   	ret

c103b477 <ftrace_define_fields_hrtimer_init>:
 * hrtimer_init - called when the hrtimer is initialized
 * @timer:	pointer to struct hrtimer
 * @clockid:	the hrtimers clock
 * @mode:	the hrtimers mode
 */
TRACE_EVENT(hrtimer_init,
c103b477:	55                   	push   %ebp
c103b478:	b9 d6 01 00 00       	mov    $0x1d6,%ecx
c103b47d:	89 e5                	mov    %esp,%ebp
c103b47f:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b484:	53                   	push   %ebx
c103b485:	89 c3                	mov    %eax,%ebx
c103b487:	6a 00                	push   $0x0
c103b489:	6a 00                	push   $0x0
c103b48b:	6a 04                	push   $0x4
c103b48d:	6a 0c                	push   $0xc
c103b48f:	e8 fc ff ff ff       	call   c103b490 <ftrace_define_fields_hrtimer_init+0x19>
c103b494:	83 c4 10             	add    $0x10,%esp
c103b497:	85 c0                	test   %eax,%eax
c103b499:	75 3c                	jne    c103b4d7 <ftrace_define_fields_hrtimer_init+0x60>
c103b49b:	6a 00                	push   $0x0
c103b49d:	b9 de 01 00 00       	mov    $0x1de,%ecx
c103b4a2:	6a 01                	push   $0x1
c103b4a4:	ba e6 01 00 00       	mov    $0x1e6,%edx
c103b4a9:	6a 04                	push   $0x4
c103b4ab:	89 d8                	mov    %ebx,%eax
c103b4ad:	6a 10                	push   $0x10
c103b4af:	e8 fc ff ff ff       	call   c103b4b0 <ftrace_define_fields_hrtimer_init+0x39>
c103b4b4:	83 c4 10             	add    $0x10,%esp
c103b4b7:	85 c0                	test   %eax,%eax
c103b4b9:	75 1c                	jne    c103b4d7 <ftrace_define_fields_hrtimer_init+0x60>
c103b4bb:	6a 00                	push   $0x0
c103b4bd:	b9 f0 01 00 00       	mov    $0x1f0,%ecx
c103b4c2:	6a 00                	push   $0x0
c103b4c4:	ba f5 01 00 00       	mov    $0x1f5,%edx
c103b4c9:	6a 04                	push   $0x4
c103b4cb:	89 d8                	mov    %ebx,%eax
c103b4cd:	6a 14                	push   $0x14
c103b4cf:	e8 fc ff ff ff       	call   c103b4d0 <ftrace_define_fields_hrtimer_init+0x59>
c103b4d4:	83 c4 10             	add    $0x10,%esp
c103b4d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b4da:	c9                   	leave
c103b4db:	c3                   	ret

c103b4dc <ftrace_define_fields_hrtimer_start>:

/**
 * hrtimer_start - called when the hrtimer is started
 * @timer: pointer to struct hrtimer
 */
TRACE_EVENT(hrtimer_start,
c103b4dc:	55                   	push   %ebp
c103b4dd:	b9 d6 01 00 00       	mov    $0x1d6,%ecx
c103b4e2:	89 e5                	mov    %esp,%ebp
c103b4e4:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b4e9:	53                   	push   %ebx
c103b4ea:	89 c3                	mov    %eax,%ebx
c103b4ec:	6a 00                	push   $0x0
c103b4ee:	6a 00                	push   $0x0
c103b4f0:	6a 04                	push   $0x4
c103b4f2:	6a 0c                	push   $0xc
c103b4f4:	e8 fc ff ff ff       	call   c103b4f5 <ftrace_define_fields_hrtimer_start+0x19>
c103b4f9:	83 c4 10             	add    $0x10,%esp
c103b4fc:	85 c0                	test   %eax,%eax
c103b4fe:	75 5c                	jne    c103b55c <ftrace_define_fields_hrtimer_start+0x80>
c103b500:	6a 00                	push   $0x0
c103b502:	b9 b3 01 00 00       	mov    $0x1b3,%ecx
c103b507:	6a 00                	push   $0x0
c103b509:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b50e:	6a 04                	push   $0x4
c103b510:	89 d8                	mov    %ebx,%eax
c103b512:	6a 10                	push   $0x10
c103b514:	e8 fc ff ff ff       	call   c103b515 <ftrace_define_fields_hrtimer_start+0x39>
c103b519:	83 c4 10             	add    $0x10,%esp
c103b51c:	85 c0                	test   %eax,%eax
c103b51e:	75 3c                	jne    c103b55c <ftrace_define_fields_hrtimer_start+0x80>
c103b520:	6a 00                	push   $0x0
c103b522:	b9 bc 01 00 00       	mov    $0x1bc,%ecx
c103b527:	6a 01                	push   $0x1
c103b529:	ba 07 02 00 00       	mov    $0x207,%edx
c103b52e:	6a 08                	push   $0x8
c103b530:	89 d8                	mov    %ebx,%eax
c103b532:	6a 14                	push   $0x14
c103b534:	e8 fc ff ff ff       	call   c103b535 <ftrace_define_fields_hrtimer_start+0x59>
c103b539:	83 c4 10             	add    $0x10,%esp
c103b53c:	85 c0                	test   %eax,%eax
c103b53e:	75 1c                	jne    c103b55c <ftrace_define_fields_hrtimer_start+0x80>
c103b540:	6a 00                	push   $0x0
c103b542:	b9 0b 02 00 00       	mov    $0x20b,%ecx
c103b547:	6a 01                	push   $0x1
c103b549:	ba 07 02 00 00       	mov    $0x207,%edx
c103b54e:	6a 08                	push   $0x8
c103b550:	89 d8                	mov    %ebx,%eax
c103b552:	6a 1c                	push   $0x1c
c103b554:	e8 fc ff ff ff       	call   c103b555 <ftrace_define_fields_hrtimer_start+0x79>
c103b559:	83 c4 10             	add    $0x10,%esp
		  __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) {
				  .tv64 = __entry->expires }),
		  (unsigned long long)ktime_to_ns((ktime_t) {
				  .tv64 = __entry->softexpires }))
);
c103b55c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b55f:	c9                   	leave
c103b560:	c3                   	ret

c103b561 <ftrace_define_fields_hrtimer_expire_entry>:
 * @now:	pointer to variable which contains current time of the
 *		timers base.
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(hrtimer_expire_entry,
c103b561:	55                   	push   %ebp
c103b562:	b9 d6 01 00 00       	mov    $0x1d6,%ecx
c103b567:	89 e5                	mov    %esp,%ebp
c103b569:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b56e:	53                   	push   %ebx
c103b56f:	89 c3                	mov    %eax,%ebx
c103b571:	6a 00                	push   $0x0
c103b573:	6a 00                	push   $0x0
c103b575:	6a 04                	push   $0x4
c103b577:	6a 0c                	push   $0xc
c103b579:	e8 fc ff ff ff       	call   c103b57a <ftrace_define_fields_hrtimer_expire_entry+0x19>
c103b57e:	83 c4 10             	add    $0x10,%esp
c103b581:	85 c0                	test   %eax,%eax
c103b583:	75 3c                	jne    c103b5c1 <ftrace_define_fields_hrtimer_expire_entry+0x60>
c103b585:	6a 00                	push   $0x0
c103b587:	b9 d2 01 00 00       	mov    $0x1d2,%ecx
c103b58c:	6a 01                	push   $0x1
c103b58e:	ba 07 02 00 00       	mov    $0x207,%edx
c103b593:	6a 08                	push   $0x8
c103b595:	89 d8                	mov    %ebx,%eax
c103b597:	6a 10                	push   $0x10
c103b599:	e8 fc ff ff ff       	call   c103b59a <ftrace_define_fields_hrtimer_expire_entry+0x39>
c103b59e:	83 c4 10             	add    $0x10,%esp
c103b5a1:	85 c0                	test   %eax,%eax
c103b5a3:	75 1c                	jne    c103b5c1 <ftrace_define_fields_hrtimer_expire_entry+0x60>
c103b5a5:	6a 00                	push   $0x0
c103b5a7:	b9 b3 01 00 00       	mov    $0x1b3,%ecx
c103b5ac:	6a 00                	push   $0x0
c103b5ae:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b5b3:	6a 04                	push   $0x4
c103b5b5:	89 d8                	mov    %ebx,%eax
c103b5b7:	6a 18                	push   $0x18
c103b5b9:	e8 fc ff ff ff       	call   c103b5ba <ftrace_define_fields_hrtimer_expire_entry+0x59>
c103b5be:	83 c4 10             	add    $0x10,%esp
		__entry->function	= hrtimer->function;
	),

	TP_printk("hrtimer=%p function=%pf now=%llu", __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) { .tv64 = __entry->now }))
 );
c103b5c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b5c4:	c9                   	leave
c103b5c5:	c3                   	ret

c103b5c6 <ftrace_define_fields_hrtimer_class>:

DECLARE_EVENT_CLASS(hrtimer_class,
c103b5c6:	55                   	push   %ebp
c103b5c7:	b9 d6 01 00 00       	mov    $0x1d6,%ecx
c103b5cc:	89 e5                	mov    %esp,%ebp
c103b5ce:	ba ac 01 00 00       	mov    $0x1ac,%edx
c103b5d3:	6a 00                	push   $0x0
c103b5d5:	6a 00                	push   $0x0
c103b5d7:	6a 04                	push   $0x4
c103b5d9:	6a 0c                	push   $0xc
c103b5db:	e8 fc ff ff ff       	call   c103b5dc <ftrace_define_fields_hrtimer_class+0x16>
	TP_fast_assign(
		__entry->hrtimer	= hrtimer;
	),

	TP_printk("hrtimer=%p", __entry->hrtimer)
);
c103b5e0:	c9                   	leave
c103b5e1:	c3                   	ret

c103b5e2 <ftrace_define_fields_itimer_state>:
 * @which:	name of the interval timer
 * @value:	the itimers value, itimer is canceled if value->it_value is
 *		zero, otherwise it is started
 * @expires:	the itimers expiry time
 */
TRACE_EVENT(itimer_state,
c103b5e2:	55                   	push   %ebp
c103b5e3:	b9 17 02 00 00       	mov    $0x217,%ecx
c103b5e8:	89 e5                	mov    %esp,%ebp
c103b5ea:	ba 1d 02 00 00       	mov    $0x21d,%edx
c103b5ef:	53                   	push   %ebx
c103b5f0:	89 c3                	mov    %eax,%ebx
c103b5f2:	6a 00                	push   $0x0
c103b5f4:	6a 01                	push   $0x1
c103b5f6:	6a 04                	push   $0x4
c103b5f8:	6a 0c                	push   $0xc
c103b5fa:	e8 fc ff ff ff       	call   c103b5fb <ftrace_define_fields_itimer_state+0x19>
c103b5ff:	83 c4 10             	add    $0x10,%esp
c103b602:	85 c0                	test   %eax,%eax
c103b604:	0f 85 9c 00 00 00    	jne    c103b6a6 <ftrace_define_fields_itimer_state+0xc4>
c103b60a:	6a 00                	push   $0x0
c103b60c:	b9 bc 01 00 00       	mov    $0x1bc,%ecx
c103b611:	6a 00                	push   $0x0
c103b613:	ba 21 02 00 00       	mov    $0x221,%edx
c103b618:	6a 04                	push   $0x4
c103b61a:	89 d8                	mov    %ebx,%eax
c103b61c:	6a 10                	push   $0x10
c103b61e:	e8 fc ff ff ff       	call   c103b61f <ftrace_define_fields_itimer_state+0x3d>
c103b623:	83 c4 10             	add    $0x10,%esp
c103b626:	85 c0                	test   %eax,%eax
c103b628:	75 7c                	jne    c103b6a6 <ftrace_define_fields_itimer_state+0xc4>
c103b62a:	6a 00                	push   $0x0
c103b62c:	b9 2b 02 00 00       	mov    $0x22b,%ecx
c103b631:	6a 01                	push   $0x1
c103b633:	ba 35 02 00 00       	mov    $0x235,%edx
c103b638:	6a 04                	push   $0x4
c103b63a:	89 d8                	mov    %ebx,%eax
c103b63c:	6a 14                	push   $0x14
c103b63e:	e8 fc ff ff ff       	call   c103b63f <ftrace_define_fields_itimer_state+0x5d>
c103b643:	83 c4 10             	add    $0x10,%esp
c103b646:	85 c0                	test   %eax,%eax
c103b648:	75 5c                	jne    c103b6a6 <ftrace_define_fields_itimer_state+0xc4>
c103b64a:	6a 00                	push   $0x0
c103b64c:	b9 3a 02 00 00       	mov    $0x23a,%ecx
c103b651:	6a 01                	push   $0x1
c103b653:	ba 35 02 00 00       	mov    $0x235,%edx
c103b658:	6a 04                	push   $0x4
c103b65a:	89 d8                	mov    %ebx,%eax
c103b65c:	6a 18                	push   $0x18
c103b65e:	e8 fc ff ff ff       	call   c103b65f <ftrace_define_fields_itimer_state+0x7d>
c103b663:	83 c4 10             	add    $0x10,%esp
c103b666:	85 c0                	test   %eax,%eax
c103b668:	75 3c                	jne    c103b6a6 <ftrace_define_fields_itimer_state+0xc4>
c103b66a:	6a 00                	push   $0x0
c103b66c:	b9 45 02 00 00       	mov    $0x245,%ecx
c103b671:	6a 01                	push   $0x1
c103b673:	ba 35 02 00 00       	mov    $0x235,%edx
c103b678:	6a 04                	push   $0x4
c103b67a:	89 d8                	mov    %ebx,%eax
c103b67c:	6a 1c                	push   $0x1c
c103b67e:	e8 fc ff ff ff       	call   c103b67f <ftrace_define_fields_itimer_state+0x9d>
c103b683:	83 c4 10             	add    $0x10,%esp
c103b686:	85 c0                	test   %eax,%eax
c103b688:	75 1c                	jne    c103b6a6 <ftrace_define_fields_itimer_state+0xc4>
c103b68a:	6a 00                	push   $0x0
c103b68c:	b9 52 02 00 00       	mov    $0x252,%ecx
c103b691:	6a 01                	push   $0x1
c103b693:	ba 35 02 00 00       	mov    $0x235,%edx
c103b698:	6a 04                	push   $0x4
c103b69a:	89 d8                	mov    %ebx,%eax
c103b69c:	6a 20                	push   $0x20
c103b69e:	e8 fc ff ff ff       	call   c103b69f <ftrace_define_fields_itimer_state+0xbd>
c103b6a3:	83 c4 10             	add    $0x10,%esp

	TP_printk("which=%d expires=%llu it_value=%ld.%ld it_interval=%ld.%ld",
		  __entry->which, (unsigned long long)__entry->expires,
		  __entry->value_sec, __entry->value_usec,
		  __entry->interval_sec, __entry->interval_usec)
);
c103b6a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b6a9:	c9                   	leave
c103b6aa:	c3                   	ret

c103b6ab <ftrace_define_fields_itimer_expire>:
 * itimer_expire - called when itimer expires
 * @which:	type of the interval timer
 * @pid:	pid of the process which owns the timer
 * @now:	current time, used to calculate the latency of itimer
 */
TRACE_EVENT(itimer_expire,
c103b6ab:	55                   	push   %ebp
c103b6ac:	b9 17 02 00 00       	mov    $0x217,%ecx
c103b6b1:	89 e5                	mov    %esp,%ebp
c103b6b3:	ba 1d 02 00 00       	mov    $0x21d,%edx
c103b6b8:	53                   	push   %ebx
c103b6b9:	89 c3                	mov    %eax,%ebx
c103b6bb:	6a 00                	push   $0x0
c103b6bd:	6a 01                	push   $0x1
c103b6bf:	6a 04                	push   $0x4
c103b6c1:	6a 0c                	push   $0xc
c103b6c3:	e8 fc ff ff ff       	call   c103b6c4 <ftrace_define_fields_itimer_expire+0x19>
c103b6c8:	83 c4 10             	add    $0x10,%esp
c103b6cb:	85 c0                	test   %eax,%eax
c103b6cd:	75 3c                	jne    c103b70b <ftrace_define_fields_itimer_expire+0x60>
c103b6cf:	6a 00                	push   $0x0
c103b6d1:	b9 60 02 00 00       	mov    $0x260,%ecx
c103b6d6:	6a 01                	push   $0x1
c103b6d8:	ba 64 02 00 00       	mov    $0x264,%edx
c103b6dd:	6a 04                	push   $0x4
c103b6df:	89 d8                	mov    %ebx,%eax
c103b6e1:	6a 10                	push   $0x10
c103b6e3:	e8 fc ff ff ff       	call   c103b6e4 <ftrace_define_fields_itimer_expire+0x39>
c103b6e8:	83 c4 10             	add    $0x10,%esp
c103b6eb:	85 c0                	test   %eax,%eax
c103b6ed:	75 1c                	jne    c103b70b <ftrace_define_fields_itimer_expire+0x60>
c103b6ef:	6a 00                	push   $0x0
c103b6f1:	b9 d2 01 00 00       	mov    $0x1d2,%ecx
c103b6f6:	6a 00                	push   $0x0
c103b6f8:	ba 21 02 00 00       	mov    $0x221,%edx
c103b6fd:	6a 04                	push   $0x4
c103b6ff:	89 d8                	mov    %ebx,%eax
c103b701:	6a 14                	push   $0x14
c103b703:	e8 fc ff ff ff       	call   c103b704 <ftrace_define_fields_itimer_expire+0x59>
c103b708:	83 c4 10             	add    $0x10,%esp
		__entry->pid	= pid_nr(pid);
	),

	TP_printk("which=%d pid=%d now=%llu", __entry->which,
		  (int) __entry->pid, (unsigned long long)__entry->now)
);
c103b70b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c103b70e:	c9                   	leave
c103b70f:	c3                   	ret

c103b710 <perf_fetch_caller_regs>:
 * - cs for user_mode() tests
 * - bp for callchains
 * - eflags, for future purposes, just in case
 */
static inline void perf_fetch_caller_regs(struct pt_regs *regs)
{
c103b710:	55                   	push   %ebp
c103b711:	89 c2                	mov    %eax,%edx
c103b713:	89 e5                	mov    %esp,%ebp
	memset(regs, 0, sizeof(*regs));
c103b715:	31 c0                	xor    %eax,%eax
 * - cs for user_mode() tests
 * - bp for callchains
 * - eflags, for future purposes, just in case
 */
static inline void perf_fetch_caller_regs(struct pt_regs *regs)
{
c103b717:	57                   	push   %edi
	memset(regs, 0, sizeof(*regs));
c103b718:	b9 11 00 00 00       	mov    $0x11,%ecx
c103b71d:	89 d7                	mov    %edx,%edi
c103b71f:	f3 ab                	rep stos %eax,%es:(%edi)

	perf_arch_fetch_caller_regs(regs, CALLER_ADDR0);
c103b721:	8b 45 04             	mov    0x4(%ebp),%eax
c103b724:	89 42 30             	mov    %eax,0x30(%edx)

static inline unsigned long caller_frame_pointer(void)
{
	struct stack_frame *frame;

	get_bp(frame);
c103b727:	89 e8                	mov    %ebp,%eax
c103b729:	8b 00                	mov    (%eax),%eax
c103b72b:	c7 42 34 60 00 00 00 	movl   $0x60,0x34(%edx)
c103b732:	c7 42 38 00 00 00 00 	movl   $0x0,0x38(%edx)
c103b739:	89 42 14             	mov    %eax,0x14(%edx)
}
c103b73c:	5f                   	pop    %edi
c103b73d:	5d                   	pop    %ebp
c103b73e:	c3                   	ret

c103b73f <perf_trace_timer_class>:

#include <linux/tracepoint.h>
#include <linux/hrtimer.h>
#include <linux/timer.h>

DECLARE_EVENT_CLASS(timer_class,
c103b73f:	55                   	push   %ebp
c103b740:	89 e5                	mov    %esp,%ebp
c103b742:	57                   	push   %edi
c103b743:	89 d7                	mov    %edx,%edi
c103b745:	56                   	push   %esi
c103b746:	53                   	push   %ebx
c103b747:	89 c3                	mov    %eax,%ebx
c103b749:	8d 75 ac             	lea    -0x54(%ebp),%esi
c103b74c:	83 ec 4c             	sub    $0x4c,%esp
c103b74f:	89 f0                	mov    %esi,%eax
c103b751:	e8 ba ff ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b756:	0f b7 53 24          	movzwl 0x24(%ebx),%edx
c103b75a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b75d:	89 f1                	mov    %esi,%ecx
c103b75f:	50                   	push   %eax
c103b760:	b8 14 00 00 00       	mov    $0x14,%eax
c103b765:	e8 fc ff ff ff       	call   c103b766 <perf_trace_timer_class+0x27>
c103b76a:	59                   	pop    %ecx
c103b76b:	85 c0                	test   %eax,%eax
c103b76d:	74 30                	je     c103b79f <perf_trace_timer_class+0x60>
c103b76f:	89 78 0c             	mov    %edi,0xc(%eax)
c103b772:	8b 5b 44             	mov    0x44(%ebx),%ebx
c103b775:	89 45 a8             	mov    %eax,-0x58(%ebp)
c103b778:	e8 fc ff ff ff       	call   c103b779 <perf_trace_timer_class+0x3a>

static inline void
perf_trace_buf_submit(void *raw_data, int size, int rctx, u64 addr,
		       u64 count, struct pt_regs *regs, void *head)
{
	perf_tp_event(addr, count, raw_data, size, regs, head, rctx);
c103b77d:	8b 55 a8             	mov    -0x58(%ebp),%edx
c103b780:	ff 75 f0             	pushl  -0x10(%ebp)
c103b783:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103b78a:	31 c0                	xor    %eax,%eax
c103b78c:	53                   	push   %ebx
c103b78d:	56                   	push   %esi
c103b78e:	6a 14                	push   $0x14
c103b790:	52                   	push   %edx
c103b791:	31 d2                	xor    %edx,%edx
c103b793:	6a 00                	push   $0x0
c103b795:	6a 01                	push   $0x1
c103b797:	e8 fc ff ff ff       	call   c103b798 <perf_trace_timer_class+0x59>
c103b79c:	83 c4 1c             	add    $0x1c,%esp
	TP_fast_assign(
		__entry->timer	= timer;
	),

	TP_printk("timer=%p", __entry->timer)
);
c103b79f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103b7a2:	5b                   	pop    %ebx
c103b7a3:	5e                   	pop    %esi
c103b7a4:	5f                   	pop    %edi
c103b7a5:	5d                   	pop    %ebp
c103b7a6:	c3                   	ret

c103b7a7 <perf_trace_timer_start>:
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103b7a7:	55                   	push   %ebp
c103b7a8:	89 e5                	mov    %esp,%ebp
c103b7aa:	57                   	push   %edi
c103b7ab:	56                   	push   %esi
c103b7ac:	89 c6                	mov    %eax,%esi
c103b7ae:	53                   	push   %ebx
c103b7af:	89 d3                	mov    %edx,%ebx
c103b7b1:	8d 7d ac             	lea    -0x54(%ebp),%edi
c103b7b4:	83 ec 50             	sub    $0x50,%esp
c103b7b7:	89 f8                	mov    %edi,%eax
c103b7b9:	89 4d a8             	mov    %ecx,-0x58(%ebp)
c103b7bc:	e8 4f ff ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b7c1:	0f b7 56 24          	movzwl 0x24(%esi),%edx
c103b7c5:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b7c8:	89 f9                	mov    %edi,%ecx
c103b7ca:	50                   	push   %eax
c103b7cb:	b8 1c 00 00 00       	mov    $0x1c,%eax
c103b7d0:	e8 fc ff ff ff       	call   c103b7d1 <perf_trace_timer_start+0x2a>
c103b7d5:	89 c2                	mov    %eax,%edx
c103b7d7:	85 d2                	test   %edx,%edx
c103b7d9:	58                   	pop    %eax
c103b7da:	74 44                	je     c103b820 <perf_trace_timer_start+0x79>
c103b7dc:	89 5a 0c             	mov    %ebx,0xc(%edx)
c103b7df:	8b 43 10             	mov    0x10(%ebx),%eax
c103b7e2:	89 42 10             	mov    %eax,0x10(%edx)
c103b7e5:	8b 45 a8             	mov    -0x58(%ebp),%eax
c103b7e8:	89 42 14             	mov    %eax,0x14(%edx)
c103b7eb:	a1 00 00 00 00       	mov    0x0,%eax
c103b7f0:	89 42 18             	mov    %eax,0x18(%edx)
c103b7f3:	8b 5e 44             	mov    0x44(%esi),%ebx
c103b7f6:	89 55 a4             	mov    %edx,-0x5c(%ebp)
c103b7f9:	e8 fc ff ff ff       	call   c103b7fa <perf_trace_timer_start+0x53>
c103b7fe:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c103b801:	ff 75 f0             	pushl  -0x10(%ebp)
c103b804:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103b80b:	31 c0                	xor    %eax,%eax
c103b80d:	53                   	push   %ebx
c103b80e:	57                   	push   %edi
c103b80f:	6a 1c                	push   $0x1c
c103b811:	52                   	push   %edx
c103b812:	31 d2                	xor    %edx,%edx
c103b814:	6a 00                	push   $0x0
c103b816:	6a 01                	push   $0x1
c103b818:	e8 fc ff ff ff       	call   c103b819 <perf_trace_timer_start+0x72>
c103b81d:	83 c4 1c             	add    $0x1c,%esp
	),

	TP_printk("timer=%p function=%pf expires=%lu [timeout=%ld]",
		  __entry->timer, __entry->function, __entry->expires,
		  (long)__entry->expires - __entry->now)
);
c103b820:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103b823:	5b                   	pop    %ebx
c103b824:	5e                   	pop    %esi
c103b825:	5f                   	pop    %edi
c103b826:	5d                   	pop    %ebp
c103b827:	c3                   	ret

c103b828 <perf_trace_timer_expire_entry>:
 * timer_expire_entry - called immediately before the timer callback
 * @timer:	pointer to struct timer_list
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(timer_expire_entry,
c103b828:	55                   	push   %ebp
c103b829:	89 e5                	mov    %esp,%ebp
c103b82b:	57                   	push   %edi
c103b82c:	56                   	push   %esi
c103b82d:	89 c6                	mov    %eax,%esi
c103b82f:	53                   	push   %ebx
c103b830:	89 d3                	mov    %edx,%ebx
c103b832:	8d 7d ac             	lea    -0x54(%ebp),%edi
c103b835:	83 ec 4c             	sub    $0x4c,%esp
c103b838:	89 f8                	mov    %edi,%eax
c103b83a:	e8 d1 fe ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b83f:	0f b7 56 24          	movzwl 0x24(%esi),%edx
c103b843:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b846:	89 f9                	mov    %edi,%ecx
c103b848:	50                   	push   %eax
c103b849:	b8 1c 00 00 00       	mov    $0x1c,%eax
c103b84e:	e8 fc ff ff ff       	call   c103b84f <perf_trace_timer_expire_entry+0x27>
c103b853:	59                   	pop    %ecx
c103b854:	85 c0                	test   %eax,%eax
c103b856:	89 c2                	mov    %eax,%edx
c103b858:	74 3e                	je     c103b898 <perf_trace_timer_expire_entry+0x70>
c103b85a:	89 58 0c             	mov    %ebx,0xc(%eax)
c103b85d:	a1 00 00 00 00       	mov    0x0,%eax
c103b862:	89 42 10             	mov    %eax,0x10(%edx)
c103b865:	8b 43 10             	mov    0x10(%ebx),%eax
c103b868:	89 42 14             	mov    %eax,0x14(%edx)
c103b86b:	8b 5e 44             	mov    0x44(%esi),%ebx
c103b86e:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103b871:	e8 fc ff ff ff       	call   c103b872 <perf_trace_timer_expire_entry+0x4a>
c103b876:	8b 55 a8             	mov    -0x58(%ebp),%edx
c103b879:	ff 75 f0             	pushl  -0x10(%ebp)
c103b87c:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103b883:	31 c0                	xor    %eax,%eax
c103b885:	53                   	push   %ebx
c103b886:	57                   	push   %edi
c103b887:	6a 1c                	push   $0x1c
c103b889:	52                   	push   %edx
c103b88a:	31 d2                	xor    %edx,%edx
c103b88c:	6a 00                	push   $0x0
c103b88e:	6a 01                	push   $0x1
c103b890:	e8 fc ff ff ff       	call   c103b891 <perf_trace_timer_expire_entry+0x69>
c103b895:	83 c4 1c             	add    $0x1c,%esp
		__entry->now		= jiffies;
		__entry->function	= timer->function;
	),

	TP_printk("timer=%p function=%pf now=%lu", __entry->timer, __entry->function,__entry->now)
);
c103b898:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103b89b:	5b                   	pop    %ebx
c103b89c:	5e                   	pop    %esi
c103b89d:	5f                   	pop    %edi
c103b89e:	5d                   	pop    %ebp
c103b89f:	c3                   	ret

c103b8a0 <perf_trace_hrtimer_init>:
 * hrtimer_init - called when the hrtimer is initialized
 * @timer:	pointer to struct hrtimer
 * @clockid:	the hrtimers clock
 * @mode:	the hrtimers mode
 */
TRACE_EVENT(hrtimer_init,
c103b8a0:	55                   	push   %ebp
c103b8a1:	89 e5                	mov    %esp,%ebp
c103b8a3:	57                   	push   %edi
c103b8a4:	89 d7                	mov    %edx,%edi
c103b8a6:	56                   	push   %esi
c103b8a7:	53                   	push   %ebx
c103b8a8:	89 c3                	mov    %eax,%ebx
c103b8aa:	8d 75 ac             	lea    -0x54(%ebp),%esi
c103b8ad:	83 ec 50             	sub    $0x50,%esp
c103b8b0:	89 f0                	mov    %esi,%eax
c103b8b2:	89 4d a8             	mov    %ecx,-0x58(%ebp)
c103b8b5:	e8 56 fe ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b8ba:	0f b7 53 24          	movzwl 0x24(%ebx),%edx
c103b8be:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b8c1:	89 f1                	mov    %esi,%ecx
c103b8c3:	50                   	push   %eax
c103b8c4:	b8 1c 00 00 00       	mov    $0x1c,%eax
c103b8c9:	e8 fc ff ff ff       	call   c103b8ca <perf_trace_hrtimer_init+0x2a>
c103b8ce:	89 c2                	mov    %eax,%edx
c103b8d0:	85 d2                	test   %edx,%edx
c103b8d2:	58                   	pop    %eax
c103b8d3:	74 3c                	je     c103b911 <perf_trace_hrtimer_init+0x71>
c103b8d5:	89 7a 0c             	mov    %edi,0xc(%edx)
c103b8d8:	8b 45 a8             	mov    -0x58(%ebp),%eax
c103b8db:	89 42 10             	mov    %eax,0x10(%edx)
c103b8de:	8b 45 08             	mov    0x8(%ebp),%eax
c103b8e1:	89 42 14             	mov    %eax,0x14(%edx)
c103b8e4:	8b 5b 44             	mov    0x44(%ebx),%ebx
c103b8e7:	89 55 a4             	mov    %edx,-0x5c(%ebp)
c103b8ea:	e8 fc ff ff ff       	call   c103b8eb <perf_trace_hrtimer_init+0x4b>
c103b8ef:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c103b8f2:	ff 75 f0             	pushl  -0x10(%ebp)
c103b8f5:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103b8fc:	31 c0                	xor    %eax,%eax
c103b8fe:	53                   	push   %ebx
c103b8ff:	56                   	push   %esi
c103b900:	6a 1c                	push   $0x1c
c103b902:	52                   	push   %edx
c103b903:	31 d2                	xor    %edx,%edx
c103b905:	6a 00                	push   $0x0
c103b907:	6a 01                	push   $0x1
c103b909:	e8 fc ff ff ff       	call   c103b90a <perf_trace_hrtimer_init+0x6a>
c103b90e:	83 c4 1c             	add    $0x1c,%esp
	TP_printk("hrtimer=%p clockid=%s mode=%s", __entry->hrtimer,
		  __entry->clockid == CLOCK_REALTIME ?
			"CLOCK_REALTIME" : "CLOCK_MONOTONIC",
		  __entry->mode == HRTIMER_MODE_ABS ?
			"HRTIMER_MODE_ABS" : "HRTIMER_MODE_REL")
);
c103b911:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103b914:	5b                   	pop    %ebx
c103b915:	5e                   	pop    %esi
c103b916:	5f                   	pop    %edi
c103b917:	5d                   	pop    %ebp
c103b918:	c3                   	ret

c103b919 <perf_trace_hrtimer_start>:

/**
 * hrtimer_start - called when the hrtimer is started
 * @timer: pointer to struct hrtimer
 */
TRACE_EVENT(hrtimer_start,
c103b919:	55                   	push   %ebp
c103b91a:	89 e5                	mov    %esp,%ebp
c103b91c:	57                   	push   %edi
c103b91d:	56                   	push   %esi
c103b91e:	53                   	push   %ebx
c103b91f:	89 d3                	mov    %edx,%ebx
c103b921:	83 ec 50             	sub    $0x50,%esp
c103b924:	89 45 a4             	mov    %eax,-0x5c(%ebp)
c103b927:	8d 45 ac             	lea    -0x54(%ebp),%eax
c103b92a:	e8 e1 fd ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b92f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c103b932:	8d 4d ac             	lea    -0x54(%ebp),%ecx
c103b935:	0f b7 50 24          	movzwl 0x24(%eax),%edx
c103b939:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b93c:	50                   	push   %eax
c103b93d:	b8 24 00 00 00       	mov    $0x24,%eax
c103b942:	e8 fc ff ff ff       	call   c103b943 <perf_trace_hrtimer_start+0x2a>
c103b947:	59                   	pop    %ecx
c103b948:	85 c0                	test   %eax,%eax
c103b94a:	89 c2                	mov    %eax,%edx
c103b94c:	74 54                	je     c103b9a2 <perf_trace_hrtimer_start+0x89>
c103b94e:	89 58 0c             	mov    %ebx,0xc(%eax)
c103b951:	8b 43 1c             	mov    0x1c(%ebx),%eax
c103b954:	89 42 10             	mov    %eax,0x10(%edx)
c103b957:	8b 7b 10             	mov    0x10(%ebx),%edi
c103b95a:	8b 73 0c             	mov    0xc(%ebx),%esi
c103b95d:	89 7a 18             	mov    %edi,0x18(%edx)
c103b960:	89 72 14             	mov    %esi,0x14(%edx)
	return timer->node.expires;
}

static inline ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)
{
	return timer->_softexpires;
c103b963:	8b 4b 14             	mov    0x14(%ebx),%ecx
c103b966:	8b 5b 18             	mov    0x18(%ebx),%ebx
c103b969:	89 4a 1c             	mov    %ecx,0x1c(%edx)
c103b96c:	89 5a 20             	mov    %ebx,0x20(%edx)
c103b96f:	8b 7d a4             	mov    -0x5c(%ebp),%edi
c103b972:	8b 5f 44             	mov    0x44(%edi),%ebx
c103b975:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103b978:	e8 fc ff ff ff       	call   c103b979 <perf_trace_hrtimer_start+0x60>
c103b97d:	8b 55 a8             	mov    -0x58(%ebp),%edx
c103b980:	ff 75 f0             	pushl  -0x10(%ebp)
c103b983:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103b98a:	8d 45 ac             	lea    -0x54(%ebp),%eax
c103b98d:	53                   	push   %ebx
c103b98e:	50                   	push   %eax
c103b98f:	31 c0                	xor    %eax,%eax
c103b991:	6a 24                	push   $0x24
c103b993:	52                   	push   %edx
c103b994:	31 d2                	xor    %edx,%edx
c103b996:	6a 00                	push   $0x0
c103b998:	6a 01                	push   $0x1
c103b99a:	e8 fc ff ff ff       	call   c103b99b <perf_trace_hrtimer_start+0x82>
c103b99f:	83 c4 1c             	add    $0x1c,%esp
		  __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) {
				  .tv64 = __entry->expires }),
		  (unsigned long long)ktime_to_ns((ktime_t) {
				  .tv64 = __entry->softexpires }))
);
c103b9a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103b9a5:	5b                   	pop    %ebx
c103b9a6:	5e                   	pop    %esi
c103b9a7:	5f                   	pop    %edi
c103b9a8:	5d                   	pop    %ebp
c103b9a9:	c3                   	ret

c103b9aa <perf_trace_hrtimer_expire_entry>:
 * @now:	pointer to variable which contains current time of the
 *		timers base.
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(hrtimer_expire_entry,
c103b9aa:	55                   	push   %ebp
c103b9ab:	89 e5                	mov    %esp,%ebp
c103b9ad:	57                   	push   %edi
c103b9ae:	89 c7                	mov    %eax,%edi
c103b9b0:	56                   	push   %esi
c103b9b1:	89 ce                	mov    %ecx,%esi
c103b9b3:	53                   	push   %ebx
c103b9b4:	83 ec 50             	sub    $0x50,%esp
c103b9b7:	8d 45 ac             	lea    -0x54(%ebp),%eax
c103b9ba:	89 55 a4             	mov    %edx,-0x5c(%ebp)
c103b9bd:	e8 4e fd ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103b9c2:	0f b7 57 24          	movzwl 0x24(%edi),%edx
c103b9c6:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103b9c9:	8d 4d ac             	lea    -0x54(%ebp),%ecx
c103b9cc:	50                   	push   %eax
c103b9cd:	b8 1c 00 00 00       	mov    $0x1c,%eax
c103b9d2:	e8 fc ff ff ff       	call   c103b9d3 <perf_trace_hrtimer_expire_entry+0x29>
c103b9d7:	5b                   	pop    %ebx
c103b9d8:	85 c0                	test   %eax,%eax
c103b9da:	89 c2                	mov    %eax,%edx
c103b9dc:	74 4a                	je     c103ba28 <perf_trace_hrtimer_expire_entry+0x7e>
c103b9de:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c103b9e1:	89 42 0c             	mov    %eax,0xc(%edx)
c103b9e4:	8b 0e                	mov    (%esi),%ecx
c103b9e6:	8b 5e 04             	mov    0x4(%esi),%ebx
c103b9e9:	89 4a 10             	mov    %ecx,0x10(%edx)
c103b9ec:	89 5a 14             	mov    %ebx,0x14(%edx)
c103b9ef:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
c103b9f2:	8b 43 1c             	mov    0x1c(%ebx),%eax
c103b9f5:	89 42 18             	mov    %eax,0x18(%edx)
c103b9f8:	8b 5f 44             	mov    0x44(%edi),%ebx
c103b9fb:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103b9fe:	e8 fc ff ff ff       	call   c103b9ff <perf_trace_hrtimer_expire_entry+0x55>
c103ba03:	8b 55 a8             	mov    -0x58(%ebp),%edx
c103ba06:	ff 75 f0             	pushl  -0x10(%ebp)
c103ba09:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103ba10:	8d 45 ac             	lea    -0x54(%ebp),%eax
c103ba13:	53                   	push   %ebx
c103ba14:	50                   	push   %eax
c103ba15:	31 c0                	xor    %eax,%eax
c103ba17:	6a 1c                	push   $0x1c
c103ba19:	52                   	push   %edx
c103ba1a:	31 d2                	xor    %edx,%edx
c103ba1c:	6a 00                	push   $0x0
c103ba1e:	6a 01                	push   $0x1
c103ba20:	e8 fc ff ff ff       	call   c103ba21 <perf_trace_hrtimer_expire_entry+0x77>
c103ba25:	83 c4 1c             	add    $0x1c,%esp
		__entry->function	= hrtimer->function;
	),

	TP_printk("hrtimer=%p function=%pf now=%llu", __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) { .tv64 = __entry->now }))
 );
c103ba28:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103ba2b:	5b                   	pop    %ebx
c103ba2c:	5e                   	pop    %esi
c103ba2d:	5f                   	pop    %edi
c103ba2e:	5d                   	pop    %ebp
c103ba2f:	c3                   	ret

c103ba30 <perf_trace_hrtimer_class>:

DECLARE_EVENT_CLASS(hrtimer_class,
c103ba30:	55                   	push   %ebp
c103ba31:	89 e5                	mov    %esp,%ebp
c103ba33:	57                   	push   %edi
c103ba34:	89 d7                	mov    %edx,%edi
c103ba36:	56                   	push   %esi
c103ba37:	53                   	push   %ebx
c103ba38:	89 c3                	mov    %eax,%ebx
c103ba3a:	8d 75 ac             	lea    -0x54(%ebp),%esi
c103ba3d:	83 ec 4c             	sub    $0x4c,%esp
c103ba40:	89 f0                	mov    %esi,%eax
c103ba42:	e8 c9 fc ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103ba47:	0f b7 53 24          	movzwl 0x24(%ebx),%edx
c103ba4b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103ba4e:	89 f1                	mov    %esi,%ecx
c103ba50:	50                   	push   %eax
c103ba51:	b8 14 00 00 00       	mov    $0x14,%eax
c103ba56:	e8 fc ff ff ff       	call   c103ba57 <perf_trace_hrtimer_class+0x27>
c103ba5b:	89 c2                	mov    %eax,%edx
c103ba5d:	85 d2                	test   %edx,%edx
c103ba5f:	58                   	pop    %eax
c103ba60:	74 30                	je     c103ba92 <perf_trace_hrtimer_class+0x62>
c103ba62:	89 7a 0c             	mov    %edi,0xc(%edx)
c103ba65:	8b 5b 44             	mov    0x44(%ebx),%ebx
c103ba68:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103ba6b:	e8 fc ff ff ff       	call   c103ba6c <perf_trace_hrtimer_class+0x3c>
c103ba70:	8b 55 a8             	mov    -0x58(%ebp),%edx
c103ba73:	ff 75 f0             	pushl  -0x10(%ebp)
c103ba76:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103ba7d:	31 c0                	xor    %eax,%eax
c103ba7f:	53                   	push   %ebx
c103ba80:	56                   	push   %esi
c103ba81:	6a 14                	push   $0x14
c103ba83:	52                   	push   %edx
c103ba84:	31 d2                	xor    %edx,%edx
c103ba86:	6a 00                	push   $0x0
c103ba88:	6a 01                	push   $0x1
c103ba8a:	e8 fc ff ff ff       	call   c103ba8b <perf_trace_hrtimer_class+0x5b>
c103ba8f:	83 c4 1c             	add    $0x1c,%esp
	TP_fast_assign(
		__entry->hrtimer	= hrtimer;
	),

	TP_printk("hrtimer=%p", __entry->hrtimer)
);
c103ba92:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103ba95:	5b                   	pop    %ebx
c103ba96:	5e                   	pop    %esi
c103ba97:	5f                   	pop    %edi
c103ba98:	5d                   	pop    %ebp
c103ba99:	c3                   	ret

c103ba9a <perf_trace_itimer_state>:
 * @which:	name of the interval timer
 * @value:	the itimers value, itimer is canceled if value->it_value is
 *		zero, otherwise it is started
 * @expires:	the itimers expiry time
 */
TRACE_EVENT(itimer_state,
c103ba9a:	55                   	push   %ebp
c103ba9b:	89 e5                	mov    %esp,%ebp
c103ba9d:	57                   	push   %edi
c103ba9e:	56                   	push   %esi
c103ba9f:	89 c6                	mov    %eax,%esi
c103baa1:	53                   	push   %ebx
c103baa2:	89 cb                	mov    %ecx,%ebx
c103baa4:	8d 7d ac             	lea    -0x54(%ebp),%edi
c103baa7:	83 ec 50             	sub    $0x50,%esp
c103baaa:	89 f8                	mov    %edi,%eax
c103baac:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103baaf:	e8 5c fc ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103bab4:	0f b7 56 24          	movzwl 0x24(%esi),%edx
c103bab8:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103babb:	89 f9                	mov    %edi,%ecx
c103babd:	50                   	push   %eax
c103babe:	b8 24 00 00 00       	mov    $0x24,%eax
c103bac3:	e8 fc ff ff ff       	call   c103bac4 <perf_trace_itimer_state+0x2a>
c103bac8:	59                   	pop    %ecx
c103bac9:	85 c0                	test   %eax,%eax
c103bacb:	89 c2                	mov    %eax,%edx
c103bacd:	74 50                	je     c103bb1f <perf_trace_itimer_state+0x85>
c103bacf:	8b 45 a8             	mov    -0x58(%ebp),%eax
c103bad2:	89 42 0c             	mov    %eax,0xc(%edx)
c103bad5:	8b 45 08             	mov    0x8(%ebp),%eax
c103bad8:	89 42 10             	mov    %eax,0x10(%edx)
c103badb:	8b 43 08             	mov    0x8(%ebx),%eax
c103bade:	89 42 14             	mov    %eax,0x14(%edx)
c103bae1:	8b 43 0c             	mov    0xc(%ebx),%eax
c103bae4:	89 42 18             	mov    %eax,0x18(%edx)
c103bae7:	8b 03                	mov    (%ebx),%eax
c103bae9:	89 42 1c             	mov    %eax,0x1c(%edx)
c103baec:	8b 43 04             	mov    0x4(%ebx),%eax
c103baef:	89 42 20             	mov    %eax,0x20(%edx)
c103baf2:	8b 5e 44             	mov    0x44(%esi),%ebx
c103baf5:	89 55 a4             	mov    %edx,-0x5c(%ebp)
c103baf8:	e8 fc ff ff ff       	call   c103baf9 <perf_trace_itimer_state+0x5f>
c103bafd:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c103bb00:	ff 75 f0             	pushl  -0x10(%ebp)
c103bb03:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103bb0a:	31 c0                	xor    %eax,%eax
c103bb0c:	53                   	push   %ebx
c103bb0d:	57                   	push   %edi
c103bb0e:	6a 24                	push   $0x24
c103bb10:	52                   	push   %edx
c103bb11:	31 d2                	xor    %edx,%edx
c103bb13:	6a 00                	push   $0x0
c103bb15:	6a 01                	push   $0x1
c103bb17:	e8 fc ff ff ff       	call   c103bb18 <perf_trace_itimer_state+0x7e>
c103bb1c:	83 c4 1c             	add    $0x1c,%esp

	TP_printk("which=%d expires=%llu it_value=%ld.%ld it_interval=%ld.%ld",
		  __entry->which, (unsigned long long)__entry->expires,
		  __entry->value_sec, __entry->value_usec,
		  __entry->interval_sec, __entry->interval_usec)
);
c103bb1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bb22:	5b                   	pop    %ebx
c103bb23:	5e                   	pop    %esi
c103bb24:	5f                   	pop    %edi
c103bb25:	5d                   	pop    %ebp
c103bb26:	c3                   	ret

c103bb27 <perf_trace_itimer_expire>:
 * itimer_expire - called when itimer expires
 * @which:	type of the interval timer
 * @pid:	pid of the process which owns the timer
 * @now:	current time, used to calculate the latency of itimer
 */
TRACE_EVENT(itimer_expire,
c103bb27:	55                   	push   %ebp
c103bb28:	89 e5                	mov    %esp,%ebp
c103bb2a:	57                   	push   %edi
c103bb2b:	56                   	push   %esi
c103bb2c:	89 c6                	mov    %eax,%esi
c103bb2e:	53                   	push   %ebx
c103bb2f:	89 cb                	mov    %ecx,%ebx
c103bb31:	8d 7d ac             	lea    -0x54(%ebp),%edi
c103bb34:	83 ec 4c             	sub    $0x4c,%esp
c103bb37:	89 f8                	mov    %edi,%eax
c103bb39:	89 55 a8             	mov    %edx,-0x58(%ebp)
c103bb3c:	e8 cf fb ff ff       	call   c103b710 <perf_fetch_caller_regs>
c103bb41:	0f b7 56 24          	movzwl 0x24(%esi),%edx
c103bb45:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bb48:	89 f9                	mov    %edi,%ecx
c103bb4a:	50                   	push   %eax
c103bb4b:	b8 1c 00 00 00       	mov    $0x1c,%eax
c103bb50:	e8 fc ff ff ff       	call   c103bb51 <perf_trace_itimer_expire+0x2a>
c103bb55:	89 c7                	mov    %eax,%edi
c103bb57:	85 ff                	test   %edi,%edi
c103bb59:	58                   	pop    %eax
c103bb5a:	74 42                	je     c103bb9e <perf_trace_itimer_expire+0x77>
c103bb5c:	8b 45 a8             	mov    -0x58(%ebp),%eax
c103bb5f:	89 47 0c             	mov    %eax,0xc(%edi)
c103bb62:	8b 45 08             	mov    0x8(%ebp),%eax
c103bb65:	89 47 14             	mov    %eax,0x14(%edi)
 */

static inline pid_t pid_nr(struct pid *pid)
{
	pid_t nr = 0;
	if (pid)
c103bb68:	31 c0                	xor    %eax,%eax
c103bb6a:	85 db                	test   %ebx,%ebx
c103bb6c:	74 03                	je     c103bb71 <perf_trace_itimer_expire+0x4a>
		nr = pid->numbers[0].nr;
c103bb6e:	8b 43 1c             	mov    0x1c(%ebx),%eax
c103bb71:	89 47 10             	mov    %eax,0x10(%edi)
c103bb74:	8b 5e 44             	mov    0x44(%esi),%ebx
c103bb77:	e8 fc ff ff ff       	call   c103bb78 <perf_trace_itimer_expire+0x51>
c103bb7c:	31 d2                	xor    %edx,%edx
c103bb7e:	ff 75 f0             	pushl  -0x10(%ebp)
c103bb81:	03 1c 85 00 00 00 00 	add    0x0(,%eax,4),%ebx
c103bb88:	8d 45 ac             	lea    -0x54(%ebp),%eax
c103bb8b:	53                   	push   %ebx
c103bb8c:	50                   	push   %eax
c103bb8d:	31 c0                	xor    %eax,%eax
c103bb8f:	6a 1c                	push   $0x1c
c103bb91:	57                   	push   %edi
c103bb92:	6a 00                	push   $0x0
c103bb94:	6a 01                	push   $0x1
c103bb96:	e8 fc ff ff ff       	call   c103bb97 <perf_trace_itimer_expire+0x70>
c103bb9b:	83 c4 1c             	add    $0x1c,%esp
		__entry->pid	= pid_nr(pid);
	),

	TP_printk("which=%d pid=%d now=%llu", __entry->which,
		  (int) __entry->pid, (unsigned long long)__entry->now)
);
c103bb9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bba1:	5b                   	pop    %ebx
c103bba2:	5e                   	pop    %esi
c103bba3:	5f                   	pop    %edi
c103bba4:	5d                   	pop    %ebp
c103bba5:	c3                   	ret

c103bba6 <ftrace_raw_event_timer_class>:

#include <linux/tracepoint.h>
#include <linux/hrtimer.h>
#include <linux/timer.h>

DECLARE_EVENT_CLASS(timer_class,
c103bba6:	55                   	push   %ebp
c103bba7:	89 e5                	mov    %esp,%ebp
c103bba9:	57                   	push   %edi
c103bbaa:	56                   	push   %esi
c103bbab:	89 c6                	mov    %eax,%esi
c103bbad:	53                   	push   %ebx
c103bbae:	83 ec 0c             	sub    $0xc,%esp
c103bbb1:	89 55 e8             	mov    %edx,-0x18(%ebp)
	/*
	 * "=rm" is safe here, because "pop" adjusts the stack before
	 * it evaluates its effective address -- this is part of the
	 * documented behavior of the "pop" instruction.
	 */
	asm volatile("# __raw_save_flags\n\t"
c103bbb4:	9c                   	pushf
c103bbb5:	8f 45 ec             	popl   -0x14(%ebp)
c103bbb8:	89 e0                	mov    %esp,%eax
c103bbba:	8b 56 24             	mov    0x24(%esi),%edx
c103bbbd:	b9 10 00 00 00       	mov    $0x10,%ecx
c103bbc2:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bbc7:	8b 78 14             	mov    0x14(%eax),%edi
c103bbca:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bbcd:	57                   	push   %edi
c103bbce:	ff 75 ec             	pushl  -0x14(%ebp)
c103bbd1:	e8 fc ff ff ff       	call   c103bbd2 <ftrace_raw_event_timer_class+0x2c>
c103bbd6:	89 c3                	mov    %eax,%ebx
c103bbd8:	85 db                	test   %ebx,%ebx
c103bbda:	58                   	pop    %eax
c103bbdb:	5a                   	pop    %edx
c103bbdc:	74 2e                	je     c103bc0c <ftrace_raw_event_timer_class+0x66>
c103bbde:	89 d8                	mov    %ebx,%eax
c103bbe0:	e8 fc ff ff ff       	call   c103bbe1 <ftrace_raw_event_timer_class+0x3b>
c103bbe5:	8b 55 e8             	mov    -0x18(%ebp),%edx
c103bbe8:	89 c1                	mov    %eax,%ecx
c103bbea:	89 50 0c             	mov    %edx,0xc(%eax)
c103bbed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bbf0:	89 f2                	mov    %esi,%edx
c103bbf2:	53                   	push   %ebx
c103bbf3:	e8 fc ff ff ff       	call   c103bbf4 <ftrace_raw_event_timer_class+0x4e>
c103bbf8:	59                   	pop    %ecx
c103bbf9:	85 c0                	test   %eax,%eax
c103bbfb:	75 0f                	jne    c103bc0c <ftrace_raw_event_timer_class+0x66>
c103bbfd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c103bc00:	89 da                	mov    %ebx,%edx
c103bc02:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bc05:	57                   	push   %edi
c103bc06:	e8 fc ff ff ff       	call   c103bc07 <ftrace_raw_event_timer_class+0x61>
c103bc0b:	5a                   	pop    %edx
c103bc0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bc0f:	5b                   	pop    %ebx
c103bc10:	5e                   	pop    %esi
c103bc11:	5f                   	pop    %edi
c103bc12:	5d                   	pop    %ebp
c103bc13:	c3                   	ret

c103bc14 <ftrace_raw_event_timer_start>:
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103bc14:	55                   	push   %ebp
c103bc15:	89 e5                	mov    %esp,%ebp
c103bc17:	57                   	push   %edi
c103bc18:	89 c7                	mov    %eax,%edi
c103bc1a:	56                   	push   %esi
c103bc1b:	53                   	push   %ebx
c103bc1c:	89 d3                	mov    %edx,%ebx
c103bc1e:	83 ec 10             	sub    $0x10,%esp
c103bc21:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
c103bc24:	9c                   	pushf
c103bc25:	8f 45 e8             	popl   -0x18(%ebp)
c103bc28:	89 e0                	mov    %esp,%eax
c103bc2a:	8b 57 24             	mov    0x24(%edi),%edx
c103bc2d:	b9 1c 00 00 00       	mov    $0x1c,%ecx
c103bc32:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bc37:	8b 40 14             	mov    0x14(%eax),%eax
c103bc3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103bc3d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bc40:	ff 75 ec             	pushl  -0x14(%ebp)
c103bc43:	ff 75 e8             	pushl  -0x18(%ebp)
c103bc46:	e8 fc ff ff ff       	call   c103bc47 <ftrace_raw_event_timer_start+0x33>
c103bc4b:	89 c6                	mov    %eax,%esi
c103bc4d:	85 f6                	test   %esi,%esi
c103bc4f:	58                   	pop    %eax
c103bc50:	5a                   	pop    %edx
c103bc51:	74 42                	je     c103bc95 <ftrace_raw_event_timer_start+0x81>
c103bc53:	89 f0                	mov    %esi,%eax
c103bc55:	e8 fc ff ff ff       	call   c103bc56 <ftrace_raw_event_timer_start+0x42>
c103bc5a:	89 58 0c             	mov    %ebx,0xc(%eax)
c103bc5d:	8b 53 10             	mov    0x10(%ebx),%edx
c103bc60:	89 c1                	mov    %eax,%ecx
c103bc62:	89 50 10             	mov    %edx,0x10(%eax)
c103bc65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c103bc68:	89 50 14             	mov    %edx,0x14(%eax)
c103bc6b:	8b 15 00 00 00 00    	mov    0x0,%edx
c103bc71:	89 50 18             	mov    %edx,0x18(%eax)
c103bc74:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bc77:	89 fa                	mov    %edi,%edx
c103bc79:	56                   	push   %esi
c103bc7a:	e8 fc ff ff ff       	call   c103bc7b <ftrace_raw_event_timer_start+0x67>
c103bc7f:	5b                   	pop    %ebx
c103bc80:	85 c0                	test   %eax,%eax
c103bc82:	75 11                	jne    c103bc95 <ftrace_raw_event_timer_start+0x81>
c103bc84:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103bc87:	89 f2                	mov    %esi,%edx
c103bc89:	ff 75 ec             	pushl  -0x14(%ebp)
c103bc8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bc8f:	e8 fc ff ff ff       	call   c103bc90 <ftrace_raw_event_timer_start+0x7c>
c103bc94:	59                   	pop    %ecx
c103bc95:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bc98:	5b                   	pop    %ebx
c103bc99:	5e                   	pop    %esi
c103bc9a:	5f                   	pop    %edi
c103bc9b:	5d                   	pop    %ebp
c103bc9c:	c3                   	ret

c103bc9d <ftrace_raw_event_timer_expire_entry>:
 * timer_expire_entry - called immediately before the timer callback
 * @timer:	pointer to struct timer_list
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(timer_expire_entry,
c103bc9d:	55                   	push   %ebp
c103bc9e:	89 e5                	mov    %esp,%ebp
c103bca0:	57                   	push   %edi
c103bca1:	89 c7                	mov    %eax,%edi
c103bca3:	56                   	push   %esi
c103bca4:	53                   	push   %ebx
c103bca5:	89 d3                	mov    %edx,%ebx
c103bca7:	83 ec 0c             	sub    $0xc,%esp
c103bcaa:	9c                   	pushf
c103bcab:	8f 45 e8             	popl   -0x18(%ebp)
c103bcae:	89 e0                	mov    %esp,%eax
c103bcb0:	8b 57 24             	mov    0x24(%edi),%edx
c103bcb3:	b9 18 00 00 00       	mov    $0x18,%ecx
c103bcb8:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bcbd:	8b 40 14             	mov    0x14(%eax),%eax
c103bcc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103bcc3:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bcc6:	ff 75 ec             	pushl  -0x14(%ebp)
c103bcc9:	ff 75 e8             	pushl  -0x18(%ebp)
c103bccc:	e8 fc ff ff ff       	call   c103bccd <ftrace_raw_event_timer_expire_entry+0x30>
c103bcd1:	89 c6                	mov    %eax,%esi
c103bcd3:	85 f6                	test   %esi,%esi
c103bcd5:	58                   	pop    %eax
c103bcd6:	5a                   	pop    %edx
c103bcd7:	74 3c                	je     c103bd15 <ftrace_raw_event_timer_expire_entry+0x78>
c103bcd9:	89 f0                	mov    %esi,%eax
c103bcdb:	e8 fc ff ff ff       	call   c103bcdc <ftrace_raw_event_timer_expire_entry+0x3f>
c103bce0:	89 58 0c             	mov    %ebx,0xc(%eax)
c103bce3:	8b 15 00 00 00 00    	mov    0x0,%edx
c103bce9:	89 c1                	mov    %eax,%ecx
c103bceb:	89 50 10             	mov    %edx,0x10(%eax)
c103bcee:	8b 53 10             	mov    0x10(%ebx),%edx
c103bcf1:	89 50 14             	mov    %edx,0x14(%eax)
c103bcf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bcf7:	89 fa                	mov    %edi,%edx
c103bcf9:	56                   	push   %esi
c103bcfa:	e8 fc ff ff ff       	call   c103bcfb <ftrace_raw_event_timer_expire_entry+0x5e>
c103bcff:	5b                   	pop    %ebx
c103bd00:	85 c0                	test   %eax,%eax
c103bd02:	75 11                	jne    c103bd15 <ftrace_raw_event_timer_expire_entry+0x78>
c103bd04:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103bd07:	89 f2                	mov    %esi,%edx
c103bd09:	ff 75 ec             	pushl  -0x14(%ebp)
c103bd0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bd0f:	e8 fc ff ff ff       	call   c103bd10 <ftrace_raw_event_timer_expire_entry+0x73>
c103bd14:	59                   	pop    %ecx
c103bd15:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bd18:	5b                   	pop    %ebx
c103bd19:	5e                   	pop    %esi
c103bd1a:	5f                   	pop    %edi
c103bd1b:	5d                   	pop    %ebp
c103bd1c:	c3                   	ret

c103bd1d <ftrace_raw_event_hrtimer_init>:
 * hrtimer_init - called when the hrtimer is initialized
 * @timer:	pointer to struct hrtimer
 * @clockid:	the hrtimers clock
 * @mode:	the hrtimers mode
 */
TRACE_EVENT(hrtimer_init,
c103bd1d:	55                   	push   %ebp
c103bd1e:	89 e5                	mov    %esp,%ebp
c103bd20:	57                   	push   %edi
c103bd21:	56                   	push   %esi
c103bd22:	89 c6                	mov    %eax,%esi
c103bd24:	53                   	push   %ebx
c103bd25:	83 ec 10             	sub    $0x10,%esp
c103bd28:	89 55 e8             	mov    %edx,-0x18(%ebp)
c103bd2b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
c103bd2e:	9c                   	pushf
c103bd2f:	8f 45 ec             	popl   -0x14(%ebp)
c103bd32:	89 e0                	mov    %esp,%eax
c103bd34:	8b 56 24             	mov    0x24(%esi),%edx
c103bd37:	b9 18 00 00 00       	mov    $0x18,%ecx
c103bd3c:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bd41:	8b 78 14             	mov    0x14(%eax),%edi
c103bd44:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bd47:	57                   	push   %edi
c103bd48:	ff 75 ec             	pushl  -0x14(%ebp)
c103bd4b:	e8 fc ff ff ff       	call   c103bd4c <ftrace_raw_event_hrtimer_init+0x2f>
c103bd50:	89 c3                	mov    %eax,%ebx
c103bd52:	85 db                	test   %ebx,%ebx
c103bd54:	58                   	pop    %eax
c103bd55:	5a                   	pop    %edx
c103bd56:	74 3a                	je     c103bd92 <ftrace_raw_event_hrtimer_init+0x75>
c103bd58:	89 d8                	mov    %ebx,%eax
c103bd5a:	e8 fc ff ff ff       	call   c103bd5b <ftrace_raw_event_hrtimer_init+0x3e>
c103bd5f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c103bd62:	89 50 0c             	mov    %edx,0xc(%eax)
c103bd65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c103bd68:	89 c1                	mov    %eax,%ecx
c103bd6a:	89 50 10             	mov    %edx,0x10(%eax)
c103bd6d:	8b 55 08             	mov    0x8(%ebp),%edx
c103bd70:	89 50 14             	mov    %edx,0x14(%eax)
c103bd73:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bd76:	89 f2                	mov    %esi,%edx
c103bd78:	53                   	push   %ebx
c103bd79:	e8 fc ff ff ff       	call   c103bd7a <ftrace_raw_event_hrtimer_init+0x5d>
c103bd7e:	5e                   	pop    %esi
c103bd7f:	85 c0                	test   %eax,%eax
c103bd81:	75 0f                	jne    c103bd92 <ftrace_raw_event_hrtimer_init+0x75>
c103bd83:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c103bd86:	89 da                	mov    %ebx,%edx
c103bd88:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bd8b:	57                   	push   %edi
c103bd8c:	e8 fc ff ff ff       	call   c103bd8d <ftrace_raw_event_hrtimer_init+0x70>
c103bd91:	59                   	pop    %ecx
c103bd92:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bd95:	5b                   	pop    %ebx
c103bd96:	5e                   	pop    %esi
c103bd97:	5f                   	pop    %edi
c103bd98:	5d                   	pop    %ebp
c103bd99:	c3                   	ret

c103bd9a <ftrace_raw_event_hrtimer_start>:

/**
 * hrtimer_start - called when the hrtimer is started
 * @timer: pointer to struct hrtimer
 */
TRACE_EVENT(hrtimer_start,
c103bd9a:	55                   	push   %ebp
c103bd9b:	89 e5                	mov    %esp,%ebp
c103bd9d:	57                   	push   %edi
c103bd9e:	89 c7                	mov    %eax,%edi
c103bda0:	56                   	push   %esi
c103bda1:	53                   	push   %ebx
c103bda2:	89 d3                	mov    %edx,%ebx
c103bda4:	83 ec 0c             	sub    $0xc,%esp
c103bda7:	9c                   	pushf
c103bda8:	8f 45 e8             	popl   -0x18(%ebp)
c103bdab:	89 e0                	mov    %esp,%eax
c103bdad:	8b 57 24             	mov    0x24(%edi),%edx
c103bdb0:	b9 24 00 00 00       	mov    $0x24,%ecx
c103bdb5:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bdba:	8b 40 14             	mov    0x14(%eax),%eax
c103bdbd:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103bdc0:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bdc3:	ff 75 ec             	pushl  -0x14(%ebp)
c103bdc6:	ff 75 e8             	pushl  -0x18(%ebp)
c103bdc9:	e8 fc ff ff ff       	call   c103bdca <ftrace_raw_event_hrtimer_start+0x30>
c103bdce:	89 c6                	mov    %eax,%esi
c103bdd0:	85 f6                	test   %esi,%esi
c103bdd2:	58                   	pop    %eax
c103bdd3:	5a                   	pop    %edx
c103bdd4:	74 4b                	je     c103be21 <ftrace_raw_event_hrtimer_start+0x87>
c103bdd6:	89 f0                	mov    %esi,%eax
c103bdd8:	e8 fc ff ff ff       	call   c103bdd9 <ftrace_raw_event_hrtimer_start+0x3f>
c103bddd:	89 58 0c             	mov    %ebx,0xc(%eax)
c103bde0:	8b 53 1c             	mov    0x1c(%ebx),%edx
c103bde3:	89 50 10             	mov    %edx,0x10(%eax)
	timer->_softexpires = ktime_add_ns(timer->_softexpires, ns);
}

static inline ktime_t hrtimer_get_expires(const struct hrtimer *timer)
{
	return timer->node.expires;
c103bde6:	8b 53 0c             	mov    0xc(%ebx),%edx
c103bde9:	8b 4b 10             	mov    0x10(%ebx),%ecx
c103bdec:	89 50 14             	mov    %edx,0x14(%eax)
c103bdef:	89 48 18             	mov    %ecx,0x18(%eax)
}

static inline ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)
{
	return timer->_softexpires;
c103bdf2:	8b 53 14             	mov    0x14(%ebx),%edx
c103bdf5:	8b 4b 18             	mov    0x18(%ebx),%ecx
c103bdf8:	89 50 1c             	mov    %edx,0x1c(%eax)
c103bdfb:	89 fa                	mov    %edi,%edx
c103bdfd:	89 48 20             	mov    %ecx,0x20(%eax)
c103be00:	89 c1                	mov    %eax,%ecx
c103be02:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103be05:	56                   	push   %esi
c103be06:	e8 fc ff ff ff       	call   c103be07 <ftrace_raw_event_hrtimer_start+0x6d>
c103be0b:	5b                   	pop    %ebx
c103be0c:	85 c0                	test   %eax,%eax
c103be0e:	75 11                	jne    c103be21 <ftrace_raw_event_hrtimer_start+0x87>
c103be10:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103be13:	89 f2                	mov    %esi,%edx
c103be15:	ff 75 ec             	pushl  -0x14(%ebp)
c103be18:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103be1b:	e8 fc ff ff ff       	call   c103be1c <ftrace_raw_event_hrtimer_start+0x82>
c103be20:	59                   	pop    %ecx
c103be21:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103be24:	5b                   	pop    %ebx
c103be25:	5e                   	pop    %esi
c103be26:	5f                   	pop    %edi
c103be27:	5d                   	pop    %ebp
c103be28:	c3                   	ret

c103be29 <ftrace_raw_event_hrtimer_expire_entry>:
 * @now:	pointer to variable which contains current time of the
 *		timers base.
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(hrtimer_expire_entry,
c103be29:	55                   	push   %ebp
c103be2a:	89 e5                	mov    %esp,%ebp
c103be2c:	57                   	push   %edi
c103be2d:	89 c7                	mov    %eax,%edi
c103be2f:	56                   	push   %esi
c103be30:	53                   	push   %ebx
c103be31:	89 d3                	mov    %edx,%ebx
c103be33:	83 ec 10             	sub    $0x10,%esp
c103be36:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
c103be39:	9c                   	pushf
c103be3a:	8f 45 e8             	popl   -0x18(%ebp)
c103be3d:	89 e0                	mov    %esp,%eax
c103be3f:	8b 57 24             	mov    0x24(%edi),%edx
c103be42:	b9 1c 00 00 00       	mov    $0x1c,%ecx
c103be47:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103be4c:	8b 40 14             	mov    0x14(%eax),%eax
c103be4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103be52:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103be55:	ff 75 ec             	pushl  -0x14(%ebp)
c103be58:	ff 75 e8             	pushl  -0x18(%ebp)
c103be5b:	e8 fc ff ff ff       	call   c103be5c <ftrace_raw_event_hrtimer_expire_entry+0x33>
c103be60:	89 c6                	mov    %eax,%esi
c103be62:	85 f6                	test   %esi,%esi
c103be64:	58                   	pop    %eax
c103be65:	5a                   	pop    %edx
c103be66:	74 41                	je     c103bea9 <ftrace_raw_event_hrtimer_expire_entry+0x80>
c103be68:	89 f0                	mov    %esi,%eax
c103be6a:	e8 fc ff ff ff       	call   c103be6b <ftrace_raw_event_hrtimer_expire_entry+0x42>
c103be6f:	89 58 0c             	mov    %ebx,0xc(%eax)
c103be72:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c103be75:	8b 11                	mov    (%ecx),%edx
c103be77:	8b 49 04             	mov    0x4(%ecx),%ecx
c103be7a:	89 50 10             	mov    %edx,0x10(%eax)
c103be7d:	89 48 14             	mov    %ecx,0x14(%eax)
c103be80:	8b 53 1c             	mov    0x1c(%ebx),%edx
c103be83:	89 c1                	mov    %eax,%ecx
c103be85:	89 50 18             	mov    %edx,0x18(%eax)
c103be88:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103be8b:	89 fa                	mov    %edi,%edx
c103be8d:	56                   	push   %esi
c103be8e:	e8 fc ff ff ff       	call   c103be8f <ftrace_raw_event_hrtimer_expire_entry+0x66>
c103be93:	5b                   	pop    %ebx
c103be94:	85 c0                	test   %eax,%eax
c103be96:	75 11                	jne    c103bea9 <ftrace_raw_event_hrtimer_expire_entry+0x80>
c103be98:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103be9b:	89 f2                	mov    %esi,%edx
c103be9d:	ff 75 ec             	pushl  -0x14(%ebp)
c103bea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bea3:	e8 fc ff ff ff       	call   c103bea4 <ftrace_raw_event_hrtimer_expire_entry+0x7b>
c103bea8:	59                   	pop    %ecx
c103bea9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103beac:	5b                   	pop    %ebx
c103bead:	5e                   	pop    %esi
c103beae:	5f                   	pop    %edi
c103beaf:	5d                   	pop    %ebp
c103beb0:	c3                   	ret

c103beb1 <ftrace_raw_event_hrtimer_class>:

	TP_printk("hrtimer=%p function=%pf now=%llu", __entry->hrtimer, __entry->function,
		  (unsigned long long)ktime_to_ns((ktime_t) { .tv64 = __entry->now }))
 );

DECLARE_EVENT_CLASS(hrtimer_class,
c103beb1:	55                   	push   %ebp
c103beb2:	89 e5                	mov    %esp,%ebp
c103beb4:	57                   	push   %edi
c103beb5:	56                   	push   %esi
c103beb6:	89 c6                	mov    %eax,%esi
c103beb8:	53                   	push   %ebx
c103beb9:	83 ec 0c             	sub    $0xc,%esp
c103bebc:	89 55 e8             	mov    %edx,-0x18(%ebp)
c103bebf:	9c                   	pushf
c103bec0:	8f 45 ec             	popl   -0x14(%ebp)
c103bec3:	89 e0                	mov    %esp,%eax
c103bec5:	8b 56 24             	mov    0x24(%esi),%edx
c103bec8:	b9 10 00 00 00       	mov    $0x10,%ecx
c103becd:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bed2:	8b 78 14             	mov    0x14(%eax),%edi
c103bed5:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bed8:	57                   	push   %edi
c103bed9:	ff 75 ec             	pushl  -0x14(%ebp)
c103bedc:	e8 fc ff ff ff       	call   c103bedd <ftrace_raw_event_hrtimer_class+0x2c>
c103bee1:	89 c3                	mov    %eax,%ebx
c103bee3:	85 db                	test   %ebx,%ebx
c103bee5:	58                   	pop    %eax
c103bee6:	5a                   	pop    %edx
c103bee7:	74 2e                	je     c103bf17 <ftrace_raw_event_hrtimer_class+0x66>
c103bee9:	89 d8                	mov    %ebx,%eax
c103beeb:	e8 fc ff ff ff       	call   c103beec <ftrace_raw_event_hrtimer_class+0x3b>
c103bef0:	8b 55 e8             	mov    -0x18(%ebp),%edx
c103bef3:	89 c1                	mov    %eax,%ecx
c103bef5:	89 50 0c             	mov    %edx,0xc(%eax)
c103bef8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103befb:	89 f2                	mov    %esi,%edx
c103befd:	53                   	push   %ebx
c103befe:	e8 fc ff ff ff       	call   c103beff <ftrace_raw_event_hrtimer_class+0x4e>
c103bf03:	5e                   	pop    %esi
c103bf04:	85 c0                	test   %eax,%eax
c103bf06:	75 0f                	jne    c103bf17 <ftrace_raw_event_hrtimer_class+0x66>
c103bf08:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c103bf0b:	89 da                	mov    %ebx,%edx
c103bf0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bf10:	57                   	push   %edi
c103bf11:	e8 fc ff ff ff       	call   c103bf12 <ftrace_raw_event_hrtimer_class+0x61>
c103bf16:	59                   	pop    %ecx
c103bf17:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bf1a:	5b                   	pop    %ebx
c103bf1b:	5e                   	pop    %esi
c103bf1c:	5f                   	pop    %edi
c103bf1d:	5d                   	pop    %ebp
c103bf1e:	c3                   	ret

c103bf1f <ftrace_raw_event_itimer_state>:
 * @which:	name of the interval timer
 * @value:	the itimers value, itimer is canceled if value->it_value is
 *		zero, otherwise it is started
 * @expires:	the itimers expiry time
 */
TRACE_EVENT(itimer_state,
c103bf1f:	55                   	push   %ebp
c103bf20:	89 e5                	mov    %esp,%ebp
c103bf22:	57                   	push   %edi
c103bf23:	89 c7                	mov    %eax,%edi
c103bf25:	56                   	push   %esi
c103bf26:	53                   	push   %ebx
c103bf27:	89 cb                	mov    %ecx,%ebx
c103bf29:	83 ec 10             	sub    $0x10,%esp
c103bf2c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c103bf2f:	9c                   	pushf
c103bf30:	8f 45 e8             	popl   -0x18(%ebp)
c103bf33:	89 e0                	mov    %esp,%eax
c103bf35:	8b 57 24             	mov    0x24(%edi),%edx
c103bf38:	b9 24 00 00 00       	mov    $0x24,%ecx
c103bf3d:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bf42:	8b 40 14             	mov    0x14(%eax),%eax
c103bf45:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103bf48:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bf4b:	ff 75 ec             	pushl  -0x14(%ebp)
c103bf4e:	ff 75 e8             	pushl  -0x18(%ebp)
c103bf51:	e8 fc ff ff ff       	call   c103bf52 <ftrace_raw_event_itimer_state+0x33>
c103bf56:	89 c6                	mov    %eax,%esi
c103bf58:	85 f6                	test   %esi,%esi
c103bf5a:	58                   	pop    %eax
c103bf5b:	5a                   	pop    %edx
c103bf5c:	74 4d                	je     c103bfab <ftrace_raw_event_itimer_state+0x8c>
c103bf5e:	89 f0                	mov    %esi,%eax
c103bf60:	e8 fc ff ff ff       	call   c103bf61 <ftrace_raw_event_itimer_state+0x42>
c103bf65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c103bf68:	89 50 0c             	mov    %edx,0xc(%eax)
c103bf6b:	8b 55 08             	mov    0x8(%ebp),%edx
c103bf6e:	89 c1                	mov    %eax,%ecx
c103bf70:	89 50 10             	mov    %edx,0x10(%eax)
c103bf73:	8b 53 08             	mov    0x8(%ebx),%edx
c103bf76:	89 50 14             	mov    %edx,0x14(%eax)
c103bf79:	8b 53 0c             	mov    0xc(%ebx),%edx
c103bf7c:	89 50 18             	mov    %edx,0x18(%eax)
c103bf7f:	8b 13                	mov    (%ebx),%edx
c103bf81:	89 50 1c             	mov    %edx,0x1c(%eax)
c103bf84:	8b 53 04             	mov    0x4(%ebx),%edx
c103bf87:	89 50 20             	mov    %edx,0x20(%eax)
c103bf8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bf8d:	89 fa                	mov    %edi,%edx
c103bf8f:	56                   	push   %esi
c103bf90:	e8 fc ff ff ff       	call   c103bf91 <ftrace_raw_event_itimer_state+0x72>
c103bf95:	5b                   	pop    %ebx
c103bf96:	85 c0                	test   %eax,%eax
c103bf98:	75 11                	jne    c103bfab <ftrace_raw_event_itimer_state+0x8c>
c103bf9a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103bf9d:	89 f2                	mov    %esi,%edx
c103bf9f:	ff 75 ec             	pushl  -0x14(%ebp)
c103bfa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103bfa5:	e8 fc ff ff ff       	call   c103bfa6 <ftrace_raw_event_itimer_state+0x87>
c103bfaa:	59                   	pop    %ecx
c103bfab:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103bfae:	5b                   	pop    %ebx
c103bfaf:	5e                   	pop    %esi
c103bfb0:	5f                   	pop    %edi
c103bfb1:	5d                   	pop    %ebp
c103bfb2:	c3                   	ret

c103bfb3 <ftrace_raw_event_itimer_expire>:
 * itimer_expire - called when itimer expires
 * @which:	type of the interval timer
 * @pid:	pid of the process which owns the timer
 * @now:	current time, used to calculate the latency of itimer
 */
TRACE_EVENT(itimer_expire,
c103bfb3:	55                   	push   %ebp
c103bfb4:	89 e5                	mov    %esp,%ebp
c103bfb6:	57                   	push   %edi
c103bfb7:	89 cf                	mov    %ecx,%edi
c103bfb9:	56                   	push   %esi
c103bfba:	89 c6                	mov    %eax,%esi
c103bfbc:	53                   	push   %ebx
c103bfbd:	83 ec 10             	sub    $0x10,%esp
c103bfc0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c103bfc3:	9c                   	pushf
c103bfc4:	8f 45 e8             	popl   -0x18(%ebp)
c103bfc7:	89 e0                	mov    %esp,%eax
c103bfc9:	b9 18 00 00 00       	mov    $0x18,%ecx
c103bfce:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103bfd3:	8b 40 14             	mov    0x14(%eax),%eax
c103bfd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
c103bfd9:	8b 56 24             	mov    0x24(%esi),%edx
c103bfdc:	8d 45 f0             	lea    -0x10(%ebp),%eax
c103bfdf:	ff 75 ec             	pushl  -0x14(%ebp)
c103bfe2:	ff 75 e8             	pushl  -0x18(%ebp)
c103bfe5:	e8 fc ff ff ff       	call   c103bfe6 <ftrace_raw_event_itimer_expire+0x33>
c103bfea:	89 c3                	mov    %eax,%ebx
c103bfec:	85 db                	test   %ebx,%ebx
c103bfee:	58                   	pop    %eax
c103bfef:	5a                   	pop    %edx
c103bff0:	74 42                	je     c103c034 <ftrace_raw_event_itimer_expire+0x81>
c103bff2:	89 d8                	mov    %ebx,%eax
c103bff4:	e8 fc ff ff ff       	call   c103bff5 <ftrace_raw_event_itimer_expire+0x42>
c103bff9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c103bffc:	89 50 0c             	mov    %edx,0xc(%eax)
c103bfff:	8b 55 08             	mov    0x8(%ebp),%edx
c103c002:	89 50 14             	mov    %edx,0x14(%eax)
 */

static inline pid_t pid_nr(struct pid *pid)
{
	pid_t nr = 0;
	if (pid)
c103c005:	31 d2                	xor    %edx,%edx
c103c007:	85 ff                	test   %edi,%edi
c103c009:	74 03                	je     c103c00e <ftrace_raw_event_itimer_expire+0x5b>
		nr = pid->numbers[0].nr;
c103c00b:	8b 57 1c             	mov    0x1c(%edi),%edx
c103c00e:	89 50 10             	mov    %edx,0x10(%eax)
c103c011:	89 c1                	mov    %eax,%ecx
c103c013:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103c016:	89 f2                	mov    %esi,%edx
c103c018:	53                   	push   %ebx
c103c019:	e8 fc ff ff ff       	call   c103c01a <ftrace_raw_event_itimer_expire+0x67>
c103c01e:	5e                   	pop    %esi
c103c01f:	85 c0                	test   %eax,%eax
c103c021:	75 11                	jne    c103c034 <ftrace_raw_event_itimer_expire+0x81>
c103c023:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c103c026:	89 da                	mov    %ebx,%edx
c103c028:	ff 75 ec             	pushl  -0x14(%ebp)
c103c02b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c103c02e:	e8 fc ff ff ff       	call   c103c02f <ftrace_raw_event_itimer_expire+0x7c>
c103c033:	59                   	pop    %ecx
c103c034:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103c037:	5b                   	pop    %ebx
c103c038:	5e                   	pop    %esi
c103c039:	5f                   	pop    %edi
c103c03a:	5d                   	pop    %ebp
c103c03b:	c3                   	ret

c103c03c <usleep_range>:
 * usleep_range - Drop in replacement for udelay where wakeup is flexible
 * @min: Minimum time in usecs to sleep
 * @max: Maximum time in usecs to sleep
 */
void usleep_range(unsigned long min, unsigned long max)
{
c103c03c:	55                   	push   %ebp
	ktime_t kmin;
	unsigned long delta;

	kmin = ktime_set(0, min * NSEC_PER_USEC);
	delta = (max - min) * NSEC_PER_USEC;
	return schedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);
c103c03d:	29 c2                	sub    %eax,%edx
 * usleep_range - Drop in replacement for udelay where wakeup is flexible
 * @min: Minimum time in usecs to sleep
 * @max: Maximum time in usecs to sleep
 */
void usleep_range(unsigned long min, unsigned long max)
{
c103c03f:	89 e5                	mov    %esp,%ebp
	ktime_t kmin;
	unsigned long delta;

	kmin = ktime_set(0, min * NSEC_PER_USEC);
	delta = (max - min) * NSEC_PER_USEC;
	return schedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);
c103c041:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
 * usleep_range - Drop in replacement for udelay where wakeup is flexible
 * @min: Minimum time in usecs to sleep
 * @max: Maximum time in usecs to sleep
 */
void usleep_range(unsigned long min, unsigned long max)
{
c103c047:	53                   	push   %ebx
{
#if (BITS_PER_LONG == 64)
	if (unlikely(secs >= KTIME_SEC_MAX))
		return (ktime_t){ .tv64 = KTIME_MAX };
#endif
	return (ktime_t) { .tv64 = (s64)secs * NSEC_PER_SEC + (s64)nsecs };
c103c048:	69 d8 e8 03 00 00    	imul   $0x3e8,%eax,%ebx
c103c04e:	83 ec 08             	sub    $0x8,%esp
c103c051:	64 8b 0d 00 00 00 00 	mov    %fs:0x0,%ecx
	__set_current_state(TASK_UNINTERRUPTIBLE);
c103c058:	c7 01 02 00 00 00    	movl   $0x2,(%ecx)
c103c05e:	31 c9                	xor    %ecx,%ecx
static int __sched do_usleep_range(unsigned long min, unsigned long max)
{
	ktime_t kmin;
	unsigned long delta;

	kmin = ktime_set(0, min * NSEC_PER_USEC);
c103c060:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	delta = (max - min) * NSEC_PER_USEC;
	return schedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);
c103c063:	8d 45 f4             	lea    -0xc(%ebp),%eax
c103c066:	b1 01                	mov    $0x1,%cl
static int __sched do_usleep_range(unsigned long min, unsigned long max)
{
	ktime_t kmin;
	unsigned long delta;

	kmin = ktime_set(0, min * NSEC_PER_USEC);
c103c068:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	delta = (max - min) * NSEC_PER_USEC;
	return schedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);
c103c06b:	e8 fc ff ff ff       	call   c103c06c <usleep_range+0x30>
 */
void usleep_range(unsigned long min, unsigned long max)
{
	__set_current_state(TASK_UNINTERRUPTIBLE);
	do_usleep_range(min, max);
}
c103c070:	59                   	pop    %ecx
c103c071:	5b                   	pop    %ebx
c103c072:	5b                   	pop    %ebx
c103c073:	5d                   	pop    %ebp
c103c074:	c3                   	ret

c103c075 <rcu_read_unlock_sched_notrace>:
	preempt_enable();
}

/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */
static inline notrace void rcu_read_unlock_sched_notrace(void)
{
c103c075:	55                   	push   %ebp
c103c076:	89 e5                	mov    %esp,%ebp
register unsigned long current_stack_pointer asm("esp") __used;

/* how to get the thread information struct from C */
static inline struct thread_info *current_thread_info(void)
{
	return (struct thread_info *)
c103c078:	89 e0                	mov    %esp,%eax
c103c07a:	25 00 e0 ff ff       	and    $0xffffe000,%eax
	__release(RCU_SCHED);
	preempt_enable_notrace();
c103c07f:	ff 48 14             	decl   0x14(%eax)
c103c082:	8b 40 08             	mov    0x8(%eax),%eax
c103c085:	a8 08                	test   $0x8,%al
c103c087:	74 05                	je     c103c08e <rcu_read_unlock_sched_notrace+0x19>
c103c089:	e8 fc ff ff ff       	call   c103c08a <rcu_read_unlock_sched_notrace+0x15>
}
c103c08e:	5d                   	pop    %ebp
c103c08f:	c3                   	ret

c103c090 <detach_timer>:
}
EXPORT_SYMBOL(init_timer_deferrable_key);

static inline void detach_timer(struct timer_list *timer,
				int clear_pending)
{
c103c090:	55                   	push   %ebp

/**
 * timer_cancel - called when the timer is canceled
 * @timer:	pointer to struct timer_list
 */
DEFINE_EVENT(timer_class, timer_cancel,
c103c091:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
c103c098:	89 e5                	mov    %esp,%ebp
c103c09a:	57                   	push   %edi
c103c09b:	89 d7                	mov    %edx,%edi
c103c09d:	56                   	push   %esi
c103c09e:	89 c6                	mov    %eax,%esi
c103c0a0:	53                   	push   %ebx
c103c0a1:	74 28                	je     c103c0cb <detach_timer+0x3b>
c103c0a3:	89 e0                	mov    %esp,%eax
c103c0a5:	25 00 e0 ff ff       	and    $0xffffe000,%eax
}

/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */
static inline notrace void rcu_read_lock_sched_notrace(void)
{
	preempt_disable_notrace();
c103c0aa:	ff 40 14             	incl   0x14(%eax)
c103c0ad:	8b 1d 10 00 00 00    	mov    0x10,%ebx
c103c0b3:	85 db                	test   %ebx,%ebx
c103c0b5:	74 0f                	je     c103c0c6 <detach_timer+0x36>
c103c0b7:	8b 43 04             	mov    0x4(%ebx),%eax
c103c0ba:	89 f2                	mov    %esi,%edx
c103c0bc:	ff 13                	call   *(%ebx)
c103c0be:	83 c3 08             	add    $0x8,%ebx
c103c0c1:	83 3b 00             	cmpl   $0x0,(%ebx)
c103c0c4:	eb ef                	jmp    c103c0b5 <detach_timer+0x25>
c103c0c6:	e8 aa ff ff ff       	call   c103c075 <rcu_read_unlock_sched_notrace>
	struct list_head *entry = &timer->entry;

	debug_deactivate(timer);

	__list_del(entry->prev, entry->next);
c103c0cb:	8b 16                	mov    (%esi),%edx
	if (clear_pending)
c103c0cd:	85 ff                	test   %edi,%edi
{
	struct list_head *entry = &timer->entry;

	debug_deactivate(timer);

	__list_del(entry->prev, entry->next);
c103c0cf:	8b 46 04             	mov    0x4(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
c103c0d2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
c103c0d5:	89 10                	mov    %edx,(%eax)
	if (clear_pending)
c103c0d7:	74 06                	je     c103c0df <detach_timer+0x4f>
		entry->next = NULL;
c103c0d9:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	entry->prev = LIST_POISON2;
c103c0df:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
}
c103c0e6:	5b                   	pop    %ebx
c103c0e7:	5e                   	pop    %esi
c103c0e8:	5f                   	pop    %edi
c103c0e9:	5d                   	pop    %ebp
c103c0ea:	c3                   	ret

c103c0eb <migrate_timer_list>:
	return 0;
}

#ifdef CONFIG_HOTPLUG_CPU
static void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)
{
c103c0eb:	55                   	push   %ebp
c103c0ec:	89 e5                	mov    %esp,%ebp
c103c0ee:	57                   	push   %edi
c103c0ef:	89 d7                	mov    %edx,%edi
c103c0f1:	56                   	push   %esi
c103c0f2:	89 c6                	mov    %eax,%esi
c103c0f4:	53                   	push   %ebx
	struct timer_list *timer;

	while (!list_empty(head)) {
c103c0f5:	eb 2c                	jmp    c103c123 <migrate_timer_list+0x38>
		timer = list_first_entry(head, struct timer_list, entry);
		detach_timer(timer, 0);
c103c0f7:	31 d2                	xor    %edx,%edx
c103c0f9:	89 d8                	mov    %ebx,%eax
c103c0fb:	e8 90 ff ff ff       	call   c103c090 <detach_timer>
}

static inline void
timer_set_base(struct timer_list *timer, struct tvec_base *new_base)
{
	timer->base = (struct tvec_base *)((unsigned long)(new_base) |
c103c100:	8b 43 0c             	mov    0xc(%ebx),%eax

	while (!list_empty(head)) {
		timer = list_first_entry(head, struct timer_list, entry);
		detach_timer(timer, 0);
		timer_set_base(timer, new_base);
		if (time_before(timer->expires, new_base->next_timer) &&
c103c103:	8b 53 08             	mov    0x8(%ebx),%edx
}

static inline void
timer_set_base(struct timer_list *timer, struct tvec_base *new_base)
{
	timer->base = (struct tvec_base *)((unsigned long)(new_base) |
c103c106:	83 e0 01             	and    $0x1,%eax
c103c109:	09 f0                	or     %esi,%eax
c103c10b:	89 43 0c             	mov    %eax,0xc(%ebx)

	while (!list_empty(head)) {
		timer = list_first_entry(head, struct timer_list, entry);
		detach_timer(timer, 0);
		timer_set_base(timer, new_base);
		if (time_before(timer->expires, new_base->next_timer) &&
c103c10e:	3b 56 0c             	cmp    0xc(%esi),%edx
c103c111:	79 07                	jns    c103c11a <migrate_timer_list+0x2f>
c103c113:	a8 01                	test   $0x1,%al
c103c115:	75 03                	jne    c103c11a <migrate_timer_list+0x2f>
		    !tbase_get_deferrable(timer->base))
			new_base->next_timer = timer->expires;
c103c117:	89 56 0c             	mov    %edx,0xc(%esi)
		internal_add_timer(new_base, timer);
c103c11a:	89 da                	mov    %ebx,%edx
c103c11c:	89 f0                	mov    %esi,%eax
c103c11e:	e8 03 eb ff ff       	call   c103ac26 <internal_add_timer>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
c103c123:	8b 1f                	mov    (%edi),%ebx
#ifdef CONFIG_HOTPLUG_CPU
static void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)
{
	struct timer_list *timer;

	while (!list_empty(head)) {
c103c125:	39 fb                	cmp    %edi,%ebx
c103c127:	75 ce                	jne    c103c0f7 <migrate_timer_list+0xc>
		if (time_before(timer->expires, new_base->next_timer) &&
		    !tbase_get_deferrable(timer->base))
			new_base->next_timer = timer->expires;
		internal_add_timer(new_base, timer);
	}
}
c103c129:	5b                   	pop    %ebx
c103c12a:	5e                   	pop    %esi
c103c12b:	5f                   	pop    %edi
c103c12c:	5d                   	pop    %ebp
c103c12d:	c3                   	ret

c103c12e <debug_activate>:
	trace_timer_init(timer);
}

static inline void
debug_activate(struct timer_list *timer, unsigned long expires)
{
c103c12e:	55                   	push   %ebp
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103c12f:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
c103c136:	89 e5                	mov    %esp,%ebp
c103c138:	57                   	push   %edi
c103c139:	89 c7                	mov    %eax,%edi
c103c13b:	56                   	push   %esi
c103c13c:	89 d6                	mov    %edx,%esi
c103c13e:	53                   	push   %ebx
c103c13f:	74 2a                	je     c103c16b <debug_activate+0x3d>
c103c141:	89 e0                	mov    %esp,%eax
c103c143:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c148:	ff 40 14             	incl   0x14(%eax)
c103c14b:	8b 1d 10 00 00 00    	mov    0x10,%ebx
c103c151:	85 db                	test   %ebx,%ebx
c103c153:	74 11                	je     c103c166 <debug_activate+0x38>
c103c155:	8b 43 04             	mov    0x4(%ebx),%eax
c103c158:	89 f1                	mov    %esi,%ecx
c103c15a:	89 fa                	mov    %edi,%edx
c103c15c:	ff 13                	call   *(%ebx)
c103c15e:	83 c3 08             	add    $0x8,%ebx
c103c161:	83 3b 00             	cmpl   $0x0,(%ebx)
c103c164:	eb ed                	jmp    c103c153 <debug_activate+0x25>
c103c166:	e8 0a ff ff ff       	call   c103c075 <rcu_read_unlock_sched_notrace>
	debug_timer_activate(timer);
	trace_timer_start(timer, expires);
}
c103c16b:	5b                   	pop    %ebx
c103c16c:	5e                   	pop    %esi
c103c16d:	5f                   	pop    %edi
c103c16e:	5d                   	pop    %ebp
c103c16f:	c3                   	ret

c103c170 <init_timer_key>:
 * other timer functions.
 */
void init_timer_key(struct timer_list *timer,
		    const char *name,
		    struct lock_class_key *key)
{
c103c170:	55                   	push   %ebp

/**
 * timer_init - called when the timer is initialized
 * @timer:	pointer to struct timer_list
 */
DEFINE_EVENT(timer_class, timer_init,
c103c171:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
c103c178:	89 e5                	mov    %esp,%ebp
c103c17a:	57                   	push   %edi
c103c17b:	56                   	push   %esi
c103c17c:	53                   	push   %ebx
c103c17d:	89 c3                	mov    %eax,%ebx
c103c17f:	74 28                	je     c103c1a9 <init_timer_key+0x39>
c103c181:	89 e0                	mov    %esp,%eax
c103c183:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c188:	ff 40 14             	incl   0x14(%eax)
c103c18b:	8b 35 10 00 00 00    	mov    0x10,%esi
c103c191:	85 f6                	test   %esi,%esi
c103c193:	74 0f                	je     c103c1a4 <init_timer_key+0x34>
c103c195:	8b 46 04             	mov    0x4(%esi),%eax
c103c198:	89 da                	mov    %ebx,%edx
c103c19a:	ff 16                	call   *(%esi)
c103c19c:	83 c6 08             	add    $0x8,%esi
c103c19f:	83 3e 00             	cmpl   $0x0,(%esi)
c103c1a2:	eb ef                	jmp    c103c193 <init_timer_key+0x23>
c103c1a4:	e8 cc fe ff ff       	call   c103c075 <rcu_read_unlock_sched_notrace>

static void __init_timer(struct timer_list *timer,
			 const char *name,
			 struct lock_class_key *key)
{
	timer->entry.next = NULL;
c103c1a9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	timer->base = __raw_get_cpu_var(tvec_bases);
c103c1af:	b8 00 00 00 00       	mov    $0x0,%eax
c103c1b4:	64 03 05 00 00 00 00 	add    %fs:0x0,%eax
c103c1bb:	8b 00                	mov    (%eax),%eax
	timer->slack = -1;
#ifdef CONFIG_TIMER_STATS
	timer->start_site = NULL;
	timer->start_pid = -1;
	memset(timer->start_comm, 0, TASK_COMM_LEN);
c103c1bd:	8d 53 24             	lea    0x24(%ebx),%edx
c103c1c0:	b9 04 00 00 00       	mov    $0x4,%ecx
c103c1c5:	89 d7                	mov    %edx,%edi
			 const char *name,
			 struct lock_class_key *key)
{
	timer->entry.next = NULL;
	timer->base = __raw_get_cpu_var(tvec_bases);
	timer->slack = -1;
c103c1c7:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
#ifdef CONFIG_TIMER_STATS
	timer->start_site = NULL;
c103c1ce:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
static void __init_timer(struct timer_list *timer,
			 const char *name,
			 struct lock_class_key *key)
{
	timer->entry.next = NULL;
	timer->base = __raw_get_cpu_var(tvec_bases);
c103c1d5:	89 43 0c             	mov    %eax,0xc(%ebx)
	timer->slack = -1;
#ifdef CONFIG_TIMER_STATS
	timer->start_site = NULL;
	timer->start_pid = -1;
	memset(timer->start_comm, 0, TASK_COMM_LEN);
c103c1d8:	31 c0                	xor    %eax,%eax
	timer->entry.next = NULL;
	timer->base = __raw_get_cpu_var(tvec_bases);
	timer->slack = -1;
#ifdef CONFIG_TIMER_STATS
	timer->start_site = NULL;
	timer->start_pid = -1;
c103c1da:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
	memset(timer->start_comm, 0, TASK_COMM_LEN);
c103c1e1:	f3 ab                	rep stos %eax,%es:(%edi)
		    const char *name,
		    struct lock_class_key *key)
{
	debug_init(timer);
	__init_timer(timer, name, key);
}
c103c1e3:	5b                   	pop    %ebx
c103c1e4:	5e                   	pop    %esi
c103c1e5:	5f                   	pop    %edi
c103c1e6:	5d                   	pop    %ebp
c103c1e7:	c3                   	ret

c103c1e8 <setup_deferrable_timer_on_stack_key>:
void setup_deferrable_timer_on_stack_key(struct timer_list *timer,
					 const char *name,
					 struct lock_class_key *key,
					 void (*function)(unsigned long),
					 unsigned long data)
{
c103c1e8:	55                   	push   %ebp
c103c1e9:	89 e5                	mov    %esp,%ebp
c103c1eb:	53                   	push   %ebx
c103c1ec:	89 c3                	mov    %eax,%ebx
	timer->function = function;
c103c1ee:	8b 45 08             	mov    0x8(%ebp),%eax
c103c1f1:	89 43 10             	mov    %eax,0x10(%ebx)
	timer->data = data;
c103c1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c103c1f7:	89 43 14             	mov    %eax,0x14(%ebx)
static inline void destroy_timer_on_stack(struct timer_list *timer) { }
static inline void init_timer_on_stack_key(struct timer_list *timer,
					   const char *name,
					   struct lock_class_key *key)
{
	init_timer_key(timer, name, key);
c103c1fa:	89 d8                	mov    %ebx,%eax
c103c1fc:	e8 fc ff ff ff       	call   c103c1fd <setup_deferrable_timer_on_stack_key+0x15>
	return ((struct tvec_base *)((unsigned long)base & ~TBASE_DEFERRABLE_FLAG));
}

static inline void timer_set_deferrable(struct timer_list *timer)
{
	timer->base = TBASE_MAKE_DEFERRED(timer->base);
c103c201:	ff 43 0c             	incl   0xc(%ebx)
{
	timer->function = function;
	timer->data = data;
	init_timer_on_stack_key(timer, name, key);
	timer_set_deferrable(timer);
}
c103c204:	5b                   	pop    %ebx
c103c205:	5d                   	pop    %ebp
c103c206:	c3                   	ret

c103c207 <init_timer_deferrable_key>:
EXPORT_SYMBOL(init_timer_key);

void init_timer_deferrable_key(struct timer_list *timer,
			       const char *name,
			       struct lock_class_key *key)
{
c103c207:	55                   	push   %ebp
c103c208:	89 e5                	mov    %esp,%ebp
c103c20a:	53                   	push   %ebx
c103c20b:	89 c3                	mov    %eax,%ebx
	init_timer_key(timer, name, key);
c103c20d:	e8 fc ff ff ff       	call   c103c20e <init_timer_deferrable_key+0x7>
	return ((struct tvec_base *)((unsigned long)base & ~TBASE_DEFERRABLE_FLAG));
}

static inline void timer_set_deferrable(struct timer_list *timer)
{
	timer->base = TBASE_MAKE_DEFERRED(timer->base);
c103c212:	ff 43 0c             	incl   0xc(%ebx)
			       const char *name,
			       struct lock_class_key *key)
{
	init_timer_key(timer, name, key);
	timer_set_deferrable(timer);
}
c103c215:	5b                   	pop    %ebx
c103c216:	5d                   	pop    %ebp
c103c217:	c3                   	ret

c103c218 <run_timer_softirq>:

/*
 * This function runs timers and the timer-tq in bottom half context.
 */
static void run_timer_softirq(struct softirq_action *h)
{
c103c218:	55                   	push   %ebp
c103c219:	89 e5                	mov    %esp,%ebp
c103c21b:	57                   	push   %edi
c103c21c:	56                   	push   %esi
c103c21d:	53                   	push   %ebx
c103c21e:	83 ec 28             	sub    $0x28,%esp
	struct tvec_base *base = __this_cpu_read(tvec_bases);
c103c221:	64 8b 1d 00 00 00 00 	mov    %fs:0x0,%ebx

	hrtimer_run_pending();
c103c228:	e8 fc ff ff ff       	call   c103c229 <run_timer_softirq+0x11>

	if (time_after_eq(jiffies, base->timer_jiffies))
c103c22d:	a1 00 00 00 00       	mov    0x0,%eax
c103c232:	3b 43 08             	cmp    0x8(%ebx),%eax
c103c235:	0f 88 f0 01 00 00    	js     c103c42b <run_timer_softirq+0x213>
	raw_spin_lock_nest_lock(spinlock_check(lock), nest_lock);	\
} while (0)

static inline void spin_lock_irq(spinlock_t *lock)
{
	raw_spin_lock_irq(&lock->rlock);
c103c23b:	89 d8                	mov    %ebx,%eax
c103c23d:	e8 fc ff ff ff       	call   c103c23e <run_timer_softirq+0x26>

		/*
		 * Cascade timers:
		 */
		if (!index &&
			(!cascade(base, &base->tv2, INDEX(0))) &&
c103c242:	8d 83 10 08 00 00    	lea    0x810(%ebx),%eax
				(!cascade(base, &base->tv3, INDEX(1))) &&
c103c248:	8d 93 10 0a 00 00    	lea    0xa10(%ebx),%edx

		/*
		 * Cascade timers:
		 */
		if (!index &&
			(!cascade(base, &base->tv2, INDEX(0))) &&
c103c24e:	89 45 e0             	mov    %eax,-0x20(%ebp)
				(!cascade(base, &base->tv3, INDEX(1))) &&
					!cascade(base, &base->tv4, INDEX(2)))
c103c251:	8d 8b 10 0c 00 00    	lea    0xc10(%ebx),%ecx
		/*
		 * Cascade timers:
		 */
		if (!index &&
			(!cascade(base, &base->tv2, INDEX(0))) &&
				(!cascade(base, &base->tv3, INDEX(1))) &&
c103c257:	89 55 dc             	mov    %edx,-0x24(%ebp)
					!cascade(base, &base->tv4, INDEX(2)))
			cascade(base, &base->tv5, INDEX(3));
c103c25a:	8d 83 10 0e 00 00    	lea    0xe10(%ebx),%eax
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
	new->next->prev = new;
c103c260:	8d 55 ec             	lea    -0x14(%ebp),%edx
		 * Cascade timers:
		 */
		if (!index &&
			(!cascade(base, &base->tv2, INDEX(0))) &&
				(!cascade(base, &base->tv3, INDEX(1))) &&
					!cascade(base, &base->tv4, INDEX(2)))
c103c263:	89 4d d8             	mov    %ecx,-0x28(%ebp)
			cascade(base, &base->tv5, INDEX(3));
c103c266:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c103c269:	89 55 cc             	mov    %edx,-0x34(%ebp)
c103c26c:	e9 9c 01 00 00       	jmp    c103c40d <run_timer_softirq+0x1f5>
		int index = base->timer_jiffies & TVR_MASK;

		/*
		 * Cascade timers:
		 */
		if (!index &&
c103c271:	89 ce                	mov    %ecx,%esi
c103c273:	81 e6 ff 00 00 00    	and    $0xff,%esi
c103c279:	75 52                	jne    c103c2cd <run_timer_softirq+0xb5>
			(!cascade(base, &base->tv2, INDEX(0))) &&
c103c27b:	8b 55 e0             	mov    -0x20(%ebp),%edx
c103c27e:	c1 e9 08             	shr    $0x8,%ecx
c103c281:	89 d8                	mov    %ebx,%eax
c103c283:	83 e1 3f             	and    $0x3f,%ecx
c103c286:	e8 7e ea ff ff       	call   c103ad09 <cascade>
		int index = base->timer_jiffies & TVR_MASK;

		/*
		 * Cascade timers:
		 */
		if (!index &&
c103c28b:	85 c0                	test   %eax,%eax
c103c28d:	75 3e                	jne    c103c2cd <run_timer_softirq+0xb5>
			(!cascade(base, &base->tv2, INDEX(0))) &&
				(!cascade(base, &base->tv3, INDEX(1))) &&
c103c28f:	8b 4b 08             	mov    0x8(%ebx),%ecx
c103c292:	89 d8                	mov    %ebx,%eax
c103c294:	8b 55 dc             	mov    -0x24(%ebp),%edx
c103c297:	c1 e9 0e             	shr    $0xe,%ecx
c103c29a:	83 e1 3f             	and    $0x3f,%ecx
c103c29d:	e8 67 ea ff ff       	call   c103ad09 <cascade>
		int index = base->timer_jiffies & TVR_MASK;

		/*
		 * Cascade timers:
		 */
		if (!index &&
c103c2a2:	85 c0                	test   %eax,%eax
c103c2a4:	75 27                	jne    c103c2cd <run_timer_softirq+0xb5>
			(!cascade(base, &base->tv2, INDEX(0))) &&
				(!cascade(base, &base->tv3, INDEX(1))) &&
					!cascade(base, &base->tv4, INDEX(2)))
c103c2a6:	8b 4b 08             	mov    0x8(%ebx),%ecx
c103c2a9:	89 d8                	mov    %ebx,%eax
c103c2ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
c103c2ae:	c1 e9 14             	shr    $0x14,%ecx
c103c2b1:	83 e1 3f             	and    $0x3f,%ecx
c103c2b4:	e8 50 ea ff ff       	call   c103ad09 <cascade>
		int index = base->timer_jiffies & TVR_MASK;

		/*
		 * Cascade timers:
		 */
		if (!index &&
c103c2b9:	85 c0                	test   %eax,%eax
c103c2bb:	75 10                	jne    c103c2cd <run_timer_softirq+0xb5>
			(!cascade(base, &base->tv2, INDEX(0))) &&
				(!cascade(base, &base->tv3, INDEX(1))) &&
					!cascade(base, &base->tv4, INDEX(2)))
			cascade(base, &base->tv5, INDEX(3));
c103c2bd:	8b 4b 08             	mov    0x8(%ebx),%ecx
c103c2c0:	89 d8                	mov    %ebx,%eax
c103c2c2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c103c2c5:	c1 e9 1a             	shr    $0x1a,%ecx
c103c2c8:	e8 3c ea ff ff       	call   c103ad09 <cascade>
		++base->timer_jiffies;
c103c2cd:	ff 43 08             	incl   0x8(%ebx)
c103c2d0:	89 df                	mov    %ebx,%edi
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
c103c2d2:	8b 54 f3 10          	mov    0x10(%ebx,%esi,8),%edx
	new->next->prev = new;
c103c2d6:	8d 4d ec             	lea    -0x14(%ebp),%ecx
		list_replace_init(base->tv1.vec + index, &work_list);
c103c2d9:	8d 44 f3 10          	lea    0x10(%ebx,%esi,8),%eax
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
c103c2dd:	89 55 ec             	mov    %edx,-0x14(%ebp)
	new->next->prev = new;
c103c2e0:	89 4a 04             	mov    %ecx,0x4(%edx)
	new->prev = old->prev;
c103c2e3:	8b 54 f3 14          	mov    0x14(%ebx,%esi,8),%edx
c103c2e7:	89 55 f0             	mov    %edx,-0x10(%ebp)
	new->prev->next = new;
c103c2ea:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103c2ec:	89 44 f3 10          	mov    %eax,0x10(%ebx,%esi,8)
	list->prev = list;
c103c2f0:	89 44 f3 14          	mov    %eax,0x14(%ebx,%esi,8)
c103c2f4:	e9 06 01 00 00       	jmp    c103c3ff <run_timer_softirq+0x1e7>
		while (!list_empty(head)) {
			void (*fn)(unsigned long);
			unsigned long data;

			timer = list_first_entry(head, struct timer_list,entry);
			fn = timer->function;
c103c2f9:	8b 43 10             	mov    0x10(%ebx),%eax
c103c2fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			data = timer->data;
c103c2ff:	8b 53 14             	mov    0x14(%ebx),%edx
c103c302:	89 55 d0             	mov    %edx,-0x30(%ebp)

static void timer_stats_account_timer(struct timer_list *timer)
{
	unsigned int flag = 0;

	if (likely(!timer->start_site))
c103c305:	8b 4b 20             	mov    0x20(%ebx),%ecx
c103c308:	85 c9                	test   %ecx,%ecx
c103c30a:	74 1b                	je     c103c327 <run_timer_softirq+0x10f>
		return;
	if (unlikely(tbase_get_deferrable(timer->base)))
		flag |= TIMER_STATS_FLAG_DEFERRABLE;

	timer_stats_update_stats(timer, timer->start_pid, timer->start_site,
c103c30c:	8b 43 0c             	mov    0xc(%ebx),%eax
c103c30f:	8b 53 1c             	mov    0x1c(%ebx),%edx
c103c312:	83 e0 01             	and    $0x1,%eax
c103c315:	50                   	push   %eax
c103c316:	8d 43 24             	lea    0x24(%ebx),%eax
c103c319:	50                   	push   %eax
c103c31a:	89 d8                	mov    %ebx,%eax
c103c31c:	ff 75 e4             	pushl  -0x1c(%ebp)
c103c31f:	e8 fc ff ff ff       	call   c103c320 <run_timer_softirq+0x108>
c103c324:	83 c4 0c             	add    $0xc,%esp
			data = timer->data;

			timer_stats_account_timer(timer);

			base->running_timer = timer;
			detach_timer(timer, 1);
c103c327:	ba 01 00 00 00       	mov    $0x1,%edx
c103c32c:	89 d8                	mov    %ebx,%eax
			fn = timer->function;
			data = timer->data;

			timer_stats_account_timer(timer);

			base->running_timer = timer;
c103c32e:	89 5f 04             	mov    %ebx,0x4(%edi)
			detach_timer(timer, 1);
c103c331:	e8 5a fd ff ff       	call   c103c090 <detach_timer>
	raw_spin_unlock_bh(&lock->rlock);
}

static inline void spin_unlock_irq(spinlock_t *lock)
{
	raw_spin_unlock_irq(&lock->rlock);
c103c336:	89 f8                	mov    %edi,%eax
c103c338:	e8 fc ff ff ff       	call   c103c339 <run_timer_softirq+0x121>
c103c33d:	89 e0                	mov    %esp,%eax
c103c33f:	25 00 e0 ff ff       	and    $0xffffe000,%eax
}

static void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),
			  unsigned long data)
{
	int preempt_count = preempt_count();
c103c344:	8b 48 14             	mov    0x14(%eax),%ecx
 * timer_expire_entry - called immediately before the timer callback
 * @timer:	pointer to struct timer_list
 *
 * Allows to determine the timer latency.
 */
TRACE_EVENT(timer_expire_entry,
c103c347:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
c103c34e:	89 4d e8             	mov    %ecx,-0x18(%ebp)
c103c351:	74 24                	je     c103c377 <run_timer_softirq+0x15f>
c103c353:	89 ca                	mov    %ecx,%edx
c103c355:	42                   	inc    %edx
c103c356:	89 50 14             	mov    %edx,0x14(%eax)
c103c359:	8b 35 10 00 00 00    	mov    0x10,%esi
c103c35f:	85 f6                	test   %esi,%esi
c103c361:	74 0f                	je     c103c372 <run_timer_softirq+0x15a>
c103c363:	8b 46 04             	mov    0x4(%esi),%eax
c103c366:	89 da                	mov    %ebx,%edx
c103c368:	ff 16                	call   *(%esi)
c103c36a:	83 c6 08             	add    $0x8,%esi
c103c36d:	83 3e 00             	cmpl   $0x0,(%esi)
c103c370:	eb ef                	jmp    c103c361 <run_timer_softirq+0x149>
c103c372:	e8 fe fc ff ff       	call   c103c075 <rcu_read_unlock_sched_notrace>
	 * call here and in del_timer_sync().
	 */
	lock_map_acquire(&lockdep_map);

	trace_timer_expire_entry(timer);
	fn(data);
c103c377:	8b 45 d0             	mov    -0x30(%ebp),%eax
c103c37a:	ff 55 e4             	call   *-0x1c(%ebp)
 * determine the runtime of the timer callback function.
 *
 * NOTE: Do NOT derefernce timer in TP_fast_assign. The pointer might
 * be invalid. We solely track the pointer.
 */
DEFINE_EVENT(timer_class, timer_expire_exit,
c103c37d:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
c103c384:	74 28                	je     c103c3ae <run_timer_softirq+0x196>
c103c386:	89 e0                	mov    %esp,%eax
c103c388:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c38d:	ff 40 14             	incl   0x14(%eax)
c103c390:	8b 35 10 00 00 00    	mov    0x10,%esi
c103c396:	85 f6                	test   %esi,%esi
c103c398:	74 0f                	je     c103c3a9 <run_timer_softirq+0x191>
c103c39a:	8b 46 04             	mov    0x4(%esi),%eax
c103c39d:	89 da                	mov    %ebx,%edx
c103c39f:	ff 16                	call   *(%esi)
c103c3a1:	83 c6 08             	add    $0x8,%esi
c103c3a4:	83 3e 00             	cmpl   $0x0,(%esi)
c103c3a7:	eb ef                	jmp    c103c398 <run_timer_softirq+0x180>
c103c3a9:	e8 c7 fc ff ff       	call   c103c075 <rcu_read_unlock_sched_notrace>
	trace_timer_expire_exit(timer);

	lock_map_release(&lockdep_map);

	if (preempt_count != preempt_count()) {
c103c3ae:	89 e0                	mov    %esp,%eax
c103c3b0:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c3b5:	8b 40 14             	mov    0x14(%eax),%eax
c103c3b8:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c103c3bb:	74 3b                	je     c103c3f8 <run_timer_softirq+0x1e0>
		WARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",
c103c3bd:	80 3d 4a 10 00 00 01 	cmpb   $0x1,0x104a
c103c3c4:	74 25                	je     c103c3eb <run_timer_softirq+0x1d3>
c103c3c6:	50                   	push   %eax
c103c3c7:	ff 75 e8             	pushl  -0x18(%ebp)
c103c3ca:	ff 75 e4             	pushl  -0x1c(%ebp)
c103c3cd:	68 6a 02 00 00       	push   $0x26a
c103c3d2:	68 31 04 00 00       	push   $0x431
c103c3d7:	68 00 00 00 00       	push   $0x0
c103c3dc:	e8 fc ff ff ff       	call   c103c3dd <run_timer_softirq+0x1c5>
c103c3e1:	c6 05 4a 10 00 00 01 	movb   $0x1,0x104a
c103c3e8:	83 c4 18             	add    $0x18,%esp
		 * Restore the preempt count. That gives us a decent
		 * chance to survive and extract information. If the
		 * callback kept a lock held, bad luck, but not worse
		 * than the BUG() we had.
		 */
		preempt_count() = preempt_count;
c103c3eb:	8b 55 e8             	mov    -0x18(%ebp),%edx
c103c3ee:	89 e0                	mov    %esp,%eax
c103c3f0:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c3f5:	89 50 14             	mov    %edx,0x14(%eax)
	raw_spin_lock_nest_lock(spinlock_check(lock), nest_lock);	\
} while (0)

static inline void spin_lock_irq(spinlock_t *lock)
{
	raw_spin_lock_irq(&lock->rlock);
c103c3f8:	89 f8                	mov    %edi,%eax
c103c3fa:	e8 fc ff ff ff       	call   c103c3fb <run_timer_softirq+0x1e3>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
c103c3ff:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	struct timer_list *timer;

	spin_lock_irq(&base->lock);
	while (time_after_eq(jiffies, base->timer_jiffies)) {
		struct list_head work_list;
		struct list_head *head = &work_list;
c103c402:	3b 5d cc             	cmp    -0x34(%ebp),%ebx
c103c405:	0f 85 ee fe ff ff    	jne    c103c2f9 <run_timer_softirq+0xe1>
c103c40b:	89 fb                	mov    %edi,%ebx
static inline void __run_timers(struct tvec_base *base)
{
	struct timer_list *timer;

	spin_lock_irq(&base->lock);
	while (time_after_eq(jiffies, base->timer_jiffies)) {
c103c40d:	a1 00 00 00 00       	mov    0x0,%eax
c103c412:	8b 4b 08             	mov    0x8(%ebx),%ecx
c103c415:	39 c8                	cmp    %ecx,%eax
c103c417:	0f 89 54 fe ff ff    	jns    c103c271 <run_timer_softirq+0x59>
			spin_unlock_irq(&base->lock);
			call_timer_fn(timer, fn, data);
			spin_lock_irq(&base->lock);
		}
	}
	base->running_timer = NULL;
c103c41d:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	raw_spin_unlock_bh(&lock->rlock);
}

static inline void spin_unlock_irq(spinlock_t *lock)
{
	raw_spin_unlock_irq(&lock->rlock);
c103c424:	89 d8                	mov    %ebx,%eax
c103c426:	e8 fc ff ff ff       	call   c103c427 <run_timer_softirq+0x20f>

	hrtimer_run_pending();

	if (time_after_eq(jiffies, base->timer_jiffies))
		__run_timers(base);
}
c103c42b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c103c42e:	5b                   	pop    %ebx
c103c42f:	5e                   	pop    %esi
c103c430:	5f                   	pop    %edi
c103c431:	5d                   	pop    %ebp
c103c432:	c3                   	ret

c103c433 <do_sysinfo>:
/**
 * do_sysinfo - fill in sysinfo struct
 * @info: pointer to buffer to fill
 */
int do_sysinfo(struct sysinfo *info)
{
c103c433:	55                   	push   %ebp
	unsigned long mem_total, sav_total;
	unsigned int mem_unit, bitcount;
	struct timespec tp;

	memset(info, 0, sizeof(struct sysinfo));
c103c434:	b9 10 00 00 00       	mov    $0x10,%ecx
/**
 * do_sysinfo - fill in sysinfo struct
 * @info: pointer to buffer to fill
 */
int do_sysinfo(struct sysinfo *info)
{
c103c439:	89 e5                	mov    %esp,%ebp
c103c43b:	57                   	push   %edi
c103c43c:	56                   	push   %esi
c103c43d:	53                   	push   %ebx
c103c43e:	89 c3                	mov    %eax,%ebx
	unsigned long mem_total, sav_total;
	unsigned int mem_unit, bitcount;
	struct timespec tp;

	memset(info, 0, sizeof(struct sysinfo));
c103c440:	89 df                	mov    %ebx,%edi
c103c442:	31 c0                	xor    %eax,%eax
/**
 * do_sysinfo - fill in sysinfo struct
 * @info: pointer to buffer to fill
 */
int do_sysinfo(struct sysinfo *info)
{
c103c444:	83 ec 08             	sub    $0x8,%esp
	unsigned long mem_total, sav_total;
	unsigned int mem_unit, bitcount;
	struct timespec tp;

	memset(info, 0, sizeof(struct sysinfo));
c103c447:	f3 ab                	rep stos %eax,%es:(%edi)

	ktime_get_ts(&tp);
c103c449:	8d 75 ec             	lea    -0x14(%ebp),%esi
c103c44c:	89 f0                	mov    %esi,%eax
c103c44e:	e8 fc ff ff ff       	call   c103c44f <do_sysinfo+0x1c>
	monotonic_to_bootbased(&tp);
c103c453:	89 f0                	mov    %esi,%eax
c103c455:	e8 fc ff ff ff       	call   c103c456 <do_sysinfo+0x23>
	info->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
c103c45a:	31 c0                	xor    %eax,%eax

	get_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);
c103c45c:	b9 05 00 00 00       	mov    $0x5,%ecx

	memset(info, 0, sizeof(struct sysinfo));

	ktime_get_ts(&tp);
	monotonic_to_bootbased(&tp);
	info->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
c103c461:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c103c465:	0f 95 c0             	setne  %al

	get_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);
c103c468:	31 d2                	xor    %edx,%edx

	memset(info, 0, sizeof(struct sysinfo));

	ktime_get_ts(&tp);
	monotonic_to_bootbased(&tp);
	info->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
c103c46a:	03 45 ec             	add    -0x14(%ebp),%eax
c103c46d:	89 03                	mov    %eax,(%ebx)

	get_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);
c103c46f:	8d 43 04             	lea    0x4(%ebx),%eax
c103c472:	e8 fc ff ff ff       	call   c103c473 <do_sysinfo+0x40>

	info->procs = nr_threads;
c103c477:	a1 00 00 00 00       	mov    0x0,%eax
c103c47c:	66 89 43 28          	mov    %ax,0x28(%ebx)

	si_meminfo(info);
c103c480:	89 d8                	mov    %ebx,%eax
c103c482:	e8 fc ff ff ff       	call   c103c483 <do_sysinfo+0x50>
	si_swapinfo(info);
c103c487:	89 d8                	mov    %ebx,%eax
c103c489:	e8 fc ff ff ff       	call   c103c48a <do_sysinfo+0x57>
	 * well, in that case 2.2.x was broken anyways...
	 *
	 *  -Erik Andersen <andersee@debian.org>
	 */

	mem_total = info->totalram + info->totalswap;
c103c48e:	8b 53 20             	mov    0x20(%ebx),%edx
	if (mem_total < info->totalram || mem_total < info->totalswap)
c103c491:	89 d0                	mov    %edx,%eax
c103c493:	03 43 10             	add    0x10(%ebx),%eax
c103c496:	72 3b                	jb     c103c4d3 <do_sysinfo+0xa0>
c103c498:	39 d0                	cmp    %edx,%eax
c103c49a:	72 37                	jb     c103c4d3 <do_sysinfo+0xa0>
		goto out;
	bitcount = 0;
	mem_unit = info->mem_unit;
c103c49c:	8b 53 34             	mov    0x34(%ebx),%edx
c103c49f:	31 c9                	xor    %ecx,%ecx
	while (mem_unit > 1) {
c103c4a1:	eb 0c                	jmp    c103c4af <do_sysinfo+0x7c>
		bitcount++;
		mem_unit >>= 1;
		sav_total = mem_total;
		mem_total <<= 1;
c103c4a3:	8d 34 00             	lea    (%eax,%eax,1),%esi
		if (mem_total < sav_total)
c103c4a6:	39 c6                	cmp    %eax,%esi
c103c4a8:	72 29                	jb     c103c4d3 <do_sysinfo+0xa0>
	if (mem_total < info->totalram || mem_total < info->totalswap)
		goto out;
	bitcount = 0;
	mem_unit = info->mem_unit;
	while (mem_unit > 1) {
		bitcount++;
c103c4aa:	41                   	inc    %ecx
		mem_unit >>= 1;
c103c4ab:	89 f0                	mov    %esi,%eax
c103c4ad:	d1 ea                	shr    %edx
	mem_total = info->totalram + info->totalswap;
	if (mem_total < info->totalram || mem_total < info->totalswap)
		goto out;
	bitcount = 0;
	mem_unit = info->mem_unit;
	while (mem_unit > 1) {
c103c4af:	83 fa 01             	cmp    $0x1,%edx
c103c4b2:	77 ef                	ja     c103c4a3 <do_sysinfo+0x70>
	 * with 2.2.x, and also retains compatibility with earlier 2.4.x
	 * kernels...
	 */

	info->mem_unit = 1;
	info->totalram <<= bitcount;
c103c4b4:	d3 63 10             	shll   %cl,0x10(%ebx)
	info->freeram <<= bitcount;
c103c4b7:	d3 63 14             	shll   %cl,0x14(%ebx)
	info->sharedram <<= bitcount;
c103c4ba:	d3 63 18             	shll   %cl,0x18(%ebx)
	info->bufferram <<= bitcount;
c103c4bd:	d3 63 1c             	shll   %cl,0x1c(%ebx)
	info->totalswap <<= bitcount;
c103c4c0:	d3 63 20             	shll   %cl,0x20(%ebx)
	info->freeswap <<= bitcount;
c103c4c3:	d3 63 24             	shll   %cl,0x24(%ebx)
	info->totalhigh <<= bitcount;
c103c4c6:	d3 63 2c             	shll   %cl,0x2c(%ebx)
	info->freehigh <<= bitcount;
c103c4c9:	d3 63 30             	shll   %cl,0x30(%ebx)
	 * info->mem_unit and set it to 1.  This leaves things compatible
	 * with 2.2.x, and also retains compatibility with earlier 2.4.x
	 * kernels...
	 */

	info->mem_unit = 1;
c103c4cc:	c7 43 34 01 00 00 00 	movl   $0x1,0x34(%ebx)
	info->totalhigh <<= bitcount;
	info->freehigh <<= bitcount;

out:
	return 0;
}
c103c4d3:	5e                   	pop    %esi
c103c4d4:	31 c0                	xor    %eax,%eax
c103c4d6:	5f                   	pop    %edi
c103c4d7:	5b                   	pop    %ebx
c103c4d8:	5e                   	pop    %esi
c103c4d9:	5f                   	pop    %edi
c103c4da:	5d                   	pop    %ebp
c103c4db:	c3                   	ret

c103c4dc <sys_sysinfo>:

SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
{
c103c4dc:	55                   	push   %ebp
c103c4dd:	89 e5                	mov    %esp,%ebp
c103c4df:	53                   	push   %ebx
	struct sysinfo val;

	do_sysinfo(&val);
c103c4e0:	8d 5d bc             	lea    -0x44(%ebp),%ebx
out:
	return 0;
}

SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
{
c103c4e3:	83 ec 40             	sub    $0x40,%esp
	struct sysinfo val;

	do_sysinfo(&val);
c103c4e6:	89 d8                	mov    %ebx,%eax
c103c4e8:	e8 fc ff ff ff       	call   c103c4e9 <sys_sysinfo+0xd>

	if (copy_to_user(info, &val, sizeof(struct sysinfo)))
c103c4ed:	8b 45 08             	mov    0x8(%ebp),%eax
c103c4f0:	89 da                	mov    %ebx,%edx
c103c4f2:	b9 40 00 00 00       	mov    $0x40,%ecx
c103c4f7:	e8 fc ff ff ff       	call   c103c4f8 <sys_sysinfo+0x1c>
c103c4fc:	83 f8 01             	cmp    $0x1,%eax
c103c4ff:	19 c0                	sbb    %eax,%eax
		return -EFAULT;

	return 0;
}
c103c501:	83 c4 40             	add    $0x40,%esp
{
	struct sysinfo val;

	do_sysinfo(&val);

	if (copy_to_user(info, &val, sizeof(struct sysinfo)))
c103c504:	f7 d0                	not    %eax
c103c506:	83 e0 f2             	and    $0xfffffff2,%eax
		return -EFAULT;

	return 0;
}
c103c509:	5b                   	pop    %ebx
c103c50a:	5d                   	pop    %ebp
c103c50b:	c3                   	ret

c103c50c <sys_gettid>:
}
EXPORT_SYMBOL(schedule_timeout_uninterruptible);

/* Thread ID - the internal kernel "pid" */
SYSCALL_DEFINE0(gettid)
{
c103c50c:	55                   	push   %ebp
	return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline pid_t task_pid_vnr(struct task_struct *tsk)
{
	return __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
c103c50d:	31 c9                	xor    %ecx,%ecx
c103c50f:	89 e5                	mov    %esp,%ebp
c103c511:	31 d2                	xor    %edx,%edx
c103c513:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
c103c519:	e8 fc ff ff ff       	call   c103c51a <sys_gettid+0xe>
	return task_pid_vnr(current);
}
c103c51e:	5d                   	pop    %ebp
c103c51f:	c3                   	ret

c103c520 <lock_timer_base>:
 * locked.
 */
static struct tvec_base *lock_timer_base(struct timer_list *timer,
					unsigned long *flags)
	__acquires(timer->base->lock)
{
c103c520:	55                   	push   %ebp
c103c521:	89 e5                	mov    %esp,%ebp
c103c523:	57                   	push   %edi
c103c524:	89 d7                	mov    %edx,%edi
c103c526:	56                   	push   %esi
c103c527:	89 c6                	mov    %eax,%esi
c103c529:	53                   	push   %ebx
c103c52a:	83 ec 04             	sub    $0x4,%esp
	struct tvec_base *base;

	for (;;) {
		struct tvec_base *prelock_base = timer->base;
c103c52d:	8b 4e 0c             	mov    0xc(%esi),%ecx
		base = tbase_get_base(prelock_base);
		if (likely(base != NULL)) {
c103c530:	89 cb                	mov    %ecx,%ebx
c103c532:	83 e3 fe             	and    $0xfffffffe,%ebx
c103c535:	74 25                	je     c103c55c <lock_timer_base+0x3c>
			spin_lock_irqsave(&base->lock, *flags);
c103c537:	89 d8                	mov    %ebx,%eax
c103c539:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c103c53c:	e8 fc ff ff ff       	call   c103c53d <lock_timer_base+0x1d>
			if (likely(prelock_base == timer->base))
c103c541:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	for (;;) {
		struct tvec_base *prelock_base = timer->base;
		base = tbase_get_base(prelock_base);
		if (likely(base != NULL)) {
			spin_lock_irqsave(&base->lock, *flags);
c103c544:	89 07                	mov    %eax,(%edi)
			if (likely(prelock_base == timer->base))
c103c546:	3b 4e 0c             	cmp    0xc(%esi),%ecx
c103c549:	75 08                	jne    c103c553 <lock_timer_base+0x33>
			/* The timer has migrated to another CPU */
			spin_unlock_irqrestore(&base->lock, *flags);
		}
		cpu_relax();
	}
}
c103c54b:	5a                   	pop    %edx
c103c54c:	89 d8                	mov    %ebx,%eax
c103c54e:	5b                   	pop    %ebx
c103c54f:	5e                   	pop    %esi
c103c550:	5f                   	pop    %edi
c103c551:	5d                   	pop    %ebp
c103c552:	c3                   	ret
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
c103c553:	89 c2                	mov    %eax,%edx
c103c555:	89 d8                	mov    %ebx,%eax
c103c557:	e8 fc ff ff ff       	call   c103c558 <lock_timer_base+0x38>
}

/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
static inline void rep_nop(void)
{
	asm volatile("rep; nop" ::: "memory");
c103c55c:	f3 90                	pause
				return base;
			/* The timer has migrated to another CPU */
			spin_unlock_irqrestore(&base->lock, *flags);
		}
		cpu_relax();
	}
c103c55e:	eb cd                	jmp    c103c52d <lock_timer_base+0xd>

c103c560 <try_to_del_timer_sync>:
 *
 * This function tries to deactivate a timer. Upon successful (ret >= 0)
 * exit the timer is not queued and the handler is not running on any CPU.
 */
int try_to_del_timer_sync(struct timer_list *timer)
{
c103c560:	55                   	push   %ebp
c103c561:	89 e5                	mov    %esp,%ebp
c103c563:	57                   	push   %edi
	unsigned long flags;
	int ret = -1;

	base = lock_timer_base(timer, &flags);

	if (base->running_timer == timer)
c103c564:	83 cf ff             	or     $0xffffffff,%edi
 *
 * This function tries to deactivate a timer. Upon successful (ret >= 0)
 * exit the timer is not queued and the handler is not running on any CPU.
 */
int try_to_del_timer_sync(struct timer_list *timer)
{
c103c567:	56                   	push   %esi
c103c568:	53                   	push   %ebx
c103c569:	89 c3                	mov    %eax,%ebx
c103c56b:	83 ec 04             	sub    $0x4,%esp
	struct tvec_base *base;
	unsigned long flags;
	int ret = -1;

	base = lock_timer_base(timer, &flags);
c103c56e:	8d 55 f0             	lea    -0x10(%ebp),%edx
c103c571:	e8 aa ff ff ff       	call   c103c520 <lock_timer_base>

	if (base->running_timer == timer)
c103c576:	39 58 04             	cmp    %ebx,0x4(%eax)
{
	struct tvec_base *base;
	unsigned long flags;
	int ret = -1;

	base = lock_timer_base(timer, &flags);
c103c579:	89 c6                	mov    %eax,%esi

	if (base->running_timer == timer)
c103c57b:	74 39                	je     c103c5b6 <try_to_del_timer_sync+0x56>
		goto out;

	timer_stats_timer_clear_start_info(timer);
	ret = 0;
	if (timer_pending(timer)) {
c103c57d:	31 ff                	xor    %edi,%edi
c103c57f:	83 3b 00             	cmpl   $0x0,(%ebx)
	__timer_stats_timer_set_start_info(timer, __builtin_return_address(0));
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
c103c582:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
c103c589:	74 2b                	je     c103c5b6 <try_to_del_timer_sync+0x56>
		detach_timer(timer, 1);
c103c58b:	89 d8                	mov    %ebx,%eax
c103c58d:	ba 01 00 00 00       	mov    $0x1,%edx
c103c592:	e8 f9 fa ff ff       	call   c103c090 <detach_timer>
		if (timer->expires == base->next_timer &&
c103c597:	8b 43 08             	mov    0x8(%ebx),%eax
c103c59a:	3b 46 0c             	cmp    0xc(%esi),%eax
c103c59d:	75 12                	jne    c103c5b1 <try_to_del_timer_sync+0x51>
		    !tbase_get_deferrable(timer->base))
c103c59f:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103c5a3:	75 0c                	jne    c103c5b1 <try_to_del_timer_sync+0x51>
			base->next_timer = base->timer_jiffies;
c103c5a5:	8b 46 08             	mov    0x8(%esi),%eax
c103c5a8:	66 bf 01 00          	mov    $0x1,%di
c103c5ac:	89 46 0c             	mov    %eax,0xc(%esi)
c103c5af:	eb 05                	jmp    c103c5b6 <try_to_del_timer_sync+0x56>
c103c5b1:	bf 01 00 00 00       	mov    $0x1,%edi
c103c5b6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c103c5b9:	89 f0                	mov    %esi,%eax
c103c5bb:	e8 fc ff ff ff       	call   c103c5bc <try_to_del_timer_sync+0x5c>
	}
out:
	spin_unlock_irqrestore(&base->lock, flags);

	return ret;
}
c103c5c0:	89 f8                	mov    %edi,%eax
c103c5c2:	59                   	pop    %ecx
c103c5c3:	5b                   	pop    %ebx
c103c5c4:	5e                   	pop    %esi
c103c5c5:	5f                   	pop    %edi
c103c5c6:	5d                   	pop    %ebp
c103c5c7:	c3                   	ret

c103c5c8 <del_timer_sync>:
 * it has interrupted the softirq that CPU0 is waiting to finish.
 *
 * The function returns whether it has deactivated a pending timer or not.
 */
int del_timer_sync(struct timer_list *timer)
{
c103c5c8:	55                   	push   %ebp
c103c5c9:	89 e5                	mov    %esp,%ebp
c103c5cb:	53                   	push   %ebx
c103c5cc:	89 c3                	mov    %eax,%ebx
#endif
	/*
	 * don't use it in hardirq context, because it
	 * could lead to deadlock.
	 */
	WARN_ON(in_irq());
c103c5ce:	89 e0                	mov    %esp,%eax
c103c5d0:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c5d5:	f7 40 14 00 00 ff 03 	testl  $0x3ff0000,0x14(%eax)
c103c5dc:	74 0f                	je     c103c5ed <del_timer_sync+0x25>
c103c5de:	ba f4 03 00 00       	mov    $0x3f4,%edx
c103c5e3:	b8 00 00 00 00       	mov    $0x0,%eax
c103c5e8:	e8 fc ff ff ff       	call   c103c5e9 <del_timer_sync+0x21>
	for (;;) {
		int ret = try_to_del_timer_sync(timer);
c103c5ed:	89 d8                	mov    %ebx,%eax
c103c5ef:	e8 fc ff ff ff       	call   c103c5f0 <del_timer_sync+0x28>
		if (ret >= 0)
c103c5f4:	85 c0                	test   %eax,%eax
c103c5f6:	78 03                	js     c103c5fb <del_timer_sync+0x33>
			return ret;
		cpu_relax();
	}
}
c103c5f8:	5b                   	pop    %ebx
c103c5f9:	5d                   	pop    %ebp
c103c5fa:	c3                   	ret
c103c5fb:	f3 90                	pause
	for (;;) {
		int ret = try_to_del_timer_sync(timer);
		if (ret >= 0)
			return ret;
		cpu_relax();
	}
c103c5fd:	eb ee                	jmp    c103c5ed <del_timer_sync+0x25>

c103c5ff <del_timer>:
 * The function returns whether it has deactivated a pending timer or not.
 * (ie. del_timer() of an inactive timer returns 0, del_timer() of an
 * active timer returns 1.)
 */
int del_timer(struct timer_list *timer)
{
c103c5ff:	55                   	push   %ebp
c103c600:	89 e5                	mov    %esp,%ebp
c103c602:	57                   	push   %edi
	struct tvec_base *base;
	unsigned long flags;
	int ret = 0;

	timer_stats_timer_clear_start_info(timer);
	if (timer_pending(timer)) {
c103c603:	31 ff                	xor    %edi,%edi
 * The function returns whether it has deactivated a pending timer or not.
 * (ie. del_timer() of an inactive timer returns 0, del_timer() of an
 * active timer returns 1.)
 */
int del_timer(struct timer_list *timer)
{
c103c605:	56                   	push   %esi
c103c606:	53                   	push   %ebx
c103c607:	89 c3                	mov    %eax,%ebx
c103c609:	83 ec 04             	sub    $0x4,%esp
	struct tvec_base *base;
	unsigned long flags;
	int ret = 0;

	timer_stats_timer_clear_start_info(timer);
	if (timer_pending(timer)) {
c103c60c:	83 38 00             	cmpl   $0x0,(%eax)
c103c60f:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c103c616:	74 44                	je     c103c65c <del_timer+0x5d>
		base = lock_timer_base(timer, &flags);
c103c618:	8d 55 f0             	lea    -0x10(%ebp),%edx
c103c61b:	e8 00 ff ff ff       	call   c103c520 <lock_timer_base>
		if (timer_pending(timer)) {
c103c620:	83 3b 00             	cmpl   $0x0,(%ebx)
	unsigned long flags;
	int ret = 0;

	timer_stats_timer_clear_start_info(timer);
	if (timer_pending(timer)) {
		base = lock_timer_base(timer, &flags);
c103c623:	89 c6                	mov    %eax,%esi
		if (timer_pending(timer)) {
c103c625:	74 2b                	je     c103c652 <del_timer+0x53>
			detach_timer(timer, 1);
c103c627:	89 d8                	mov    %ebx,%eax
c103c629:	ba 01 00 00 00       	mov    $0x1,%edx
c103c62e:	e8 5d fa ff ff       	call   c103c090 <detach_timer>
			if (timer->expires == base->next_timer &&
c103c633:	8b 43 08             	mov    0x8(%ebx),%eax
c103c636:	3b 46 0c             	cmp    0xc(%esi),%eax
c103c639:	75 12                	jne    c103c64d <del_timer+0x4e>
			    !tbase_get_deferrable(timer->base))
c103c63b:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103c63f:	75 0c                	jne    c103c64d <del_timer+0x4e>
				base->next_timer = base->timer_jiffies;
c103c641:	8b 46 08             	mov    0x8(%esi),%eax
c103c644:	66 bf 01 00          	mov    $0x1,%di
c103c648:	89 46 0c             	mov    %eax,0xc(%esi)
c103c64b:	eb 05                	jmp    c103c652 <del_timer+0x53>
c103c64d:	bf 01 00 00 00       	mov    $0x1,%edi
c103c652:	8b 55 f0             	mov    -0x10(%ebp),%edx
c103c655:	89 f0                	mov    %esi,%eax
c103c657:	e8 fc ff ff ff       	call   c103c658 <del_timer+0x59>
		}
		spin_unlock_irqrestore(&base->lock, flags);
	}

	return ret;
}
c103c65c:	5b                   	pop    %ebx
c103c65d:	89 f8                	mov    %edi,%eax
c103c65f:	5b                   	pop    %ebx
c103c660:	5e                   	pop    %esi
c103c661:	5f                   	pop    %edi
c103c662:	5d                   	pop    %ebp
c103c663:	c3                   	ret

c103c664 <process_timeout>:
}

#endif

static void process_timeout(unsigned long __data)
{
c103c664:	55                   	push   %ebp
c103c665:	89 e5                	mov    %esp,%ebp
	wake_up_process((struct task_struct *)__data);
c103c667:	e8 fc ff ff ff       	call   c103c668 <process_timeout+0x4>
}
c103c66c:	5d                   	pop    %ebp
c103c66d:	c3                   	ret

c103c66e <sys_getpid>:
 * which case the tgid is the same in all threads of the same group.
 *
 * This is SMP safe as current->tgid does not change.
 */
SYSCALL_DEFINE0(getpid)
{
c103c66e:	55                   	push   %ebp
c103c66f:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax

pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);

static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
	return pid_vnr(task_tgid(tsk));
c103c675:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
c103c67b:	89 e5                	mov    %esp,%ebp
c103c67d:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
c103c683:	e8 fc ff ff ff       	call   c103c684 <sys_getpid+0x16>
	return task_tgid_vnr(current);
}
c103c688:	5d                   	pop    %ebp
c103c689:	c3                   	ret

c103c68a <sys_getppid>:
 * change from under us. However, we can use a stale
 * value of ->real_parent under rcu_read_lock(), see
 * release_task()->call_rcu(delayed_put_task_struct).
 */
SYSCALL_DEFINE0(getppid)
{
c103c68a:	55                   	push   %ebp
c103c68b:	89 e5                	mov    %esp,%ebp
c103c68d:	83 ec 04             	sub    $0x4,%esp
 * block, but only when acquiring spinlocks that are subject to priority
 * inheritance.
 */
static inline void rcu_read_lock(void)
{
	__rcu_read_lock();
c103c690:	e8 fc ff ff ff       	call   c103c691 <sys_getppid+0x7>
c103c695:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
c103c69b:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
c103c6a1:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
c103c6a7:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
c103c6ad:	e8 fc ff ff ff       	call   c103c6ae <sys_getppid+0x24>
 */
static inline void rcu_read_unlock(void)
{
	rcu_read_release();
	__release(RCU);
	__rcu_read_unlock();
c103c6b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c103c6b5:	e8 fc ff ff ff       	call   c103c6b6 <sys_getppid+0x2c>
	rcu_read_lock();
	pid = task_tgid_vnr(current->real_parent);
	rcu_read_unlock();

	return pid;
}
c103c6ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c103c6bd:	c9                   	leave
c103c6be:	c3                   	ret

c103c6bf <sys_alarm>:
/*
 * For backwards compatibility?  This can be done in libc so Alpha
 * and all newer ports shouldn't need it.
 */
SYSCALL_DEFINE1(alarm, unsigned int, seconds)
{
c103c6bf:	55                   	push   %ebp
c103c6c0:	89 e5                	mov    %esp,%ebp
	return alarm_setitimer(seconds);
c103c6c2:	8b 45 08             	mov    0x8(%ebp),%eax
c103c6c5:	e8 fc ff ff ff       	call   c103c6c6 <sys_alarm+0x7>
}
c103c6ca:	5d                   	pop    %ebp
c103c6cb:	c3                   	ret

c103c6cc <run_local_timers>:

/*
 * Called by the local, per-CPU timer interrupt on SMP.
 */
void run_local_timers(void)
{
c103c6cc:	55                   	push   %ebp
c103c6cd:	89 e5                	mov    %esp,%ebp
	hrtimer_run_queues();
c103c6cf:	e8 fc ff ff ff       	call   c103c6d0 <run_local_timers+0x4>
	raise_softirq(TIMER_SOFTIRQ);
c103c6d4:	b8 01 00 00 00       	mov    $0x1,%eax
c103c6d9:	e8 fc ff ff ff       	call   c103c6da <run_local_timers+0xe>
}
c103c6de:	5d                   	pop    %ebp
c103c6df:	c3                   	ret

c103c6e0 <update_process_times>:
/*
 * Called from the timer interrupt handler to charge one tick to the current
 * process.  user_tick is 1 if the tick is user time, 0 for system.
 */
void update_process_times(int user_tick)
{
c103c6e0:	55                   	push   %ebp
c103c6e1:	89 e5                	mov    %esp,%ebp
c103c6e3:	57                   	push   %edi
c103c6e4:	56                   	push   %esi
c103c6e5:	53                   	push   %ebx
c103c6e6:	89 c3                	mov    %eax,%ebx
	struct task_struct *p = current;
	int cpu = smp_processor_id();
c103c6e8:	e8 fc ff ff ff       	call   c103c6e9 <update_process_times+0x9>

	/* Note: this timer irq context must be accounted for as well. */
	account_process_tick(p, user_tick);
c103c6ed:	89 da                	mov    %ebx,%edx
c103c6ef:	64 8b 3d 00 00 00 00 	mov    %fs:0x0,%edi
 * process.  user_tick is 1 if the tick is user time, 0 for system.
 */
void update_process_times(int user_tick)
{
	struct task_struct *p = current;
	int cpu = smp_processor_id();
c103c6f6:	89 c6                	mov    %eax,%esi

	/* Note: this timer irq context must be accounted for as well. */
	account_process_tick(p, user_tick);
c103c6f8:	89 f8                	mov    %edi,%eax
c103c6fa:	e8 fc ff ff ff       	call   c103c6fb <update_process_times+0x1b>
	run_local_timers();
c103c6ff:	e8 fc ff ff ff       	call   c103c700 <update_process_times+0x20>
	rcu_check_callbacks(cpu, user_tick);
c103c704:	89 f0                	mov    %esi,%eax
c103c706:	89 da                	mov    %ebx,%edx
c103c708:	e8 fc ff ff ff       	call   c103c709 <update_process_times+0x29>
	printk_tick();
c103c70d:	e8 fc ff ff ff       	call   c103c70e <update_process_times+0x2e>
#ifdef CONFIG_IRQ_WORK
	if (in_irq())
c103c712:	89 e0                	mov    %esp,%eax
c103c714:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103c719:	f7 40 14 00 00 ff 03 	testl  $0x3ff0000,0x14(%eax)
c103c720:	74 05                	je     c103c727 <update_process_times+0x47>
		irq_work_run();
c103c722:	e8 fc ff ff ff       	call   c103c723 <update_process_times+0x43>
#endif
	scheduler_tick();
c103c727:	e8 fc ff ff ff       	call   c103c728 <update_process_times+0x48>
	run_posix_cpu_timers(p);
c103c72c:	89 f8                	mov    %edi,%eax
c103c72e:	e8 fc ff ff ff       	call   c103c72f <update_process_times+0x4f>
}
c103c733:	5b                   	pop    %ebx
c103c734:	5e                   	pop    %esi
c103c735:	5f                   	pop    %edi
c103c736:	5d                   	pop    %ebp
c103c737:	c3                   	ret

c103c738 <get_next_timer_interrupt>:
/**
 * get_next_timer_interrupt - return the jiffy of the next pending timer
 * @now: current time (in jiffies)
 */
unsigned long get_next_timer_interrupt(unsigned long now)
{
c103c738:	55                   	push   %ebp
c103c739:	89 e5                	mov    %esp,%ebp
c103c73b:	57                   	push   %edi
c103c73c:	56                   	push   %esi
c103c73d:	53                   	push   %ebx
c103c73e:	83 ec 2c             	sub    $0x2c,%esp
c103c741:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct tvec_base *base = __this_cpu_read(tvec_bases);
c103c744:	64 8b 1d 00 00 00 00 	mov    %fs:0x0,%ebx

	/*
	 * Pretend that there is no timer pending if the cpu is offline.
	 * Possible pending timers will be migrated later to an active cpu.
	 */
	if (cpu_is_offline(smp_processor_id()))
c103c74b:	e8 fc ff ff ff       	call   c103c74c <get_next_timer_interrupt+0x14>

static inline int variable_test_bit(int nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
c103c750:	8b 15 00 00 00 00    	mov    0x0,%edx
c103c756:	0f a3 02             	bt     %eax,(%edx)
c103c759:	19 c0                	sbb    %eax,%eax
c103c75b:	85 c0                	test   %eax,%eax
c103c75d:	75 0c                	jne    c103c76b <get_next_timer_interrupt+0x33>
		return now + NEXT_TIMER_MAX_DELTA;
c103c75f:	81 45 e0 ff ff ff 3f 	addl   $0x3fffffff,-0x20(%ebp)
c103c766:	e9 91 01 00 00       	jmp    c103c8fc <get_next_timer_interrupt+0x1c4>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
c103c76b:	89 d8                	mov    %ebx,%eax
c103c76d:	e8 fc ff ff ff       	call   c103c76e <get_next_timer_interrupt+0x36>
	spin_lock(&base->lock);
	if (time_before_eq(base->next_timer, base->timer_jiffies))
c103c772:	8b 43 08             	mov    0x8(%ebx),%eax
c103c775:	3b 43 0c             	cmp    0xc(%ebx),%eax
c103c778:	0f 88 12 01 00 00    	js     c103c890 <get_next_timer_interrupt+0x158>
	int index, slot, array, found = 0;
	struct timer_list *nte;
	struct tvec *varray[4];

	/* Look for timer events in tv1. */
	index = slot = timer_jiffies & TVR_MASK;
c103c77e:	0f b6 c8             	movzbl %al,%ecx
c103c781:	89 ce                	mov    %ecx,%esi
	do {
		list_for_each_entry(nte, base->tv1.vec + slot, entry) {
c103c783:	8d 7c f3 10          	lea    0x10(%ebx,%esi,8),%edi
c103c787:	8b 54 f3 10          	mov    0x10(%ebx,%esi,8),%edx
c103c78b:	89 7d dc             	mov    %edi,-0x24(%ebp)
c103c78e:	eb 20                	jmp    c103c7b0 <get_next_timer_interrupt+0x78>
			if (tbase_get_deferrable(nte->base))
c103c790:	f6 42 0c 01          	testb  $0x1,0xc(%edx)
c103c794:	74 04                	je     c103c79a <get_next_timer_interrupt+0x62>
	struct tvec *varray[4];

	/* Look for timer events in tv1. */
	index = slot = timer_jiffies & TVR_MASK;
	do {
		list_for_each_entry(nte, base->tv1.vec + slot, entry) {
c103c796:	89 fa                	mov    %edi,%edx
c103c798:	eb 16                	jmp    c103c7b0 <get_next_timer_interrupt+0x78>
				continue;

			found = 1;
			expires = nte->expires;
			/* Look at the cascade bucket(s)? */
			if (!index || slot < index)
c103c79a:	39 ce                	cmp    %ecx,%esi
		list_for_each_entry(nte, base->tv1.vec + slot, entry) {
			if (tbase_get_deferrable(nte->base))
				continue;

			found = 1;
			expires = nte->expires;
c103c79c:	8b 52 08             	mov    0x8(%edx),%edx
			/* Look at the cascade bucket(s)? */
			if (!index || slot < index)
c103c79f:	7c 08                	jl     c103c7a9 <get_next_timer_interrupt+0x71>
c103c7a1:	85 c9                	test   %ecx,%ecx
c103c7a3:	0f 85 e4 00 00 00    	jne    c103c88d <get_next_timer_interrupt+0x155>
c103c7a9:	bf 01 00 00 00       	mov    $0x1,%edi
c103c7ae:	eb 1e                	jmp    c103c7ce <get_next_timer_interrupt+0x96>
	struct tvec *varray[4];

	/* Look for timer events in tv1. */
	index = slot = timer_jiffies & TVR_MASK;
	do {
		list_for_each_entry(nte, base->tv1.vec + slot, entry) {
c103c7b0:	8b 3a                	mov    (%edx),%edi
c103c7b2:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c103c7b6:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c103c7b9:	75 d5                	jne    c103c790 <get_next_timer_interrupt+0x58>
			/* Look at the cascade bucket(s)? */
			if (!index || slot < index)
				goto cascade;
			return expires;
		}
		slot = (slot + 1) & TVR_MASK;
c103c7bb:	46                   	inc    %esi
c103c7bc:	81 e6 ff 00 00 00    	and    $0xff,%esi
	} while (slot != index);
c103c7c2:	39 ce                	cmp    %ecx,%esi
c103c7c4:	75 bd                	jne    c103c783 <get_next_timer_interrupt+0x4b>
 * This function needs to be called with interrupts disabled.
 */
static unsigned long __next_timer_interrupt(struct tvec_base *base)
{
	unsigned long timer_jiffies = base->timer_jiffies;
	unsigned long expires = timer_jiffies + NEXT_TIMER_MAX_DELTA;
c103c7c6:	8d 90 ff ff ff 3f    	lea    0x3fffffff(%eax),%edx
c103c7cc:	31 ff                	xor    %edi,%edi
		slot = (slot + 1) & TVR_MASK;
	} while (slot != index);

cascade:
	/* Calculate the next cascade event */
	if (index)
c103c7ce:	85 c9                	test   %ecx,%ecx
c103c7d0:	74 07                	je     c103c7d9 <get_next_timer_interrupt+0xa1>
		timer_jiffies += TVR_SIZE - index;
c103c7d2:	05 00 01 00 00       	add    $0x100,%eax
c103c7d7:	29 c8                	sub    %ecx,%eax
	timer_jiffies >>= TVR_BITS;
c103c7d9:	c1 e8 08             	shr    $0x8,%eax
c103c7dc:	89 45 dc             	mov    %eax,-0x24(%ebp)

	/* Check tv2-tv5. */
	varray[0] = &base->tv2;
c103c7df:	8d 83 10 08 00 00    	lea    0x810(%ebx),%eax
c103c7e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	varray[1] = &base->tv3;
c103c7e8:	8d 83 10 0a 00 00    	lea    0xa10(%ebx),%eax
c103c7ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
	varray[2] = &base->tv4;
c103c7f1:	8d 83 10 0c 00 00    	lea    0xc10(%ebx),%eax
c103c7f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	varray[3] = &base->tv5;
c103c7fa:	8d 83 10 0e 00 00    	lea    0xe10(%ebx),%eax
c103c800:	89 45 f0             	mov    %eax,-0x10(%ebp)
c103c803:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	for (array = 0; array < 4; array++) {
		struct tvec *varp = varray[array];
c103c80a:	89 5d cc             	mov    %ebx,-0x34(%ebp)
c103c80d:	8b 45 d8             	mov    -0x28(%ebp),%eax

		index = slot = timer_jiffies & TVN_MASK;
c103c810:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	varray[1] = &base->tv3;
	varray[2] = &base->tv4;
	varray[3] = &base->tv5;

	for (array = 0; array < 4; array++) {
		struct tvec *varp = varray[array];
c103c813:	8b 44 85 e4          	mov    -0x1c(%ebp,%eax,4),%eax

		index = slot = timer_jiffies & TVN_MASK;
c103c817:	83 e1 3f             	and    $0x3f,%ecx
	varray[1] = &base->tv3;
	varray[2] = &base->tv4;
	varray[3] = &base->tv5;

	for (array = 0; array < 4; array++) {
		struct tvec *varp = varray[array];
c103c81a:	89 45 d0             	mov    %eax,-0x30(%ebp)

		index = slot = timer_jiffies & TVN_MASK;
c103c81d:	89 c8                	mov    %ecx,%eax
		do {
			list_for_each_entry(nte, varp->vec + slot, entry) {
c103c81f:	8b 75 d0             	mov    -0x30(%ebp),%esi
c103c822:	8b 1c c6             	mov    (%esi,%eax,8),%ebx
c103c825:	8d 34 c6             	lea    (%esi,%eax,8),%esi
c103c828:	89 75 c8             	mov    %esi,-0x38(%ebp)
c103c82b:	eb 1a                	jmp    c103c847 <get_next_timer_interrupt+0x10f>
				if (tbase_get_deferrable(nte->base))
c103c82d:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103c831:	89 d6                	mov    %edx,%esi
c103c833:	75 0d                	jne    c103c842 <get_next_timer_interrupt+0x10a>
					continue;

				found = 1;
				if (time_before(nte->expires, expires))
c103c835:	8b 73 08             	mov    0x8(%ebx),%esi
c103c838:	bf 01 00 00 00       	mov    $0x1,%edi
c103c83d:	39 d6                	cmp    %edx,%esi
c103c83f:	0f 49 f2             	cmovns %edx,%esi
	for (array = 0; array < 4; array++) {
		struct tvec *varp = varray[array];

		index = slot = timer_jiffies & TVN_MASK;
		do {
			list_for_each_entry(nte, varp->vec + slot, entry) {
c103c842:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
c103c845:	89 f2                	mov    %esi,%edx
c103c847:	8b 33                	mov    (%ebx),%esi
c103c849:	89 75 d4             	mov    %esi,-0x2c(%ebp)
c103c84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c103c850:	3b 5d c8             	cmp    -0x38(%ebp),%ebx
c103c853:	75 d8                	jne    c103c82d <get_next_timer_interrupt+0xf5>
			}
			/*
			 * Do we still search for the first timer or are
			 * we looking up the cascade buckets ?
			 */
			if (found) {
c103c855:	85 ff                	test   %edi,%edi
c103c857:	74 0f                	je     c103c868 <get_next_timer_interrupt+0x130>
				/* Look at the cascade bucket(s)? */
				if (!index || slot < index)
c103c859:	39 c8                	cmp    %ecx,%eax
c103c85b:	7c 04                	jl     c103c861 <get_next_timer_interrupt+0x129>
c103c85d:	85 c9                	test   %ecx,%ecx
c103c85f:	75 29                	jne    c103c88a <get_next_timer_interrupt+0x152>
c103c861:	bf 01 00 00 00       	mov    $0x1,%edi
c103c866:	eb 08                	jmp    c103c870 <get_next_timer_interrupt+0x138>
					break;
				return expires;
			}
			slot = (slot + 1) & TVN_MASK;
c103c868:	40                   	inc    %eax
c103c869:	83 e0 3f             	and    $0x3f,%eax
		} while (slot != index);
c103c86c:	39 c8                	cmp    %ecx,%eax
c103c86e:	75 af                	jne    c103c81f <get_next_timer_interrupt+0xe7>

		if (index)
c103c870:	85 c9                	test   %ecx,%ecx
c103c872:	74 07                	je     c103c87b <get_next_timer_interrupt+0x143>
			timer_jiffies += TVN_SIZE - index;
c103c874:	83 45 dc 40          	addl   $0x40,-0x24(%ebp)
c103c878:	29 4d dc             	sub    %ecx,-0x24(%ebp)
	varray[0] = &base->tv2;
	varray[1] = &base->tv3;
	varray[2] = &base->tv4;
	varray[3] = &base->tv5;

	for (array = 0; array < 4; array++) {
c103c87b:	ff 45 d8             	incl   -0x28(%ebp)
c103c87e:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
c103c882:	74 06                	je     c103c88a <get_next_timer_interrupt+0x152>
			slot = (slot + 1) & TVN_MASK;
		} while (slot != index);

		if (index)
			timer_jiffies += TVN_SIZE - index;
		timer_jiffies >>= TVN_BITS;
c103c884:	c1 6d dc 06          	shrl   $0x6,-0x24(%ebp)
c103c888:	eb 83                	jmp    c103c80d <get_next_timer_interrupt+0xd5>
c103c88a:	8b 5d cc             	mov    -0x34(%ebp),%ebx
	 */
	if (cpu_is_offline(smp_processor_id()))
		return now + NEXT_TIMER_MAX_DELTA;
	spin_lock(&base->lock);
	if (time_before_eq(base->next_timer, base->timer_jiffies))
		base->next_timer = __next_timer_interrupt(base);
c103c88d:	89 53 0c             	mov    %edx,0xc(%ebx)
	expires = base->next_timer;
c103c890:	8b 73 0c             	mov    0xc(%ebx),%esi
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
c103c893:	89 d8                	mov    %ebx,%eax
c103c895:	e8 fc ff ff ff       	call   c103c896 <get_next_timer_interrupt+0x15e>
	spin_unlock(&base->lock);

	if (time_before_eq(expires, now))
c103c89a:	39 75 e0             	cmp    %esi,-0x20(%ebp)
c103c89d:	79 5d                	jns    c103c8fc <get_next_timer_interrupt+0x1c4>
 * event:
 */
static unsigned long cmp_next_hrtimer_event(unsigned long now,
					    unsigned long expires)
{
	ktime_t hr_delta = hrtimer_get_next_event();
c103c89f:	e8 fc ff ff ff       	call   c103c8a0 <get_next_timer_interrupt+0x168>
	struct timespec tsdelta;
	unsigned long delta;

	if (hr_delta.tv64 == KTIME_MAX)
c103c8a4:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
c103c8aa:	75 07                	jne    c103c8b3 <get_next_timer_interrupt+0x17b>
c103c8ac:	83 f8 ff             	cmp    $0xffffffff,%eax
c103c8af:	75 13                	jne    c103c8c4 <get_next_timer_interrupt+0x18c>
c103c8b1:	eb 46                	jmp    c103c8f9 <get_next_timer_interrupt+0x1c1>
		return expires;

	/*
	 * Expired timer available, let it expire in the next tick
	 */
	if (hr_delta.tv64 <= 0)
c103c8b3:	83 fa 00             	cmp    $0x0,%edx
c103c8b6:	7f 0c                	jg     c103c8c4 <get_next_timer_interrupt+0x18c>
c103c8b8:	7c 05                	jl     c103c8bf <get_next_timer_interrupt+0x187>
c103c8ba:	83 f8 00             	cmp    $0x0,%eax
c103c8bd:	77 05                	ja     c103c8c4 <get_next_timer_interrupt+0x18c>
		return now + 1;
c103c8bf:	ff 45 e0             	incl   -0x20(%ebp)
c103c8c2:	eb 38                	jmp    c103c8fc <get_next_timer_interrupt+0x1c4>

	tsdelta = ktime_to_timespec(hr_delta);
c103c8c4:	e8 fc ff ff ff       	call   c103c8c5 <get_next_timer_interrupt+0x18d>
c103c8c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	delta = timespec_to_jiffies(&tsdelta);
c103c8cc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	 * Expired timer available, let it expire in the next tick
	 */
	if (hr_delta.tv64 <= 0)
		return now + 1;

	tsdelta = ktime_to_timespec(hr_delta);
c103c8cf:	89 55 e8             	mov    %edx,-0x18(%ebp)
	delta = timespec_to_jiffies(&tsdelta);
c103c8d2:	e8 fc ff ff ff       	call   c103c8d3 <get_next_timer_interrupt+0x19b>

	/*
	 * Limit the delta to the max value, which is checked in
	 * tick_nohz_stop_sched_tick():
	 */
	if (delta > NEXT_TIMER_MAX_DELTA)
c103c8d7:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
c103c8dc:	76 07                	jbe    c103c8e5 <get_next_timer_interrupt+0x1ad>
c103c8de:	b8 ff ff ff 3f       	mov    $0x3fffffff,%eax
c103c8e3:	eb 0a                	jmp    c103c8ef <get_next_timer_interrupt+0x1b7>
	 * Take rounding errors in to account and make sure, that it
	 * expires in the next tick. Otherwise we go into an endless
	 * ping pong due to tick_nohz_stop_sched_tick() retriggering
	 * the timer softirq
	 */
	if (delta < 1)
c103c8e5:	85 c0                	test   %eax,%eax
c103c8e7:	ba 01 00 00 00       	mov    $0x1,%edx
c103c8ec:	0f 44 c2             	cmove  %edx,%eax
		delta = 1;
	now += delta;
c103c8ef:	03 45 e0             	add    -0x20(%ebp),%eax
	if (time_before(now, expires))
c103c8f2:	39 f0                	cmp    %esi,%eax
c103c8f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
c103c8f7:	78 03                	js     c103c8fc <get_next_timer_interrupt+0x1c4>
c103c8f9:	89 75 e0             	mov    %esi,-0x20(%ebp)

	if (time_before_eq(expires, now))
		return now;

	return cmp_next_hrtimer_event(now, expires);
}
c103c8fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c103c8ff:	83 c4 2c             	add    $0x2c,%esp
c103c902:	5b                   	pop    %ebx
c103c903:	5e                   	pop    %esi
c103c904:	5f                   	pop    %edi
c103c905:	5d                   	pop    %ebp
c103c906:	c3                   	ret

c103c907 <__timer_stats_timer_set_start_info>:
	list_add_tail(&timer->entry, vec);
}

#ifdef CONFIG_TIMER_STATS
void __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)
{
c103c907:	55                   	push   %ebp
	if (timer->start_site)
c103c908:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
	list_add_tail(&timer->entry, vec);
}

#ifdef CONFIG_TIMER_STATS
void __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)
{
c103c90c:	89 e5                	mov    %esp,%ebp
c103c90e:	57                   	push   %edi
c103c90f:	56                   	push   %esi
c103c910:	53                   	push   %ebx
	if (timer->start_site)
c103c911:	75 25                	jne    c103c938 <__timer_stats_timer_set_start_info+0x31>
		return;

	timer->start_site = addr;
	memcpy(timer->start_comm, current->comm, TASK_COMM_LEN);
c103c913:	8d 58 24             	lea    0x24(%eax),%ebx
c103c916:	b9 04 00 00 00       	mov    $0x4,%ecx
void __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)
{
	if (timer->start_site)
		return;

	timer->start_site = addr;
c103c91b:	89 50 20             	mov    %edx,0x20(%eax)
	memcpy(timer->start_comm, current->comm, TASK_COMM_LEN);
c103c91e:	89 df                	mov    %ebx,%edi
c103c920:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
c103c927:	8d b2 dc 02 00 00    	lea    0x2dc(%edx),%esi
c103c92d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	timer->start_pid = current->pid;
c103c92f:	8b 92 00 02 00 00    	mov    0x200(%edx),%edx
c103c935:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c103c938:	5b                   	pop    %ebx
c103c939:	5e                   	pop    %esi
c103c93a:	5f                   	pop    %edi
c103c93b:	5d                   	pop    %ebp
c103c93c:	c3                   	ret

c103c93d <timer_stats_timer_set_start_info>:
extern void __timer_stats_timer_set_start_info(struct timer_list *timer,
					       void *addr);

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
	if (likely(!timer_stats_active))
c103c93d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0

extern void __timer_stats_timer_set_start_info(struct timer_list *timer,
					       void *addr);

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
c103c944:	55                   	push   %ebp
c103c945:	89 e5                	mov    %esp,%ebp
	if (likely(!timer_stats_active))
c103c947:	74 08                	je     c103c951 <timer_stats_timer_set_start_info+0x14>
		return;
	__timer_stats_timer_set_start_info(timer, __builtin_return_address(0));
c103c949:	8b 55 04             	mov    0x4(%ebp),%edx
c103c94c:	e8 fc ff ff ff       	call   c103c94d <timer_stats_timer_set_start_info+0x10>
}
c103c951:	5d                   	pop    %ebp
c103c952:	c3                   	ret

c103c953 <__mod_timer>:
}

static inline int
__mod_timer(struct timer_list *timer, unsigned long expires,
						bool pending_only, int pinned)
{
c103c953:	55                   	push   %ebp
c103c954:	89 e5                	mov    %esp,%ebp
c103c956:	57                   	push   %edi
c103c957:	89 d7                	mov    %edx,%edi
c103c959:	56                   	push   %esi
c103c95a:	53                   	push   %ebx
c103c95b:	89 c3                	mov    %eax,%ebx
c103c95d:	83 ec 10             	sub    $0x10,%esp
c103c960:	88 4d ec             	mov    %cl,-0x14(%ebp)
	struct tvec_base *base, *new_base;
	unsigned long flags;
	int ret = 0 , cpu;

	timer_stats_timer_set_start_info(timer);
c103c963:	e8 d5 ff ff ff       	call   c103c93d <timer_stats_timer_set_start_info>
	BUG_ON(!timer->function);
c103c968:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
c103c96c:	75 04                	jne    c103c972 <__mod_timer+0x1f>
c103c96e:	0f 0b                	ud2a
c103c970:	eb fe                	jmp    c103c970 <__mod_timer+0x1d>

	base = lock_timer_base(timer, &flags);
c103c972:	8d 55 f0             	lea    -0x10(%ebp),%edx
c103c975:	89 d8                	mov    %ebx,%eax
c103c977:	e8 a4 fb ff ff       	call   c103c520 <lock_timer_base>

	if (timer_pending(timer)) {
c103c97c:	83 3b 00             	cmpl   $0x0,(%ebx)
	int ret = 0 , cpu;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(!timer->function);

	base = lock_timer_base(timer, &flags);
c103c97f:	89 c6                	mov    %eax,%esi

	if (timer_pending(timer)) {
c103c981:	74 1f                	je     c103c9a2 <__mod_timer+0x4f>
		detach_timer(timer, 0);
c103c983:	31 d2                	xor    %edx,%edx
c103c985:	89 d8                	mov    %ebx,%eax
c103c987:	e8 04 f7 ff ff       	call   c103c090 <detach_timer>
		if (timer->expires == base->next_timer &&
c103c98c:	8b 43 08             	mov    0x8(%ebx),%eax
c103c98f:	3b 46 0c             	cmp    0xc(%esi),%eax
c103c992:	75 20                	jne    c103c9b4 <__mod_timer+0x61>
		    !tbase_get_deferrable(timer->base))
c103c994:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103c998:	75 1a                	jne    c103c9b4 <__mod_timer+0x61>
			base->next_timer = base->timer_jiffies;
c103c99a:	8b 46 08             	mov    0x8(%esi),%eax
c103c99d:	89 46 0c             	mov    %eax,0xc(%esi)
c103c9a0:	eb 12                	jmp    c103c9b4 <__mod_timer+0x61>
		ret = 1;
	} else {
		if (pending_only)
c103c9a2:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c103c9a6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c103c9ad:	74 0c                	je     c103c9bb <__mod_timer+0x68>
c103c9af:	e9 8a 00 00 00       	jmp    c103ca3e <__mod_timer+0xeb>
c103c9b4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
			goto out_unlock;
	}

	debug_activate(timer, expires);
c103c9bb:	89 fa                	mov    %edi,%edx
c103c9bd:	89 d8                	mov    %ebx,%eax
c103c9bf:	e8 6a f7 ff ff       	call   c103c12e <debug_activate>

	cpu = smp_processor_id();
c103c9c4:	e8 fc ff ff ff       	call   c103c9c5 <__mod_timer+0x72>

#if defined(CONFIG_NO_HZ) && defined(CONFIG_SMP)
	if (!pinned && get_sysctl_timer_migration() && idle_cpu(cpu))
c103c9c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
			goto out_unlock;
	}

	debug_activate(timer, expires);

	cpu = smp_processor_id();
c103c9cd:	89 c2                	mov    %eax,%edx

#if defined(CONFIG_NO_HZ) && defined(CONFIG_SMP)
	if (!pinned && get_sysctl_timer_migration() && idle_cpu(cpu))
c103c9cf:	75 16                	jne    c103c9e7 <__mod_timer+0x94>
c103c9d1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c103c9d4:	e8 fc ff ff ff       	call   c103c9d5 <__mod_timer+0x82>
c103c9d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c103c9dc:	85 c0                	test   %eax,%eax
c103c9de:	74 07                	je     c103c9e7 <__mod_timer+0x94>
		cpu = get_nohz_timer_target();
c103c9e0:	e8 fc ff ff ff       	call   c103c9e1 <__mod_timer+0x8e>
c103c9e5:	89 c2                	mov    %eax,%edx
#endif
	new_base = per_cpu(tvec_bases, cpu);
c103c9e7:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
c103c9ee:	b8 00 00 00 00       	mov    $0x0,%eax
c103c9f3:	8b 14 02             	mov    (%edx,%eax,1),%edx

	if (base != new_base) {
c103c9f6:	39 d6                	cmp    %edx,%esi

#if defined(CONFIG_NO_HZ) && defined(CONFIG_SMP)
	if (!pinned && get_sysctl_timer_migration() && idle_cpu(cpu))
		cpu = get_nohz_timer_target();
#endif
	new_base = per_cpu(tvec_bases, cpu);
c103c9f8:	89 55 ec             	mov    %edx,-0x14(%ebp)

	if (base != new_base) {
c103c9fb:	74 27                	je     c103ca24 <__mod_timer+0xd1>
		 * However we can't change timer's base while it is running,
		 * otherwise del_timer_sync() can't detect that the timer's
		 * handler yet has not finished. This also guarantees that
		 * the timer is serialized wrt itself.
		 */
		if (likely(base->running_timer != timer)) {
c103c9fd:	39 5e 04             	cmp    %ebx,0x4(%esi)
c103ca00:	74 22                	je     c103ca24 <__mod_timer+0xd1>
}

static inline void
timer_set_base(struct timer_list *timer, struct tvec_base *new_base)
{
	timer->base = (struct tvec_base *)((unsigned long)(new_base) |
c103ca02:	83 63 0c 01          	andl   $0x1,0xc(%ebx)
c103ca06:	89 f0                	mov    %esi,%eax
c103ca08:	e8 fc ff ff ff       	call   c103ca09 <__mod_timer+0xb6>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
c103ca0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c103ca10:	e8 fc ff ff ff       	call   c103ca11 <__mod_timer+0xbe>
c103ca15:	8b 43 0c             	mov    0xc(%ebx),%eax
c103ca18:	8b 75 ec             	mov    -0x14(%ebp),%esi
c103ca1b:	83 e0 01             	and    $0x1,%eax
c103ca1e:	0b 45 ec             	or     -0x14(%ebp),%eax
c103ca21:	89 43 0c             	mov    %eax,0xc(%ebx)
			spin_lock(&base->lock);
			timer_set_base(timer, base);
		}
	}

	timer->expires = expires;
c103ca24:	89 7b 08             	mov    %edi,0x8(%ebx)
	if (time_before(timer->expires, base->next_timer) &&
c103ca27:	3b 7e 0c             	cmp    0xc(%esi),%edi
c103ca2a:	79 09                	jns    c103ca35 <__mod_timer+0xe2>
	    !tbase_get_deferrable(timer->base))
c103ca2c:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103ca30:	75 03                	jne    c103ca35 <__mod_timer+0xe2>
		base->next_timer = timer->expires;
c103ca32:	89 7e 0c             	mov    %edi,0xc(%esi)
	internal_add_timer(base, timer);
c103ca35:	89 da                	mov    %ebx,%edx
c103ca37:	89 f0                	mov    %esi,%eax
c103ca39:	e8 e8 e1 ff ff       	call   c103ac26 <internal_add_timer>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
c103ca3e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c103ca41:	89 f0                	mov    %esi,%eax
c103ca43:	e8 fc ff ff ff       	call   c103ca44 <__mod_timer+0xf1>

out_unlock:
	spin_unlock_irqrestore(&base->lock, flags);

	return ret;
}
c103ca48:	8b 45 e8             	mov    -0x18(%ebp),%eax
c103ca4b:	83 c4 10             	add    $0x10,%esp
c103ca4e:	5b                   	pop    %ebx
c103ca4f:	5e                   	pop    %esi
c103ca50:	5f                   	pop    %edi
c103ca51:	5d                   	pop    %ebp
c103ca52:	c3                   	ret

c103ca53 <msleep>:
/**
 * msleep - sleep safely even with waitqueue interruptions
 * @msecs: Time in milliseconds to sleep for
 */
void msleep(unsigned int msecs)
{
c103ca53:	55                   	push   %ebp
c103ca54:	89 e5                	mov    %esp,%ebp
	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
c103ca56:	e8 fc ff ff ff       	call   c103ca57 <msleep+0x4>
c103ca5b:	40                   	inc    %eax

	while (timeout)
c103ca5c:	eb 05                	jmp    c103ca63 <msleep+0x10>
		timeout = schedule_timeout_uninterruptible(timeout);
c103ca5e:	e8 fc ff ff ff       	call   c103ca5f <msleep+0xc>
 */
void msleep(unsigned int msecs)
{
	unsigned long timeout = msecs_to_jiffies(msecs) + 1;

	while (timeout)
c103ca63:	85 c0                	test   %eax,%eax
c103ca65:	75 f7                	jne    c103ca5e <msleep+0xb>
		timeout = schedule_timeout_uninterruptible(timeout);
}
c103ca67:	5d                   	pop    %ebp
c103ca68:	c3                   	ret

c103ca69 <msleep_interruptible>:
/**
 * msleep_interruptible - sleep waiting for signals
 * @msecs: Time in milliseconds to sleep for
 */
unsigned long msleep_interruptible(unsigned int msecs)
{
c103ca69:	55                   	push   %ebp
c103ca6a:	89 e5                	mov    %esp,%ebp
c103ca6c:	53                   	push   %ebx
	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
c103ca6d:	e8 fc ff ff ff       	call   c103ca6e <msleep_interruptible+0x5>
c103ca72:	64 8b 1d 00 00 00 00 	mov    %fs:0x0,%ebx
c103ca79:	40                   	inc    %eax

	while (timeout && !signal_pending(current))
c103ca7a:	eb 05                	jmp    c103ca81 <msleep_interruptible+0x18>
		timeout = schedule_timeout_interruptible(timeout);
c103ca7c:	e8 fc ff ff ff       	call   c103ca7d <msleep_interruptible+0x14>
 */
unsigned long msleep_interruptible(unsigned int msecs)
{
	unsigned long timeout = msecs_to_jiffies(msecs) + 1;

	while (timeout && !signal_pending(current))
c103ca81:	85 c0                	test   %eax,%eax
c103ca83:	74 0b                	je     c103ca90 <msleep_interruptible+0x27>
	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
{
	return test_bit(flag, (unsigned long *)&ti->flags);
c103ca85:	8b 53 04             	mov    0x4(%ebx),%edx
}

static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr % BITS_PER_LONG)) &
		(addr[nr / BITS_PER_LONG])) != 0;
c103ca88:	8b 52 08             	mov    0x8(%edx),%edx
c103ca8b:	80 e2 04             	and    $0x4,%dl
c103ca8e:	74 ec                	je     c103ca7c <msleep_interruptible+0x13>
		timeout = schedule_timeout_interruptible(timeout);
	return jiffies_to_msecs(timeout);
c103ca90:	e8 fc ff ff ff       	call   c103ca91 <msleep_interruptible+0x28>
}
c103ca95:	5b                   	pop    %ebx
c103ca96:	5d                   	pop    %ebp
c103ca97:	c3                   	ret

c103ca98 <mod_timer_pinned>:
 * mod_timer_pinned(timer, expires) is equivalent to:
 *
 *     del_timer(timer); timer->expires = expires; add_timer(timer);
 */
int mod_timer_pinned(struct timer_list *timer, unsigned long expires)
{
c103ca98:	55                   	push   %ebp
	if (timer->expires == expires && timer_pending(timer))
c103ca99:	39 50 08             	cmp    %edx,0x8(%eax)
 * mod_timer_pinned(timer, expires) is equivalent to:
 *
 *     del_timer(timer); timer->expires = expires; add_timer(timer);
 */
int mod_timer_pinned(struct timer_list *timer, unsigned long expires)
{
c103ca9c:	89 e5                	mov    %esp,%ebp
	if (timer->expires == expires && timer_pending(timer))
c103ca9e:	75 0a                	jne    c103caaa <mod_timer_pinned+0x12>
c103caa0:	83 38 00             	cmpl   $0x0,(%eax)
c103caa3:	b9 01 00 00 00       	mov    $0x1,%ecx
c103caa8:	75 0c                	jne    c103cab6 <mod_timer_pinned+0x1e>
		return 1;

	return __mod_timer(timer, expires, false, TIMER_PINNED);
c103caaa:	31 c9                	xor    %ecx,%ecx
c103caac:	6a 01                	push   $0x1
c103caae:	e8 a0 fe ff ff       	call   c103c953 <__mod_timer>
c103cab3:	89 c1                	mov    %eax,%ecx
c103cab5:	58                   	pop    %eax
}
c103cab6:	89 c8                	mov    %ecx,%eax
c103cab8:	c9                   	leave
c103cab9:	c3                   	ret

c103caba <mod_timer>:
 * The function returns whether it has modified a pending timer or not.
 * (ie. mod_timer() of an inactive timer returns 0, mod_timer() of an
 * active timer returns 1.)
 */
int mod_timer(struct timer_list *timer, unsigned long expires)
{
c103caba:	55                   	push   %ebp
c103cabb:	89 e5                	mov    %esp,%ebp
c103cabd:	56                   	push   %esi
c103cabe:	53                   	push   %ebx
c103cabf:	89 c3                	mov    %eax,%ebx
c103cac1:	83 ec 04             	sub    $0x4,%esp
	/*
	 * This is a common optimization triggered by the
	 * networking code - if the timer is re-modified
	 * to be the same thing then just return:
	 */
	if (timer_pending(timer) && timer->expires == expires)
c103cac4:	83 38 00             	cmpl   $0x0,(%eax)
c103cac7:	74 0a                	je     c103cad3 <mod_timer+0x19>
c103cac9:	39 53 08             	cmp    %edx,0x8(%ebx)
c103cacc:	b8 01 00 00 00       	mov    $0x1,%eax
c103cad1:	74 53                	je     c103cb26 <mod_timer+0x6c>
	unsigned long expires_limit, mask;
	int bit;

	expires_limit = expires;

	if (timer->slack >= 0) {
c103cad3:	8b 73 18             	mov    0x18(%ebx),%esi
c103cad6:	85 f6                	test   %esi,%esi
c103cad8:	78 05                	js     c103cadf <mod_timer+0x25>
		expires_limit = expires + timer->slack;
c103cada:	8d 34 32             	lea    (%edx,%esi,1),%esi
c103cadd:	eb 12                	jmp    c103caf1 <mod_timer+0x37>
	} else {
		unsigned long now = jiffies;
c103cadf:	a1 00 00 00 00       	mov    0x0,%eax

		/* No slack, if already expired else auto slack 0.4% */
		if (time_after(expires, now))
c103cae4:	89 d6                	mov    %edx,%esi
c103cae6:	39 d0                	cmp    %edx,%eax
c103cae8:	79 07                	jns    c103caf1 <mod_timer+0x37>
			expires_limit = expires + (expires - now)/256;
c103caea:	29 c6                	sub    %eax,%esi
c103caec:	c1 ee 08             	shr    $0x8,%esi
c103caef:	01 d6                	add    %edx,%esi
	}
	mask = expires ^ expires_limit;
c103caf1:	89 f0                	mov    %esi,%eax
c103caf3:	31 d0                	xor    %edx,%eax
	if (mask == 0)
c103caf5:	85 c0                	test   %eax,%eax

		/* No slack, if already expired else auto slack 0.4% */
		if (time_after(expires, now))
			expires_limit = expires + (expires - now)/256;
	}
	mask = expires ^ expires_limit;
c103caf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (mask == 0)
c103cafa:	74 1e                	je     c103cb1a <mod_timer+0x60>
		return expires;

	bit = find_last_bit(&mask, BITS_PER_LONG);
c103cafc:	ba 20 00 00 00       	mov    $0x20,%edx
c103cb01:	8d 45 f4             	lea    -0xc(%ebp),%eax
c103cb04:	e8 fc ff ff ff       	call   c103cb05 <mod_timer+0x4b>

	mask = (1 << bit) - 1;
c103cb09:	ba 01 00 00 00       	mov    $0x1,%edx
c103cb0e:	88 c1                	mov    %al,%cl
c103cb10:	d3 e2                	shl    %cl,%edx
c103cb12:	4a                   	dec    %edx
c103cb13:	89 55 f4             	mov    %edx,-0xc(%ebp)

	expires_limit = expires_limit & ~(mask);
c103cb16:	f7 d2                	not    %edx
c103cb18:	21 f2                	and    %esi,%edx
	if (timer_pending(timer) && timer->expires == expires)
		return 1;

	expires = apply_slack(timer, expires);

	return __mod_timer(timer, expires, false, TIMER_NOT_PINNED);
c103cb1a:	6a 00                	push   $0x0
c103cb1c:	31 c9                	xor    %ecx,%ecx
c103cb1e:	89 d8                	mov    %ebx,%eax
c103cb20:	e8 2e fe ff ff       	call   c103c953 <__mod_timer>
c103cb25:	5a                   	pop    %edx
}
c103cb26:	8d 65 f8             	lea    -0x8(%ebp),%esp
c103cb29:	5b                   	pop    %ebx
c103cb2a:	5e                   	pop    %esi
c103cb2b:	5d                   	pop    %ebp
c103cb2c:	c3                   	ret

c103cb2d <add_timer>:
 *
 * Timers with an ->expires field in the past will be executed in the next
 * timer tick.
 */
void add_timer(struct timer_list *timer)
{
c103cb2d:	55                   	push   %ebp
	BUG_ON(timer_pending(timer));
c103cb2e:	83 38 00             	cmpl   $0x0,(%eax)
 *
 * Timers with an ->expires field in the past will be executed in the next
 * timer tick.
 */
void add_timer(struct timer_list *timer)
{
c103cb31:	89 e5                	mov    %esp,%ebp
	BUG_ON(timer_pending(timer));
c103cb33:	74 04                	je     c103cb39 <add_timer+0xc>
c103cb35:	0f 0b                	ud2a
c103cb37:	eb fe                	jmp    c103cb37 <add_timer+0xa>
	mod_timer(timer, timer->expires);
c103cb39:	8b 50 08             	mov    0x8(%eax),%edx
c103cb3c:	e8 fc ff ff ff       	call   c103cb3d <add_timer+0x10>
}
c103cb41:	5d                   	pop    %ebp
c103cb42:	c3                   	ret

c103cb43 <mod_timer_pending>:
 * but will not re-activate and modify already deleted timers.
 *
 * It is useful for unserialized use of timers.
 */
int mod_timer_pending(struct timer_list *timer, unsigned long expires)
{
c103cb43:	55                   	push   %ebp
	return __mod_timer(timer, expires, true, TIMER_NOT_PINNED);
c103cb44:	b9 01 00 00 00       	mov    $0x1,%ecx
 * but will not re-activate and modify already deleted timers.
 *
 * It is useful for unserialized use of timers.
 */
int mod_timer_pending(struct timer_list *timer, unsigned long expires)
{
c103cb49:	89 e5                	mov    %esp,%ebp
	return __mod_timer(timer, expires, true, TIMER_NOT_PINNED);
c103cb4b:	6a 00                	push   $0x0
c103cb4d:	e8 01 fe ff ff       	call   c103c953 <__mod_timer>
}
c103cb52:	c9                   	leave
c103cb53:	c3                   	ret

c103cb54 <add_timer_on>:
 * @cpu: the CPU to start it on
 *
 * This is not very scalable on SMP. Double adds are not possible.
 */
void add_timer_on(struct timer_list *timer, int cpu)
{
c103cb54:	55                   	push   %ebp
c103cb55:	89 e5                	mov    %esp,%ebp
c103cb57:	57                   	push   %edi
c103cb58:	89 d7                	mov    %edx,%edi
c103cb5a:	56                   	push   %esi
c103cb5b:	53                   	push   %ebx
c103cb5c:	89 c3                	mov    %eax,%ebx
c103cb5e:	83 ec 04             	sub    $0x4,%esp
	struct tvec_base *base = per_cpu(tvec_bases, cpu);
c103cb61:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx
c103cb68:	b8 00 00 00 00       	mov    $0x0,%eax
c103cb6d:	8b 34 10             	mov    (%eax,%edx,1),%esi
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
c103cb70:	89 d8                	mov    %ebx,%eax
c103cb72:	e8 c6 fd ff ff       	call   c103c93d <timer_stats_timer_set_start_info>
	BUG_ON(timer_pending(timer) || !timer->function);
c103cb77:	83 3b 00             	cmpl   $0x0,(%ebx)
c103cb7a:	75 06                	jne    c103cb82 <add_timer_on+0x2e>
c103cb7c:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
c103cb80:	75 04                	jne    c103cb86 <add_timer_on+0x32>
c103cb82:	0f 0b                	ud2a
c103cb84:	eb fe                	jmp    c103cb84 <add_timer_on+0x30>
	spin_lock_irqsave(&base->lock, flags);
c103cb86:	89 f0                	mov    %esi,%eax
c103cb88:	e8 fc ff ff ff       	call   c103cb89 <add_timer_on+0x35>
	timer_set_base(timer, base);
	debug_activate(timer, timer->expires);
c103cb8d:	8b 53 08             	mov    0x8(%ebx),%edx
	struct tvec_base *base = per_cpu(tvec_bases, cpu);
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);
	spin_lock_irqsave(&base->lock, flags);
c103cb90:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static inline void
timer_set_base(struct timer_list *timer, struct tvec_base *new_base)
{
	timer->base = (struct tvec_base *)((unsigned long)(new_base) |
c103cb93:	8b 43 0c             	mov    0xc(%ebx),%eax
c103cb96:	83 e0 01             	and    $0x1,%eax
c103cb99:	09 f0                	or     %esi,%eax
c103cb9b:	89 43 0c             	mov    %eax,0xc(%ebx)

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);
	spin_lock_irqsave(&base->lock, flags);
	timer_set_base(timer, base);
	debug_activate(timer, timer->expires);
c103cb9e:	89 d8                	mov    %ebx,%eax
c103cba0:	e8 89 f5 ff ff       	call   c103c12e <debug_activate>
	if (time_before(timer->expires, base->next_timer) &&
c103cba5:	8b 43 08             	mov    0x8(%ebx),%eax
c103cba8:	3b 46 0c             	cmp    0xc(%esi),%eax
c103cbab:	79 09                	jns    c103cbb6 <add_timer_on+0x62>
	    !tbase_get_deferrable(timer->base))
c103cbad:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
c103cbb1:	75 03                	jne    c103cbb6 <add_timer_on+0x62>
		base->next_timer = timer->expires;
c103cbb3:	89 46 0c             	mov    %eax,0xc(%esi)
	internal_add_timer(base, timer);
c103cbb6:	89 da                	mov    %ebx,%edx
c103cbb8:	89 f0                	mov    %esi,%eax
c103cbba:	e8 67 e0 ff ff       	call   c103ac26 <internal_add_timer>
	 * active. We are protected against the other CPU fiddling
	 * with the timer by holding the timer base lock. This also
	 * makes sure that a CPU on the way to idle can not evaluate
	 * the timer wheel.
	 */
	wake_up_idle_cpu(cpu);
c103cbbf:	89 f8                	mov    %edi,%eax
c103cbc1:	e8 fc ff ff ff       	call   c103cbc2 <add_timer_on+0x6e>
c103cbc6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c103cbc9:	89 f0                	mov    %esi,%eax
c103cbcb:	e8 fc ff ff ff       	call   c103cbcc <add_timer_on+0x78>
	spin_unlock_irqrestore(&base->lock, flags);
}
c103cbd0:	59                   	pop    %ecx
c103cbd1:	5b                   	pop    %ebx
c103cbd2:	5e                   	pop    %esi
c103cbd3:	5f                   	pop    %edi
c103cbd4:	5d                   	pop    %ebp
c103cbd5:	c3                   	ret

Disassembly of section .cpuinit.text:

c103ab38 <timer_cpu_notify>:
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab38:	55                   	push   %ebp
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab39:	83 fa 07             	cmp    $0x7,%edx
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab3c:	89 e5                	mov    %esp,%ebp
c103ab3e:	57                   	push   %edi
c103ab3f:	56                   	push   %esi
c103ab40:	53                   	push   %ebx
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab41:	89 cb                	mov    %ecx,%ebx
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab43:	0f 84 49 01 00 00    	je     c103ac92 <timer_cpu_notify+0x15a>
		 * in the caller. Nothing more. We could take
		 * MAX_SCHEDULE_TIMEOUT from one of the negative value
		 * but I' d like to return a valid offset (>=0) to allow
		 * the caller to do everything it want with the retval.
		 */
		schedule();
c103ab49:	77 0b                	ja     c103ab56 <timer_cpu_notify+0x1e>
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab4b:	83 fa 03             	cmp    $0x3,%edx
		 * MAX_SCHEDULE_TIMEOUT from one of the negative value
		 * but I' d like to return a valid offset (>=0) to allow
		 * the caller to do everything it want with the retval.
		 */
		schedule();
		goto out;
c103ab4e:	0f 85 12 02 00 00    	jne    c103ad66 <timer_cpu_notify+0x22e>
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab54:	eb 13                	jmp    c103ab69 <timer_cpu_notify+0x31>
c103ab56:	83 fa 13             	cmp    $0x13,%edx
	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
				(void *)(long)smp_processor_id());

	init_timer_stats();

	BUG_ON(err != NOTIFY_OK);
c103ab59:	74 0e                	je     c103ab69 <timer_cpu_notify+0x31>
c103ab5b:	83 fa 17             	cmp    $0x17,%edx
c103ab5e:	0f 85 02 02 00 00    	jne    c103ad66 <timer_cpu_notify+0x22e>
c103ab64:	e9 29 01 00 00       	jmp    c103ac92 <timer_cpu_notify+0x15a>
{
	int j;
	struct tvec_base *base;
	static char __cpuinitdata tvec_base_done[NR_CPUS];

	if (!tvec_base_done[cpu]) {
c103ab69:	80 bb 0c 00 00 00 00 	cmpb   $0x0,0xc(%ebx)
		if (timeout < 0) {
			printk(KERN_ERR "schedule_timeout: wrong timeout "
				"value %lx\n", timeout);
			dump_stack();
			current->state = TASK_RUNNING;
			goto out;
c103ab70:	0f 85 85 00 00 00    	jne    c103abfb <timer_cpu_notify+0xc3>
	j -= cpu * 3;

	if (j <= jiffies) /* rounding ate our timeout entirely; */
		return original;
	return j;
}
c103ab76:	80 3d 49 10 00 00 00 	cmpb   $0x0,0x1049
c103ab7d:	74 67                	je     c103abe6 <timer_cpu_notify+0xae>
	int index = kmalloc_index(size);

	if (index == 0)
		return NULL;

	return kmalloc_caches[index];
c103ab7f:	a1 34 00 00 00       	mov    0x34,%eax
			return kmalloc_large(size, flags);

		if (!(flags & SLUB_DMA)) {
			struct kmem_cache *s = kmalloc_slab(size);

			if (!s)
c103ab84:	be 10 00 00 00       	mov    $0x10,%esi
c103ab89:	85 c0                	test   %eax,%eax
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies(unsigned long j, int cpu)
{
	return round_jiffies_common(j, cpu, false);
c103ab8b:	74 11                	je     c103ab9e <timer_cpu_notify+0x66>
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(s, flags, size);
c103ab8d:	b9 40 10 00 00       	mov    $0x1040,%ecx
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
c103ab92:	ba d0 80 00 00       	mov    $0x80d0,%edx
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;
c103ab97:	e8 fc ff ff ff       	call   c103ab98 <timer_cpu_notify+0x60>
	}

	expire = timeout + jiffies;

	setup_timer_on_stack(&timer, process_timeout, (unsigned long)current);
	__mod_timer(&timer, expire, false, TIMER_NOT_PINNED);
c103ab9c:	89 c6                	mov    %eax,%esi
			 * The APs use this path later in boot
			 */
			base = kmalloc_node(sizeof(*base),
						GFP_KERNEL | __GFP_ZERO,
						cpu_to_node(cpu));
			if (!base)
c103ab9e:	85 f6                	test   %esi,%esi

		if (boot_done) {
			/*
			 * The APs use this path later in boot
			 */
			base = kmalloc_node(sizeof(*base),
c103aba0:	89 f2                	mov    %esi,%edx
						GFP_KERNEL | __GFP_ZERO,
						cpu_to_node(cpu));
			if (!base)
c103aba2:	b8 0d 80 00 00       	mov    $0x800d,%eax
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
}
c103aba7:	0f 84 be 01 00 00    	je     c103ad6b <timer_cpu_notify+0x233>
						cpu_to_node(cpu));
			if (!base)
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
c103abad:	f7 c6 01 00 00 00    	test   $0x1,%esi
	del_singleshot_timer_sync(&timer);

	/* Remove the timer from the object tracker */
	destroy_timer_on_stack(&timer);

	timeout = expire - jiffies;
c103abb3:	74 20                	je     c103abd5 <timer_cpu_notify+0x9d>
			if (!base)
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
c103abb5:	ba 51 06 00 00       	mov    $0x651,%edx
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), false);
}
c103abba:	b8 00 00 00 00       	mov    $0x0,%eax
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
	return __round_jiffies_relative(j, raw_smp_processor_id());
c103abbf:	e8 fc ff ff ff       	call   c103abc0 <timer_cpu_notify+0x88>
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
				kfree(base);
c103abc4:	89 f0                	mov    %esi,%eax
c103abc6:	e8 fc ff ff ff       	call   c103abc7 <timer_cpu_notify+0x8f>
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
	return __round_jiffies_relative(j, raw_smp_processor_id());
}
c103abcb:	b8 0d 80 00 00       	mov    $0x800d,%eax
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up(unsigned long j, int cpu)
{
	return round_jiffies_common(j, cpu, true);
c103abd0:	e9 96 01 00 00       	jmp    c103ad6b <timer_cpu_notify+0x233>
c103abd5:	8b 0c 9d 00 00 00 00 	mov    0x0(,%ebx,4),%ecx
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
c103abdc:	b8 00 00 00 00       	mov    $0x0,%eax
	return schedule_timeout(timeout);
}
EXPORT_SYMBOL(schedule_timeout_interruptible);

signed long __sched schedule_timeout_killable(signed long timeout)
{
c103abe1:	89 34 08             	mov    %esi,(%eax,%ecx,1)
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
c103abe4:	eb 0c                	jmp    c103abf2 <timer_cpu_notify+0xba>
			 * This is for the boot CPU - we use compile-time
			 * static initialisation because per-cpu memory isn't
			 * ready yet and because the memory allocators are not
			 * initialised either.
			 */
			boot_done = 1;
c103abe6:	c6 05 49 10 00 00 01 	movb   $0x1,0x1049
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
c103abed:	ba 00 00 00 00       	mov    $0x0,%edx
			 * initialised either.
			 */
			boot_done = 1;
			base = &boot_tvec_bases;
		}
		tvec_base_done[cpu] = 1;
c103abf2:	c6 83 0c 00 00 00 01 	movb   $0x1,0xc(%ebx)
c103abf9:	eb 0f                	jmp    c103ac0a <timer_cpu_notify+0xd2>
	} else {
		base = per_cpu(tvec_bases, cpu);
c103abfb:	8b 14 9d 00 00 00 00 	mov    0x0(,%ebx,4),%edx
 * We can use __set_current_state() here because schedule_timeout() calls
 * schedule() unconditionally.
 */
signed long __sched schedule_timeout_interruptible(signed long timeout)
{
	__set_current_state(TASK_INTERRUPTIBLE);
c103ac02:	b8 00 00 00 00       	mov    $0x0,%eax
	return schedule_timeout(timeout);
c103ac07:	8b 14 10             	mov    (%eax,%edx,1),%edx
		tvec_base_done[cpu] = 1;
	} else {
		base = per_cpu(tvec_bases, cpu);
	}

	spin_lock_init(&base->lock);
c103ac0a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long round_jiffies_up_relative(unsigned long j)
{
	return __round_jiffies_up_relative(j, raw_smp_processor_id());
c103ac10:	31 c0                	xor    %eax,%eax
	}

	spin_lock_init(&base->lock);

	for (j = 0; j < TVN_SIZE; j++) {
		INIT_LIST_HEAD(base->tv5.vec + j);
c103ac12:	8d 8c c2 10 0e 00 00 	lea    0xe10(%edx,%eax,8),%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac19:	89 8c c2 10 0e 00 00 	mov    %ecx,0xe10(%edx,%eax,8)
	list->prev = list;
c103ac20:	89 8c c2 14 0e 00 00 	mov    %ecx,0xe14(%edx,%eax,8)
}
EXPORT_SYMBOL_GPL(set_timer_slack);

static void internal_add_timer(struct tvec_base *base, struct timer_list *timer)
{
	unsigned long expires = timer->expires;
c103ac27:	8d 8c c2 10 0c 00 00 	lea    0xc10(%edx,%eax,8),%ecx
	unsigned long idx = expires - base->timer_jiffies;
c103ac2e:	89 8c c2 10 0c 00 00 	mov    %ecx,0xc10(%edx,%eax,8)
	struct list_head *vec;

	if (idx < TVR_SIZE) {
c103ac35:	89 8c c2 14 0c 00 00 	mov    %ecx,0xc14(%edx,%eax,8)
	spin_lock_init(&base->lock);

	for (j = 0; j < TVN_SIZE; j++) {
		INIT_LIST_HEAD(base->tv5.vec + j);
		INIT_LIST_HEAD(base->tv4.vec + j);
		INIT_LIST_HEAD(base->tv3.vec + j);
c103ac3c:	8d 8c c2 10 0a 00 00 	lea    0xa10(%edx,%eax,8),%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac43:	89 8c c2 10 0a 00 00 	mov    %ecx,0xa10(%edx,%eax,8)
	list->prev = list;
c103ac4a:	89 8c c2 14 0a 00 00 	mov    %ecx,0xa14(%edx,%eax,8)
	if (idx < TVR_SIZE) {
		int i = expires & TVR_MASK;
		vec = base->tv1.vec + i;
	} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {
		int i = (expires >> TVR_BITS) & TVN_MASK;
		vec = base->tv2.vec + i;
c103ac51:	8d 8c c2 10 08 00 00 	lea    0x810(%edx,%eax,8),%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac58:	89 8c c2 10 08 00 00 	mov    %ecx,0x810(%edx,%eax,8)
	list->prev = list;
c103ac5f:	89 8c c2 14 08 00 00 	mov    %ecx,0x814(%edx,%eax,8)
		base = per_cpu(tvec_bases, cpu);
	}

	spin_lock_init(&base->lock);

	for (j = 0; j < TVN_SIZE; j++) {
c103ac66:	40                   	inc    %eax
c103ac67:	83 f8 40             	cmp    $0x40,%eax
	} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {
		int i = (expires >> TVR_BITS) & TVN_MASK;
		vec = base->tv2.vec + i;
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
c103ac6a:	75 a6                	jne    c103ac12 <timer_cpu_notify+0xda>
c103ac6c:	30 c0                	xor    %al,%al
		INIT_LIST_HEAD(base->tv4.vec + j);
		INIT_LIST_HEAD(base->tv3.vec + j);
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
		INIT_LIST_HEAD(base->tv1.vec + j);
c103ac6e:	8d 4c c2 10          	lea    0x10(%edx,%eax,8),%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ac72:	89 4c c2 10          	mov    %ecx,0x10(%edx,%eax,8)
	list->prev = list;
c103ac76:	89 4c c2 14          	mov    %ecx,0x14(%edx,%eax,8)
		INIT_LIST_HEAD(base->tv5.vec + j);
		INIT_LIST_HEAD(base->tv4.vec + j);
		INIT_LIST_HEAD(base->tv3.vec + j);
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
c103ac7a:	40                   	inc    %eax
c103ac7b:	3d 00 01 00 00       	cmp    $0x100,%eax
	} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
		vec = base->tv3.vec + i;
	} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {
		int i = (expires >> (TVR_BITS + 2 * TVN_BITS)) & TVN_MASK;
		vec = base->tv4.vec + i;
c103ac80:	75 ec                	jne    c103ac6e <timer_cpu_notify+0x136>
		INIT_LIST_HEAD(base->tv2.vec + j);
	}
	for (j = 0; j < TVR_SIZE; j++)
		INIT_LIST_HEAD(base->tv1.vec + j);

	base->timer_jiffies = jiffies;
c103ac82:	a1 00 00 00 00       	mov    0x0,%eax
c103ac87:	89 42 08             	mov    %eax,0x8(%edx)
	base->next_timer = base->timer_jiffies;
c103ac8a:	89 42 0c             	mov    %eax,0xc(%edx)
c103ac8d:	e9 d4 00 00 00       	jmp    c103ad66 <timer_cpu_notify+0x22e>
	} else if ((signed long) idx < 0) {
		/*
		 * Can happen if you add a timer with expires == jiffies,
		 * or you set a timer to go off in the past
		 */
		vec = base->tv1.vec + (base->timer_jiffies & TVR_MASK);
c103ac92:	a1 00 00 00 00       	mov    0x0,%eax
c103ac97:	0f a3 18             	bt     %ebx,(%eax)
c103ac9a:	19 c0                	sbb    %eax,%eax
{
	struct tvec_base *old_base;
	struct tvec_base *new_base;
	int i;

	BUG_ON(cpu_online(cpu));
c103ac9c:	85 c0                	test   %eax,%eax
		if (idx > 0xffffffffUL) {
			idx = 0xffffffffUL;
			expires = idx + base->timer_jiffies;
		}
		i = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;
		vec = base->tv5.vec + i;
c103ac9e:	74 04                	je     c103aca4 <timer_cpu_notify+0x16c>
c103aca0:	0f 0b                	ud2a
c103aca2:	eb fe                	jmp    c103aca2 <timer_cpu_notify+0x16a>
	struct tvec_base *old_base;
	struct tvec_base *new_base;
	int i;

	BUG_ON(cpu_online(cpu));
	old_base = per_cpu(tvec_bases, cpu);
c103aca4:	8b 04 9d 00 00 00 00 	mov    0x0(,%ebx,4),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
c103acab:	be 00 00 00 00       	mov    $0x0,%esi
	new->next = next;
	new->prev = prev;
c103acb0:	8b 1c 06             	mov    (%esi,%eax,1),%ebx
	prev->next = new;
c103acb3:	b8 01 00 00 00       	mov    $0x1,%eax
	}
	/*
	 * Timers are FIFO:
	 */
	list_add_tail(&timer->entry, vec);
}
c103acb8:	e8 fc ff ff ff       	call   c103acb9 <timer_cpu_notify+0x181>
c103acbd:	e8 fc ff ff ff       	call   c103acbe <timer_cpu_notify+0x186>
c103acc2:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
c103acc9:	8b 3c 30             	mov    (%eax,%esi,1),%edi

SYSCALL_DEFINE0(getuid)
{
	/* Only we change this so SMP safe */
	return current_uid();
}
c103accc:	31 f6                	xor    %esi,%esi
c103acce:	89 f8                	mov    %edi,%eax
c103acd0:	e8 fc ff ff ff       	call   c103acd1 <timer_cpu_notify+0x199>
	/*
	 * The caller is globally serialized and nobody else
	 * takes two locks at once, deadlock is not possible.
	 */
	spin_lock_irq(&new_base->lock);
	spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);
c103acd5:	89 d8                	mov    %ebx,%eax
c103acd7:	e8 fc ff ff ff       	call   c103acd8 <timer_cpu_notify+0x1a0>

SYSCALL_DEFINE0(geteuid)
{
	/* Only we change this so SMP safe */
	return current_euid();
}
c103acdc:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c103ace0:	74 04                	je     c103ace6 <timer_cpu_notify+0x1ae>
c103ace2:	0f 0b                	ud2a
c103ace4:	eb fe                	jmp    c103ace4 <timer_cpu_notify+0x1ac>
	spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
c103ace6:	8d 54 f3 10          	lea    0x10(%ebx,%esi,8),%edx
c103acea:	89 f8                	mov    %edi,%eax
	spin_lock_irq(&new_base->lock);
	spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
c103acec:	46                   	inc    %esi
		migrate_timer_list(new_base, old_base->tv1.vec + i);
c103aced:	e8 af 15 00 00       	call   c103c2a1 <run_timer_softirq+0x89>
	spin_lock_irq(&new_base->lock);
	spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
c103acf2:	81 fe 00 01 00 00    	cmp    $0x100,%esi
c103acf8:	75 ec                	jne    c103ace6 <timer_cpu_notify+0x1ae>
c103acfa:	66 31 f6             	xor    %si,%si
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
		migrate_timer_list(new_base, old_base->tv2.vec + i);
c103acfd:	8d 94 f3 10 08 00 00 	lea    0x810(%ebx,%esi,8),%edx

SYSCALL_DEFINE0(getegid)
{
	/* Only we change this so SMP safe */
	return  current_egid();
}
c103ad04:	89 f8                	mov    %edi,%eax
c103ad06:	e8 af 15 00 00       	call   c103c2ba <run_timer_softirq+0xa2>

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
		migrate_timer_list(new_base, old_base->tv2.vec + i);
		migrate_timer_list(new_base, old_base->tv3.vec + i);
c103ad0b:	8d 94 f3 10 0a 00 00 	lea    0xa10(%ebx,%esi,8),%edx
c103ad12:	89 f8                	mov    %edi,%eax
c103ad14:	e8 af 15 00 00       	call   c103c2c8 <run_timer_softirq+0xb0>
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
	new->next->prev = new;
c103ad19:	8d 94 f3 10 0c 00 00 	lea    0xc10(%ebx,%esi,8),%edx
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
				struct list_head *new)
{
	new->next = old->next;
c103ad20:	89 f8                	mov    %edi,%eax
	new->next->prev = new;
c103ad22:	e8 af 15 00 00       	call   c103c2d6 <run_timer_softirq+0xbe>
		migrate_timer_list(new_base, old_base->tv4.vec + i);
		migrate_timer_list(new_base, old_base->tv5.vec + i);
c103ad27:	8d 94 f3 10 0e 00 00 	lea    0xe10(%ebx,%esi,8),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
c103ad2e:	89 f8                	mov    %edi,%eax

	BUG_ON(old_base->running_timer);

	for (i = 0; i < TVR_SIZE; i++)
		migrate_timer_list(new_base, old_base->tv1.vec + i);
	for (i = 0; i < TVN_SIZE; i++) {
c103ad30:	46                   	inc    %esi
	list->prev = list;
c103ad31:	e8 af 15 00 00       	call   c103c2e5 <run_timer_softirq+0xcd>
c103ad36:	83 fe 40             	cmp    $0x40,%esi
c103ad39:	75 c2                	jne    c103acfd <timer_cpu_notify+0x1c5>
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
c103ad3b:	89 d8                	mov    %ebx,%eax
c103ad3d:	e8 fc ff ff ff       	call   c103ad3e <timer_cpu_notify+0x206>
	raw_spin_unlock_bh(&lock->rlock);
}

static inline void spin_unlock_irq(spinlock_t *lock)
{
	raw_spin_unlock_irq(&lock->rlock);
c103ad42:	89 f8                	mov    %edi,%eax
c103ad44:	e8 fc ff ff ff       	call   c103ad45 <timer_cpu_notify+0x20d>
		migrate_timer_list(new_base, old_base->tv5.vec + i);
	}

	spin_unlock(&old_base->lock);
	spin_unlock_irq(&new_base->lock);
	put_cpu_var(tvec_bases);
c103ad49:	b8 01 00 00 00       	mov    $0x1,%eax
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
		BUG_ON(tbase_get_base(timer->base) != base);
		internal_add_timer(base, timer);
c103ad4e:	e8 fc ff ff ff       	call   c103ad4f <timer_cpu_notify+0x217>
c103ad53:	89 e0                	mov    %esp,%eax

	/*
	 * We are removing _all_ timers from the list, so we
	 * don't have to detach them individually.
	 */
	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
c103ad55:	25 00 e0 ff ff       	and    $0xffffe000,%eax
c103ad5a:	8b 40 08             	mov    0x8(%eax),%eax
		BUG_ON(tbase_get_base(timer->base) != base);
		internal_add_timer(base, timer);
	}

	return index;
}
c103ad5d:	a8 08                	test   $0x8,%al
c103ad5f:	74 05                	je     c103ad66 <timer_cpu_notify+0x22e>
c103ad61:	e8 fc ff ff ff       	call   c103ad62 <timer_cpu_notify+0x22a>
c103ad66:	b8 01 00 00 00       	mov    $0x1,%eax
#endif
	default:
		break;
	}
	return NOTIFY_OK;
}
c103ad6b:	5b                   	pop    %ebx
c103ad6c:	5e                   	pop    %esi
c103ad6d:	5f                   	pop    %edi
c103ad6e:	5d                   	pop    %ebp
/**
 * timer_start - called when the timer is started
 * @timer:	pointer to struct timer_list
 * @expires:	the timers expiry time
 */
TRACE_EVENT(timer_start,
c103ad6f:	c3                   	ret

Disassembly of section .init.text:

c103ab38 <init_timers>:
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab38:	55                   	push   %ebp
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab39:	89 e5                	mov    %esp,%ebp
 * It's not worth to care about 3dnow prefetches for the K6
 * because they are microcoded there and very slow.
 */
static inline void prefetch(const void *x)
{
	alternative_input(BASE_PREFETCH,
c103ab3b:	53                   	push   %ebx
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab3c:	e8 fc ff ff ff       	call   c103ab3d <init_timers+0x5>
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab41:	ba 03 00 00 00       	mov    $0x3,%edx
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab46:	89 c1                	mov    %eax,%ecx
c103ab48:	b8 00 00 00 00       	mov    $0x0,%eax
	 * 3 jiffies. This 3 jiffies came originally from the mm/ code which
	 * already did this.
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;
c103ab4d:	e8 fc ff ff ff       	call   c103ab4e <init_timers+0x16>
c103ab52:	89 c3                	mov    %eax,%ebx

	rem = j % HZ;
c103ab54:	e8 fc ff ff ff       	call   c103ab55 <init_timers+0x1d>
	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
				(void *)(long)smp_processor_id());

	init_timer_stats();

	BUG_ON(err != NOTIFY_OK);
c103ab59:	4b                   	dec    %ebx
c103ab5a:	74 04                	je     c103ab60 <init_timers+0x28>
c103ab5c:	0f 0b                	ud2a
c103ab5e:	eb fe                	jmp    c103ab5e <init_timers+0x26>
	register_cpu_notifier(&timers_nb);
c103ab60:	b8 00 00 00 00       	mov    $0x0,%eax
c103ab65:	e8 fc ff ff ff       	call   c103ab66 <init_timers+0x2e>
	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
c103ab6a:	ba e0 16 00 00       	mov    $0x16e0,%edx
		j = j - rem + HZ;

	/* now that we have rounded, subtract the extra skew again */
	j -= cpu * 3;

	if (j <= jiffies) /* rounding ate our timeout entirely; */
c103ab6f:	b8 01 00 00 00       	mov    $0x1,%eax
	 * But never round down if @force_up is set.
	 */
	if (rem < HZ/4 && !force_up) /* round down */
		j = j - rem;
	else /* round up */
		j = j - rem + HZ;
c103ab74:	e8 fc ff ff ff       	call   c103ab75 <init_timers+0x3d>

	/* now that we have rounded, subtract the extra skew again */
	j -= cpu * 3;

	if (j <= jiffies) /* rounding ate our timeout entirely; */
c103ab79:	5b                   	pop    %ebx
c103ab7a:	5d                   	pop    %ebp
c103ab7b:	c3                   	ret

Disassembly of section .altinstr_replacement:

c103ab38 <.altinstr_replacement>:
				      tbase_get_deferrable(timer->base));
}

static unsigned long round_jiffies_common(unsigned long j, int cpu,
		bool force_up)
{
c103ab38:	0f 18 07             	prefetchnta (%edi)
c103ab3b:	0f 18 06             	prefetchnta (%esi)

Disassembly of section .sched.text:

c103ab38 <schedule_timeout>:
c103ab38:	55                   	push   %ebp
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab39:	89 e5                	mov    %esp,%ebp
c103ab3b:	56                   	push   %esi
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab3c:	89 c6                	mov    %eax,%esi
c103ab3e:	53                   	push   %ebx
c103ab3f:	83 ec 34             	sub    $0x34,%esp
signed long __sched schedule_timeout(signed long timeout)
{
	struct timer_list timer;
	unsigned long expire;

	switch (timeout)
c103ab42:	3d ff ff ff 7f       	cmp    $0x7fffffff,%eax
				unsigned long action, void *hcpu)
{
	long cpu = (long)hcpu;
	int err;

	switch(action) {
c103ab47:	75 07                	jne    c103ab50 <schedule_timeout+0x18>
		 * in the caller. Nothing more. We could take
		 * MAX_SCHEDULE_TIMEOUT from one of the negative value
		 * but I' d like to return a valid offset (>=0) to allow
		 * the caller to do everything it want with the retval.
		 */
		schedule();
c103ab49:	e8 fc ff ff ff       	call   c103ab4a <schedule_timeout+0x12>
		goto out;
c103ab4e:	eb 6a                	jmp    c103abba <schedule_timeout+0x82>
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;

	rem = j % HZ;
c103ab50:	85 c0                	test   %eax,%eax
	 * 3 jiffies. This 3 jiffies came originally from the mm/ code which
	 * already did this.
	 * The skew is done by adding 3*cpunr, then round, then subtract this
	 * extra offset again.
	 */
	j += cpu * 3;
c103ab52:	79 20                	jns    c103ab74 <schedule_timeout+0x3c>

	rem = j % HZ;
c103ab54:	50                   	push   %eax
c103ab55:	68 91 02 00 00       	push   $0x291
	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
				(void *)(long)smp_processor_id());

	init_timer_stats();

	BUG_ON(err != NOTIFY_OK);
c103ab5a:	e8 fc ff ff ff       	call   c103ab5b <schedule_timeout+0x23>
		 * that will tell you if something is gone wrong and where.
		 */
		if (timeout < 0) {
			printk(KERN_ERR "schedule_timeout: wrong timeout "
				"value %lx\n", timeout);
			dump_stack();
c103ab5f:	e8 fc ff ff ff       	call   c103ab60 <schedule_timeout+0x28>
c103ab64:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax

	init_timer_stats();

	BUG_ON(err != NOTIFY_OK);
	register_cpu_notifier(&timers_nb);
	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
c103ab6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (timeout < 0) {
			printk(KERN_ERR "schedule_timeout: wrong timeout "
				"value %lx\n", timeout);
			dump_stack();
			current->state = TASK_RUNNING;
			goto out;
c103ab70:	5a                   	pop    %edx
c103ab71:	59                   	pop    %ecx
c103ab72:	eb 46                	jmp    c103abba <schedule_timeout+0x82>
	 * But never round down if @force_up is set.
	 */
	if (rem < HZ/4 && !force_up) /* round down */
		j = j - rem;
	else /* round up */
		j = j - rem + HZ;
c103ab74:	a1 00 00 00 00       	mov    0x0,%eax

	/* now that we have rounded, subtract the extra skew again */
	j -= cpu * 3;

	if (j <= jiffies) /* rounding ate our timeout entirely; */
c103ab79:	8d 5d c4             	lea    -0x3c(%ebp),%ebx
c103ab7c:	31 c9                	xor    %ecx,%ecx
c103ab7e:	31 d2                	xor    %edx,%edx
		return original;
	return j;
}
c103ab80:	c7 45 d4 2c 1b 00 00 	movl   $0x1b2c,-0x2c(%ebp)
			current->state = TASK_RUNNING;
			goto out;
		}
	}

	expire = timeout + jiffies;
c103ab87:	01 c6                	add    %eax,%esi
c103ab89:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies(unsigned long j, int cpu)
{
	return round_jiffies_common(j, cpu, false);
}
c103ab8f:	89 45 d8             	mov    %eax,-0x28(%ebp)
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
c103ab92:	89 d8                	mov    %ebx,%eax
 * to lock contention or spurious cache line bouncing.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
c103ab94:	e8 fc ff ff ff       	call   c103ab95 <schedule_timeout+0x5d>
	}

	expire = timeout + jiffies;

	setup_timer_on_stack(&timer, process_timeout, (unsigned long)current);
	__mod_timer(&timer, expire, false, TIMER_NOT_PINNED);
c103ab99:	89 f2                	mov    %esi,%edx
c103ab9b:	31 c9                	xor    %ecx,%ecx
unsigned long __round_jiffies_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
c103ab9d:	89 d8                	mov    %ebx,%eax
			 * The APs use this path later in boot
			 */
			base = kmalloc_node(sizeof(*base),
						GFP_KERNEL | __GFP_ZERO,
						cpu_to_node(cpu));
			if (!base)
c103ab9f:	6a 00                	push   $0x0

		if (boot_done) {
			/*
			 * The APs use this path later in boot
			 */
			base = kmalloc_node(sizeof(*base),
c103aba1:	e8 17 1e 00 00       	call   c103c9bd <__mod_timer+0x6a>
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, false) - j0;
}
c103aba6:	e8 fc ff ff ff       	call   c103aba7 <schedule_timeout+0x6f>
	expire = timeout + jiffies;

	setup_timer_on_stack(&timer, process_timeout, (unsigned long)current);
	__mod_timer(&timer, expire, false, TIMER_NOT_PINNED);
	schedule();
	del_singleshot_timer_sync(&timer);
c103abab:	89 d8                	mov    %ebx,%eax
						cpu_to_node(cpu));
			if (!base)
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
c103abad:	e8 fc ff ff ff       	call   c103abae <schedule_timeout+0x76>
	del_singleshot_timer_sync(&timer);

	/* Remove the timer from the object tracker */
	destroy_timer_on_stack(&timer);

	timeout = expire - jiffies;
c103abb2:	a1 00 00 00 00       	mov    0x0,%eax
			if (!base)
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
c103abb7:	29 c6                	sub    %eax,%esi
c103abb9:	58                   	pop    %eax
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), false);
}
c103abba:	31 c0                	xor    %eax,%eax
 * of this is to have the CPU wake up less, which saves power.
 *
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
c103abbc:	85 f6                	test   %esi,%esi
c103abbe:	0f 49 c6             	cmovns %esi,%eax

	timeout = expire - jiffies;

 out:
	return timeout < 0 ? 0 : timeout;
}
c103abc1:	8d 65 f8             	lea    -0x8(%ebp),%esp
				return -ENOMEM;

			/* Make sure that tvec_base is 2 byte aligned */
			if (tbase_get_deferrable(base)) {
				WARN_ON(1);
				kfree(base);
c103abc4:	5b                   	pop    %ebx
c103abc5:	5e                   	pop    %esi
c103abc6:	5d                   	pop    %ebp
c103abc7:	c3                   	ret

c103abc8 <schedule_timeout_uninterruptible>:
	return schedule_timeout(timeout);
}
EXPORT_SYMBOL(schedule_timeout_killable);

signed long __sched schedule_timeout_uninterruptible(signed long timeout)
{
c103abc8:	55                   	push   %ebp
c103abc9:	89 e5                	mov    %esp,%ebp
 * The return value is the rounded version of the @j parameter.
 */
unsigned long round_jiffies_relative(unsigned long j)
{
	return __round_jiffies_relative(j, raw_smp_processor_id());
}
c103abcb:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
}
EXPORT_SYMBOL(schedule_timeout_killable);

signed long __sched schedule_timeout_uninterruptible(signed long timeout)
{
	__set_current_state(TASK_UNINTERRUPTIBLE);
c103abd2:	c7 02 02 00 00 00    	movl   $0x2,(%edx)
	return schedule_timeout(timeout);
c103abd8:	e8 fc ff ff ff       	call   c103abd9 <schedule_timeout_uninterruptible+0x11>
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
c103abdd:	5d                   	pop    %ebp
c103abde:	c3                   	ret

c103abdf <schedule_timeout_killable>:
	return schedule_timeout(timeout);
}
EXPORT_SYMBOL(schedule_timeout_interruptible);

signed long __sched schedule_timeout_killable(signed long timeout)
{
c103abdf:	55                   	push   %ebp
c103abe0:	89 e5                	mov    %esp,%ebp
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)
{
c103abe2:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
}
EXPORT_SYMBOL(schedule_timeout_interruptible);

signed long __sched schedule_timeout_killable(signed long timeout)
{
	__set_current_state(TASK_KILLABLE);
c103abe9:	c7 02 82 00 00 00    	movl   $0x82,(%edx)
	return schedule_timeout(timeout);
c103abef:	e8 fc ff ff ff       	call   c103abf0 <schedule_timeout_killable+0x11>
{
	unsigned long j0 = jiffies;

	/* Use j0 because jiffies might change while we run */
	return round_jiffies_common(j + j0, cpu, true) - j0;
}
c103abf4:	5d                   	pop    %ebp
c103abf5:	c3                   	ret

c103abf6 <schedule_timeout_interruptible>:
/*
 * We can use __set_current_state() here because schedule_timeout() calls
 * schedule() unconditionally.
 */
signed long __sched schedule_timeout_interruptible(signed long timeout)
{
c103abf6:	55                   	push   %ebp
 * round down.  This is useful for timeouts for which the exact time
 * of firing does not matter too much, as long as they don't fire too
 * early.
 */
unsigned long round_jiffies_up(unsigned long j)
{
c103abf7:	89 e5                	mov    %esp,%ebp
c103abf9:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
 * We can use __set_current_state() here because schedule_timeout() calls
 * schedule() unconditionally.
 */
signed long __sched schedule_timeout_interruptible(signed long timeout)
{
	__set_current_state(TASK_INTERRUPTIBLE);
c103ac00:	c7 02 01 00 00 00    	movl   $0x1,(%edx)
	return schedule_timeout(timeout);
c103ac06:	e8 fc ff ff ff       	call   c103ac07 <schedule_timeout_interruptible+0x11>
 * early.
 */
unsigned long round_jiffies_up(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), true);
}
c103ac0b:	5d                   	pop    %ebp
c103ac0c:	c3                   	ret
```

記錄分析oops所在static函數__next_timer_interrupt的彙編如下：

```sh

77e: movzbl %al, %ecx
781: mov %ecx, %esi
783: lea 0x10(%ebx, %esi, 8), %edi
787: mov 0x10(%ebx, %esi, 8), %edx
78b: %edi, -0x24(%ebp)
78e: jmp 0x7b0
= =b> %esi指timer_jiffies & 0xff; 0x10指tvec_base到tv1的偏移量;
  lea後%edi為tv1.vec[%esi]的地址, struct *list_head類型;
  mov後%edx為該地址所存儲數字的值, 對應list_head->next，下一鏈表的首地址;

790: testb $0x1, 0xc(%edx)
794: je 0x79a
= =b> %edx指nte，如果(nte->base & 1) == 0，跳到0x79a，表示got not deferrable

796: mov %edi, %edx
798: jmp 0x7b0
= =b> %edi為prefetch了的鏈表頭，為struct *list_head類型，下一遍歷經過的鏈表頭

79a: cmp %ecx, %esi
79c: mov 0x8(%edx), %edx
79f: jl 0x7a9
= =b> %ecx指index，%esi指slot，如果slot比index小則跳到0x7a9; 0x8(%edx)指nte->expires

7a1: test %ecx, %ecx
7a3: jne 0x88d
= =b> %ecx指index，如果(index & index) != 0即index != 0，則跳到0x88d

7a9: mov $0x1, %edi
7ae: jmp 0x7ce
= =b> 這裡是猜的，這裡%edi變成了found = 1?將要跳到cascade

7b0: mov (%edx), %edi
7b2: lea 0x0(%esi, %eiz, 1), %esi
7b6: cmp -0x24(%ebp), %edx
7b9: jne 0x790
= =b> 想了解lea eiz的朋友，讀這篇文章吧 http://www.technovelty.org/arch/the-quickest-way-to-do-nothing.html
  -0x24(%ebp)為0x78b所存儲的首鏈表地址，如果鏈表沒遍歷完則跳到0x790

7bb: inc %esi
7bc: and $0xff, %esi
7c2: cmp %ecx %esi
7c4: jne 0x783
= =b> %esi指slot, %ecx指index，index與(slot+1) & 0xff比較，如果不同則跳到0x783

7ce: test %ecx, %ecx
7d0: je 0x7d9
= =b> 如果index為0，跳到0x7d9

7d2: add $0x100, %eax
7d7: sub %ecx, %eax
7d9: shr 0x08, %eax
7dc: mov %eax, -0x24(%ebp)
= =b> %ecx指index，%eax指timer_jiffies，timer_jiffies += 0x100 - index，然後將其右移8位

7df: lea 0x810(%ebx), %eax
7e5: mov %eax, -0x1c(%ebp)
7e8: lea 0xa10(%ebx), %eax
7ee: mov %eax, -0x18(%ebp)
7f1: lea 0xc10(%ebx), %eax
7f7: mov %eax, -0x14(%ebp)
7fa: lea 0xe10(%ebx), %eax
800: mov %eax, -0x10(%ebp)
= =b> -0x1c(%ebp)為varray[0]，-0x18(%ebp)為varray[1]，-0x14(%ebp)為varray[2]，
  -0x10(%ebp)為varray[3]

803: movl $0x0, -0x28(%ebp)
80a: mov %ebx, -0x34(%ebp)
80d: mov -0x28(%ebp), %eax
810: mov -0x24(%ebp), %ecx
813: mov -0x1c(%ebp, %eax, 4), %eax
817: and $0x3f, %ecx
81a: mov %eax, -0x30(%ebp)
= =b> %eax是varray[x]的值, %ecx是timer_jiffies即index; -0x34(%ebp)保存base，
  -0x30(%ebp)保存varray[x]，-0x28(%ebp)保存varray的下標，-0x24(%ebp)保存timer_jiffies

81d: mov %ecx, %eax
81f: mov -0x30(%ebp), %esi
822: mov (%esi, %eax, 8), %ebx
825: lea (%esi, %eax, 8), %esi
828: %esi, -0x38(%ebp)
82b: jmp 0x847
= =b> varray[x]保存struct tvec *類型，tvec裡第timer_jiffies個list_head的地址保存在%esi，
  list_head->next的值保存在%ebx，-0x38(%ebp)保存list_head這個鏈表頭以進行遍歷

82d: testb $0x1, 0xc(%ebx)
831: mov %edx, %esi
833: jne 0x842
= =b> %ebx指nte，0xc(%ebx)指nte->base; 如果(nte->base & 1) == 1,跳到0x842,表示got deferrable;
  %edx為expires

835: mov 0x8(%ebx), %esi
838: mov $0x1, %edi
83d: cmp %edx, %esi
83f: cmovns %edx, %esi
= =b> %ebx是list_head的地址，嵌套於sturct timer_list *類型中，所以%0x8(%ebx)指timer_list.expires;
  %edx指expires, %edi是found, %esi是nte->expires; 如果nte->expires大於或等於expires，%esi代替為expires

842: mov -0x2c(%ebp), %ebx
845: mov %esi, %edx
= =b> 參考0x847的註釋，%ebx賦值為下一鏈表頭地址; %esi在這裡是expires

847: mov (%ebx), %esi
849: mov %esi, -0x2c(%ebp)
84c: lea 0x0(%esi, %eiz, 1)
850: cmp -0x38(%ebp), %ebx
853: jne 0x82d
= =b> 這裡的代碼跟0x7b0非常像; %ebx是下一鏈表頭的地址，%esi為下下一鏈表頭的地址，
  -0x2c(%ebp)保存下下一鏈表頭地址; 比較是否遍歷到最早那個鏈表頭，否則跳到0x82d

855: test %edi, %edi
857: je 0x868
= =b> %edi指found，如果沒有找到則跳到0x868

859: cmp %ecx, %eax
85b: jl 0x861
= =b> %ecx指index，%eax指slot，如果slot比index小，跳到0x861

85d: test %ecx, %ecx
85f: jne 0x88a
= =b> 如果index不為0，跳到0x88a

861: mov $0x1, %edi
866: jmp 0x870
= =b> 這裡%edi指found?猜的

868: inc %eax
869: and $0x3f, %eax
86c: cmp %ecx, %eax
86e: jne 0x81f
= =b> %eax指slot，%ecx指index，如果不相等則跳到0x81f

870: test %ecx, %ecx
872: je 0x87b
= =b> 如果index等於0跳到0x87b

874: addl $0x40, -0x24(%ebp)
878: sub %ecx, -0x24(%ebp)
= =b> -0x24(%ebp)保存timer_jiffies，%ecx為index

87b: incl -0x28(%ebp)
87e: cmpl $0x4, -0x28(%ebp)
882: je 0x88a
= =b> -0x28(%ebp)為varray[x]的下標，如果下標達到4跳到0x88a

884: shrl $0x6, -0x24(%ebp)
888: jmp 0x80d
= =b> -0x24(%ebp)保存timer_jiffies

88a: mov -0x34(%ebp), %ebx
88d: mov %edx, 0xc(%ebx)
890: mov 0xc(%ebx), %esi
893: mov %ebx, %eax
895: call 0xc14ce8e2 <_raw_spin_unlock>
= =b> 0xc(%ebx)指base->next_timer，-0x34(%ebp)保存了base，%edx指expires
```
機器碼8b 33所在的地址為0xc103c847
