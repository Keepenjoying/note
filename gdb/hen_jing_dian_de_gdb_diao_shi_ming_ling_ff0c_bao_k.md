# 很經典的GDB調試命令，包括查看變量，查看內存


笑笑小白
歸類自己需要的資料，慢慢爬行
很經典的GDB調試命令，包括查看變量，查看內存

在你調試程序時，當程序被停住時，你可以使用print命令（簡寫命令為p），或是同義命令inspect來查看當前程序的運行數據。print命令的格式是：
print
print /
是表達式，是你所調試的程序的語言的表達式（GDB可以調試多種編程語言），是輸出的格式，比如，如果要把表達式按16進制的格式輸出，那麼就是/x。

##一、表達式
print和許多GDB的命令一樣，可以接受一個表達式，GDB會根據當前的程序運行的數據來計算這個表達式，既然是表達式，那麼就可以是當前程序運行中的const常量、變量、函數等內容。可惜的是GDB不能使用你在程序中所定義的宏。
表達式的語法應該是當前所調試的語言的語法，由於C/C++是一種大眾型的語言，所以，本文中的例子都是關於C/C++的。（而關於用GDB調試其它語言的章節，我將在後面介紹）
在表達式中，有幾種GDB所支持的操作符，它們可以用在任何一種語言中。
```
@
```
是一個和數組有關的操作符，在後面會有更詳細的說明。
```
::
```
指定一個在文件或是一個函數中的變量。
```
{}
```
表示一個指向內存地址的類型為type的一個對象。


##二、程序變量
在GDB中，你可以隨時查看以下三種變量的值：
```
1、全局變量（所有文件可見的）
2、靜態全局變量（當前文件可見的）
3、局部變量（當前Scope可見的）
```

如果你的局部變量和全局變量發生衝突（也就是`重名`），一般情況下是局部變量會隱藏全局變量，也就是說，如果一個全局變量和一個函數中的局部變量同名時，如果當前停止點在函數中，用print顯示出的變量的值會是函數中的局部變量的值。如果此時你想查看`全局變量`的值時，你可以使用`::`操作符：
```
file::variable
function::variable
```

可以通過這種形式指定你所想查看的變量，是哪個文件中的或是哪個函數中的。例如，查看文件f2.c中的全局變量x的值：

```
gdb) p 'f2.c'::x
```

當然，`::`操作符會和C++中的發生衝突，GDB能自動識別`::` 是否C++的操作符，所以你不必擔心在調試C++程序時會出現異常。

另外，需要注意的是，如果你的程序編譯時開啟了優化選項，那麼在用GDB調試被優化過的程序時，可能會發生某些變量不能訪問，或是取值錯誤碼的情況。這個是很正常的，因為優化程序會刪改你的程序，整理你程序的語句順序，剔除一些無意義的變量等，所以在GDB調試這種程序時，運行時的指令和你所編寫指令就有不一樣，也就會出現你所想象不到的結果。對付這種情況時，需要在編譯程序時關閉編譯優化。一般來說，幾乎所有的編譯器都支持編譯優化的開關，例如，GNU 的C/C++編譯器GCC，你可以使用“-gstabs”選項來解決這個問題。關於編譯器的參數，還請查看編譯器的使用說明文檔。

##三、數組

有時候，你需要查看一段連續的內存空間的值。比如數組的一段，或是動態分配的數據的大小。你可以使用GDB的`@`操作符，`@`的左邊是第一個內存的地址的值，`@`的右邊則你你想查看內存的長度。例如，你的程序中有這樣的語句：
```c
int *array = (int *) malloc (len * sizeof (int));
```

於是，在GDB調試過程中，你可以以如下命令顯示出這個動態數組的取值：
```c
p *array@len
```

`@`的左邊是數組的首地址的值，也就是變量array所指向的內容，右邊則是數據的長度，其保存在變量len中，其輸出結果，大約是下面這個樣子的：
```sh
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
```

如果是靜態數組的話，可以直接用print數組名，就可以顯示數組中所有數據的內容了。


##四、輸出格式
一般來說，GDB會根據變量的類型輸出變量的值。但你也可以自定義GDB的輸出的格式。例如，你想輸出一個整數的十六進制，或是二進制來查看這個整型變量的中的位的情況。要做到這樣，你可以使用GDB的數據顯示格式：

```sh
x 按十六進制格式顯示變量。
d 按十進制格式顯示變量。
u 按十六進制格式顯示無符號整型。
o 按八進制格式顯示變量。
t 按二進制格式顯示變量。
a 按十六進制格式顯示變量。
c 按字符格式顯示變量。
f 按浮點數格式顯示變量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 'e'
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101
```
##五、查看內存
你可以使用examine命令（簡寫是x）來查看內存地址中的值。x命令的語法如下所示：
```
x/n、f、u是可選的參數。
```

- n 是一個正整數，表示顯示內存的長度，也就是說從當前地址向後顯示幾個地址的內容。
- f 表示顯示的格式，參見上面。如果地址所指的是字符串，那麼格式可以是s，如果地十是指令地址，那麼格式可以是i。
- u 表示從當前地址往後請求的字節數，如果不指定的話，GDB默認是4個bytes。u參數可以用下面的字符來代替，b表示單字節，h表示雙字節，w表示四字節，g表示八字節。當我們指定了字節長度後，GDB會從指內存定的內存地址開始，讀寫指定字節，並把其當作一個值取出來。

表示一個內存地址。

n/f/u三個參數可以一起使用。例如：
```sh
命令：x/3uh 0x54320 
```

表示，從內存地址0x54320讀取內容，h表示以雙字節為一個單位，3表示三個單位，u表示按十六進制顯示。

##六、自動顯示
你可以設置一些自動顯示的變量，當程序停住時，或是在你單步跟蹤時，這些變量會自動顯示。相關的GDB命令是display。


display/expr是一個表達式，fmt表示顯示的格式，addr表示內存地址，當你用display設定好了一個或多個表達式後，只要你的程序被停下來，GDB會自動顯示你所設置的這些表達式的值。
格式i和s同樣被display支持，一個非常有用的命令是：
```sh
display/i $pc
```

$pc是GDB的環境變量，表示著指令的地址，`/i則表示輸出格式為機器指令碼`，也就是`彙編`。於是當程序停下後，就會出現源代碼和機器指令碼相對應的情形，這是一個很有意思的功能。
下面是一些和display相關的GDB命令：
```sh
undisplay
delete display
刪除自動顯示
```

，dnums意為所設置好了的自動顯式的編號。如果要同時刪除幾個，編號可以用空格分隔，如果要刪除一個範圍內的編號，可以用減號表示（如：2-5）
```sh
disable display
enable display
```

disable和enalbe不刪除自動顯示的設置，而只是讓其失效和恢復。
```sh
info display
```

查看display設置的自動顯示的信息。GDB會打出一張表格，向你報告當然調試中設置了多少個自動顯示設置，其中包括，設置的編號，表達式，是否enable。

##七、設置顯示選項
GDB中關於顯示的選項比較多，這裡我只例舉大多數常用的選項。
```sh
set print address
set print address on
```

打開地址輸出，當程序顯示函數信息時，GDB會顯出函數的參數地址。系統默認為打開的，如：
```
(gdb) f
#0 set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
at input.c:530
530 if (lquote != def_lquote)
```
```
set print address off
```
關閉函數的參數地址顯示，如：

```sh
(gdb) set print addr off
(gdb) f
#0 set_quotes (lq="<<", rq=">>") at input.c:530
530 if (lquote != def_lquote)
```

```sh
show print address
```

查看當前地址顯示選項是否打開。

```sh
set print array
set print array on
```

打開數組顯示，打開後當數組顯示時，每個元素佔一行，如果不打開的話，每個元素則以逗號分隔。這個選項默認是關閉的。與之相關的兩個命令如下，我就不再多說了。
```sh
set print array off
show print array
set print elements
```

這個選項主要是設置數組的，如果你的數組太大了，那麼就可以指定一個來指定數據顯示的最大長度，當到達這個長度時，GDB就不再往下顯示了。如果設置為0，則表示不限制。

```sh
show print elements
```

查看print elements的選項信息。
```sh
set print null-stop
```

如果打開了這個選項，那麼當顯示字符串時，遇到結束符則停止顯示。這個選項默認為off。

```sh
set print pretty on
```

如果打開printf pretty這個選項，那麼當GDB顯示結構體時會比較漂亮。如：

```sh
$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 "Pork"
}
```

```sh
set print pretty off
```

關閉printf pretty這個選項，GDB顯示結構體時會如下顯示：
```sh
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54 "Pork"}
show print pretty
```

查看GDB是如何顯示結構體的。

```sh
set print sevenbit-strings
```

設置字符顯示，是否按“\nnn”的格式顯示，如果打開，則字符串或字符數據按\nnn顯示，如“65”。
```sh
show print sevenbit-strings
```

查看字符顯示開關是否打開。
```sh
set print union
```

設置顯示結構體時，是否顯式其內的聯合體數據。例如有以下數據結構：

```sh
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
Bug_forms;
struct thing {
Species it;
union {
Tree_forms tree;
Bug_forms bug;
} form;
};
```
```sh
struct thing foo = {Tree, {Acorn}};
```

當打開這個開關時，執行 p foo 命令後，會如下顯示：
```sh
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
```

當關閉這個開關時，執行 p foo 命令後，會如下顯示：
```sh
$1 = {it = Tree, form = {...}}
```
```sh
show print union
```

查看聯合體數據的顯示方式
set print object
在C++中，如果一個對象指針指向其派生類，如果打開這個選項，GDB會自動按照虛方法調用的規則顯示輸出，如果關閉這個選項的話，GDB就不管虛函數表了。這個選項默認是off。
```sh
show print object
```

查看對象選項的設置。
```sh
set print static-members
```

這個選項表示，當顯示一個C++對象中的內容是，是否顯示其中的靜態數據成員。`默認是on`。

```sh
show print static-members
```

查看靜態數據成員選項設置。
```sh
set print vtbl
```

當此選項打開時，GDB將用比較規整的格式來顯示虛函數表時。其默認是關閉的。
```sh
show print vtbl
```

查看虛函數顯示格式的選項。


##八、歷史記錄
當你用GDB的print查看程序運行時的數據時，你每一個print都會被GDB記錄下來。GDB會以$1, $2, $3 .....這樣的方式為你每一個print命令編上號。於是，你可以使用這個編號訪問以前的表達式，如$1。這個功能所帶來的好處是，如果你先前輸入了一個比較長的表達式，如果你還想查看這個表達式的值，你可以使用歷史記錄來訪問，省去了重複輸入。

##九、GDB環境變量
你可以在GDB的調試環境中定義自己的變量，用來保存一些調試程序中的運行數據。要定義一個GDB的變量很簡單隻需。使用GDB的`set命令`。GDB的環境變量和UNIX一樣，也是以$起頭。如：
```sh
set $foo = *object_ptr
```

使用環境變量時，GDB會在你第一次使用時創建這個變量，而在以後的使用中，則直接對其賦值。環境變量沒有類型，你可以給環境變量定義任一的類型。包括結構體和數組。
```sh
show convenience
```

該命令查看當前所設置的所有的環境變量。
這是一個比較強大的功能，環境變量和程序變量的交互使用，將使得程序調試更為靈活便捷。例如：
```sh
set $i = 0
print bar[$i++]->contents
```

於是，當你就不必，
```sh
print bar[0]->contents
print bar[1]->contents
```

地輸入命令了。輸入這樣的命令後，只用敲回車，重複執行上一條語句，環境變量會自動累加，從而完成逐個輸出的功能。

##十、查看寄存器
要查看寄存器的值，很簡單，可以使用如下命令：
```sh
info registers
```

查看寄存器的情況。（除了浮點寄存器）
```sh
info all-registers
```

查看所有寄存器的情況。（包括浮點寄存器）
```sh
info registers
```

查看所指定的寄存器的情況。
寄存器中放置了程序運行時的數據，`比如程序當前運行的指令地址（ip）`，程序的`當前堆棧地址（sp）`等等。你同樣可以使用print命令來訪問寄存器的情況，只需要在寄存器名字前加一個$符號就可以了。如：
```sh
p $eip。
```