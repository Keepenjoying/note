# 通過 GDB 學習 C 語言


對於那些具有高級編程語言諸如： Ruby、Scheme、Haskell 等背景的人來說，學習 C 語言是具有挑戰性的。除了糾結於 C  語言中像手動內存管理和指針等底層特性外，你必須在沒有 REPL ( Read-Eval-Print Loop ) 的條件下完成工作。一旦你已經習慣於在 REPL 環境下進行探索性的編程，必須進行「編寫-編譯-運行」這樣循環實在有點令人生厭。

最近我發現其實可以用 GDB 來作為 C 語言的偽 REPL。我一直嘗試使用 GDB 作為學習 C 語言的工具，而不僅僅是用來調試 C 程序，事實上這非常有趣。

這篇文章我的目的就是向你展示 GDB 是一個非常好的學習 C 語言工具。下面我將會向你介紹一些我最喜歡的 GDB 命令，然後我會向你闡述怎樣使用 GDB 來理解 C 語言中一個出了名的複雜問題：數組和指針的區別。



##GDB 簡介

從創建一個簡單的 C 程序開始，minimal.c:

```c
int main()
{ 
   int i = 1337;
   return 0; 
}
```

注意這個程序並沒有做任何事情，也沒有一條輸出指令。擁抱使用 GDB 學習 C 語言的美麗新世界吧！

使用 -g 參數進行編譯，這樣會生成一些有助於 debug，gdb 可以利用的信息，編譯後用 GDB 運行起來：

```sh
$ gcc -g minimal.c -o minimal 
$ gdb minimal
```

你現在應該能看到明顯的 GDB 提示行。我之前告訴你這是一個 REPL，下面我們就來試試：

```sh
(gdb) print 1 + 2 
$1 = 3
```
多麼神奇！ print 是 GDB 的內置命令，他能夠打印出一個 C 語言命令的返回值。如果你不確定一個 GDB 命令是做什麼，嘗試在 GDB 提示下運行命令 help。

然後是一個更有趣的例子：

```sh
(gdb) print (int) 2147483648
$2 = -2147483648
```

這裡我先忽略為什麼 2147483648 == -2147483648；我想要說明的是即使是算術運算在 C 語言中也是有很多坑的，GDB 能夠理解運行 C 語言中的算術運算。

現在讓我們在主函數中設置一個斷點然後運行程序：

```c
(gdb) break main
(gdb) run
```
現在程序在第 3 行處暫停，正好在 i 進行初始化之前。有趣的是，儘管 i 還沒有被初始化，我們依然能夠使用 print 命令看到它的值。

```c
(gdb) print i
$3 = 32767
```
在 C 語言中，一個未被初始化的局部變量的值是沒有定義的，所以你用 GDB 打印出的值可能與這裡的不一樣。

我們可以用 next 命令來執行當前斷點這一行：

```c
(gdb) next
(gdb) print i
$4 = 1337
```

###使用 x 命令檢查內存

在 C 語言中變量用來標示一塊連續的內存區間。一個變量的內存區間由兩個數字決定：

- 這塊內存第一個字節數的數值地址

- 內存的大小，單位是字節。變量所佔內容的大小取決於變量的類型。
C 語言中一個獨特的特性是你能夠直接訪問變量所佔的內存。操作符 & 可以計算一個變量的地址，操作符 sizeof 計算變量所佔內存的大小。

你可以在 GDB 中測試以上兩個概念：



```c
(gdb) print &i
$5 = (int *) 0x7fff5fbff584
(gdb) print sizeof(i)
$6 = 4
```

字面上看，i 所佔內存起始於地址 0x7fff5fbff5b4，佔內存 4 個字節。

我前面提到的變量在內存中的大小取決於它的類型，所以操作符 sizeof 能夠直接作用於類型：

```sh
(gdb) print sizeof(int)
$7 = 4
(gdb) print sizeof(double)
$8 = 8
```

以上顯示意味著，至少在我的計算機上 int 變量佔 4 個字節空間，double 變量佔 8 個字節。

GDB 帶來了一個功能強大的工具，能夠直接檢測內存：x 命令。x 命令從一個特定的地址開始檢測內存。結合一些結構化的命令和這些已給的命令能精確控制你想檢測多少字節，你想怎樣打印它們。當你有疑問時，嘗試在 GDB 提示下運行 help x。

& 操作符計算變量的地址，這意味著我們能將 &i 返回給 x，從而看到 i 值背後原始的字節。

```sh
(gdb) x/4xb &i
0x7fff5fbff584: 0x39    0x05    0x00    0x00
```

標識參數表示我想要檢查 4 個值，格式是十六進制，一次顯示一個字節。我選擇檢查 4 個字節，是因為 i 在內存中的大小是 4 字節；逐字節打印出 i 在內存中的表示。

在 Intel 機器上有一個坑應當記得，逐字節檢測時字節數是以「小端」順序保存：不像人類一般使用的標記方法，一個數字的低位在內存中排在前面（個位數在十位數之前）。

為了讓這個問題更加明顯，我們可以為 i 賦一個特別的值，然後重新檢測所佔內存。


```sh
(gdb) set var i = 0x12345678
(gdb) x/4xb &i
0x7fff5fbff584: 0x78 0x56 0x34 0x12
```

##使用 ptype 檢查類型

ptype 命令可能是我最喜愛的命令。它告訴你一個 C 語言表達式的類型。


```c
(gdb) ptype i
type = int
(gdb) ptype &i
type = int *
(gdb) ptype main
type = int (void)
```
C 語言中的類型可以變得很複雜，但是好在 ptype 允許你交互式地查看他們。

##指針和數組

數組在C語言中是非常難以捉摸的概念。這節的計畫是寫出一個簡單的程序，然後在 GDB 中運行，直至它的意義變得清晰易懂。

編寫如下的程序，array.c:

```c
int main()
{
    int a[] = {1,2,3};
    return 0;
}
```
使用 -g 作為命令行參數進行編譯，在 GDB 中運行，然後輸入 next，執行初始化那一行

```sh
$ gcc -g arrays.c -o arrays
$ gdb arrays
(gdb) break main
(gdb) run
(gdb) next
```
在這裡，你應該能夠打印出 a 的內容並檢查它的類型：


```sh
(gdb) print a
$1 = {1, 2, 3}
(gdb) ptype a
type = int [3]
```

現在我們的程序已經在 GDB 中運行起來了，我們應該做的第一件事是使用 x 看看 a 在內存中是什麼樣子。

```sh
(gdb) x/12xb &a
0x7fff5fbff56c: 0x01  0x00  0x00  0x00  0x02  0x00  0x00  0x00
0x7fff5fbff574: 0x03  0x00  0x00  0x00
```

以上意思是 a 所佔內存開始於地址 0x7fff5fbff5dc。起始的四個字節存儲 a[0], 隨後的四個字節存儲 a[1], 最後的四個字節存儲 a[2]。事實上你可以通過 sizeof 得到，a 在內存中的大小是 12 字節。

```sh
(gdb) print sizeof(a)
$2 = 12
```
現在，數組好像確實有個數組的樣子。他們有自己的數組類型，在連續的內存空間中存儲自己的成員。然而在某些情況下，數組表現得更像指針。例如，我們能在 a 上進行指針運算。


```sh
= preserve do
  :escaped
    (gdb) print a + 1
    $3 = (int *) 0x7fff5fbff570
```

字面上看，a+1 是一個指向 int 的指針，佔據地址 0x7fff5fbff570。這時，你應該反過來將指針傳遞給 x 命令，讓我們看看會發生什麼：


```c
= preserve do
  :escaped
    (gdb) x/4xb a + 1
    0x7fff5fbff570: 0x02  0x00  0x00  0x00
```

注意 0x7fff5fbff570 比 0x7fff5fbff56c 大 4，後者是 a 在內存地址中的第一個字節。考慮到 int 值佔 4 字節，這意味著 a+1 指向 a[1].

事實上，在 C 語言中數組索引是指針運算的語法糖：a[i] 等於 *(a+i)。你可以在 GDB 中嘗試一下。

```sh
= preserve do
  :escaped
    (gdb) print a[0]
    $4 = 1
    (gdb) print *(a + 0)
    $5 = 1
    (gdb) print a[1]
    $6 = 2
    (gdb) print *(a + 1)
    $7 = 2
    (gdb) print a[2]
    $8 = 3
    (gdb) print *(a + 2)
    $9 = 3
```

我們已經看到在某些情況下，a 表現的像一個數組，在另一些情況下表現得像一個指向它首元素的指針。接下來會發生什麼呢？

答案是當一個數組名在 C 語言表達式中使用時，它「退化」成指向這個數組首元素的指針。這個規則只有兩個例外：當數組名傳遞給 sizeof 函數時，當數組名傳遞給操作數 & 時。

事實上，a 在傳遞給操作數 & 時並沒有「退化」成一個指針，這就帶來一個有趣的問題：由「退化」變成的指針和 &a 存在區別嗎？

數值上講，他們都表示相同的地址：

```sh
= preserve do
  :escaped
    (gdb) x/4xb a
    0x7fff5fbff56c: 0x01  0x00  0x00  0x00
    (gdb) x/4xb &a
    0x7fff5fbff56c: 0x01  0x00  0x00  0x00
```
然而，他們的類型是不同的。我們已經看到 a 退化的值是指向 a首元素的指針；這個必須是類型 int *。對於類型 &a，我們可以直接詢問 GDB：

```sh
= preserve do
  :escaped
    (gdb) ptype &a
    type = int (*)[3]
```

從顯示上看，&a 是一個指向 3 個整數數組的指針。這就說明：當傳遞給 & 時，a 沒有退化，a 有了一個類型，是 int[3]。

通過測試他們在指針運算時的表現，你可以觀察到 a 的退化值和 &a 的明顯區別。


```sh
= preserve do
  :escaped
    (gdb) print a + 1
    $10 = (int *) 0x7fff5fbff570
    (gdb) print &a + 1
    $11 = (int (*)[3]) 0x7fff5fbff578
```

注意到對 a 增加 1 等於對 a 的地址增加 4，與此同時，對 &a 增加 1 等於對 a 的地址增加 12！

實際上 a 退化成的指針是 &a[0];

```sh
= preserve do
  :escaped
    (gdb) print &a[0]
    $11 = (int *) 0x7fff5fbff56c
```


結論

希望我已經向你證明 GDB 是學習 C 語言的一個靈巧而有富有探索性的環境。你能使用 print 打印表達式的值，使用 x 查看內存中原始字節，使用 ptype 配合類型系統進行問題修補。

如果你想要進一步對使用 GDB 學習 C 語言進行嘗試，我有一些建議如下：

- 用 gdb 通過 Ksplice 指針挑戰。
- 研究結構體是怎樣在內存中存儲的？ 他們與數組比較又有什麼異同？
- 使用 GDB 的 disassemble 命令學習彙編語言！一個特別有趣的練習是研究函數調用棧是如何工作的。
- 試試 GDB 的 「 tui 」模式，這個模式在常規 GDB 頂層提供一個圖像化的 ncurses 層(Ncurses 提供字符終端處理庫，包括面板和菜單）。在 OS X 系統中，你可能需要用源代碼安裝 GDB。


Alan 是 Hacker School 的推廣者。他想要感謝 David Albert、Tom Ballinger、Nicholas Bergson-Shilcock 和 Amy Dyer 給予非常有幫助的反饋。


