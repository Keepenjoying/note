##shell十三問之8: $(())與$()還有${}差在哪？
---

我們上一章介紹了()與{}的不同，
這次讓我們擴展一下，看看更多的變化：
$()與${}又是啥玩意兒呢？

在bash shell中, `$()`與\`\`(反引號)都是用來做
`命令替換`(command substitution)的。

所謂的`命令替換`與我們第五章學過的變量替換差不多，
都是用來`重組命令行`：
完成 \`\` 或者`$()`裡面的
命令，將其結果替換出來，
再重組命令行。

例如：
```shell
$ echo the last sunday is $(date -d "last sunday" +%Y-%m-%d)
```
如此便可方便得到上一個星期天的日期了...^_^

在操作上， 用$()或\`\`都無所謂,
只是我個人比較喜歡用$(),理由是：

1. \`\`(反引號)很容易與''(單引號)搞混亂，尤其對初學者來說。
    有時在一些奇怪的字形顯示中，兩種符號是一模一樣的(只取兩點)。
	當然了有經驗的朋友還是一眼就能分辨兩者。只是，若能更好的避免混亂，
	又何樂而不為呢？ ^_^

2.  在多次的複合替換中， \`\`需要額外的轉義(escape, \)處理，而$()則比較直觀。
例如，一個錯誤的使用的例子：
```shell
	command1 `command2 `command3` `
```
原來的本意是要在command2 \`command3\` ,
先將command3替換出來給command2處理，
然後再將command2的處理結果，給command1來處理。
然而真正的結果在命令行中卻是分成了\`command2\`與 \`\`。

正確的輸入應該如下：
```shell
	command1 `command2 \`command3\` `
```
 要不然換成$()就沒有問題了：

```shell
 	command1 $(commmand2 $(command3))
```

只要你喜歡，做多少層的替換都沒有問題~~~^_^

不過，$()並不是沒有弊端的...
首先，\`\`基本上可用在所有的unix shell中使用，
若寫成 shell script，其移植性比較高。
而$()並不是每一種shell都能使用，我只能說，
若你用bash2的話，肯定沒問題... ^_^


接下來，再讓我們看看${}吧...它其實就是用來做
變量替換用的啦。
一般情況下，$var與${var}並沒有啥不一樣。
但是用${}會比較精準的界定變量名稱的範圍，
比方說:
```shell
$ A=B
$ echo $AB
```
原本是打算先將$A的結果替換出來，
然後在其後補一個字母B；
但命令行上，
真正的結果卻是替換變量名稱為AB的值出來...
若使用${}就沒有問題了：
```shell
$ A=B
$ echo ${A}B
$ BB
```
不過，假如你只看到`${}`只能用來界定變量名稱的話，
那你就實在太小看bash了。

為了完整起見，我這裡再用一些例子加以說明`${}`的一些
特異功能：
假設我們定義了一個變量file為：
```shell
file=/dir1/dir2/dir3/my.file.txt
```
我們可以用`${}`分別替換獲得不同的值：

####1. shell字符串的非貪婪(最小匹配)左刪除
-----------

```shell
${file#*/}  #其值為：dir1/dir2/dir3/my.file.txt
```
拿掉第一個`/`及其左邊的字符串，其結果為：
`dir1/dir2/dir3/my.file.txt` 。
```shell
${file#*.}  #其值為：file.txt
```
拿掉第一個`.`及其左邊的字符串，其結果為：
`file.txt` 。


####2. shell字符串的貪婪(最大匹配)左刪除：
------
```shell
${file##*/} #其值為：my.file.txt
```
拿掉最後一個`/`及其左邊的字符串，其結果為：
`my.file.txt`

```shell
${file##*.} #其值為：txt
```
拿掉最後一個`.`及其左邊的字符串，其結果為：
`txt`

####3. shell字符串的非貪婪(最小匹配)右刪除：
----------
```shell
${file%/*}  #其值為：/dir1/dir2/dir3
```
拿掉最後一個`/`及其右邊的字符串，其結果為：
`/dir1/dir2/dir3`。

```shell
${file%.*}  #其值為：/dir1/dir2/dir3/my.file
```
拿掉最後一個`.`及其右邊的字符串，其結果為：
`/dir1/dir2/dir3/my.file`。

####4. shell字符串的貪婪(最大匹配)右刪除：
-----
```shell
${file%%/*}  #其值為：其值為空。
```
拿掉第一個`/`及其右邊的字符串，其結果為：
空串。

```shell
${file%%.*}  #其值為：/dir1/dir2/dir3/my。
```
拿掉第一個`.`及其右邊的字符串，其結果為：
/dir1/dir2/dir3/my。

> **Tips:**

> 記憶方法：

> `#`是去掉左邊(在鍵盤上`#`在`$`的左邊);

> `%`是去掉右邊(在鍵盤上`%`在`$`的右邊);

>  單個符號是最小匹配;

>  兩個符號是最大匹配;


####5. shell字符串取子串：
----

```shell
 ${file:0:5} #提取最左邊的5個字符：/dir1
 ${file:5:5} #提取第5個字符及其右邊的5個字符:/dir2
```
shell字符串取子串的格式：`${s:pos:length}`,
取字符串s的子串：從pos位置開始的字符(包括該字符)的長度為length的的子串;
其中pos為子串的首字符，在s中位置；
length為子串的長度;

> **Note:** 字符串中字符的起始編號為0.


####6. shell字符串變量值的替換：
-----

```shell
${file/dir/path}  #將第一個dir替換為path：/path1/dir2/dir3/my.file.txt
${file//dir/path} #將全部的dir替換為path：/path1/path2/path3/my.file.txt
```

shell字符串變量值的替換格式：

- 首次替換：
`${s/src_pattern/dst_pattern}` 將字符串s中的第一個src_pattern替換為dst_pattern。

- 全部替換：
`${s//src_pattern/dst_pattern}` 將字符串s中的所有出現的src_pattern替換為dst_pattern.


####7. ${}還可針對變量的不同狀態(沒設定、空值、非空值)進行賦值：
------

- `${file-my.file.txt}` #如果file沒有設定，則使用
使用my.file.txt作為返回值, 否則返回${file};(空值及非空值時，不作處理。);

- `${file:-my.file.txt}` #如果file沒有設定或者${file}為空值, 均使用my.file.txt作為其返回值，否則，返回${file}.(${file} 為非空值時，不作處理);


- `${file+my.file.txt}` #如果file已設定(為空值或非空值), 則使用my.file.txt作為其返回值，否則不作處理。(未設定時，不作處理);

- `${file:+my.file.txt}` #如果${file}為非空值, 則使用my.file.txt作為其返回值，否則，(未設定或者為空值時)不作處理。

- `${file=my.file.txt}` #如果file為設定，則將file賦值為my.file.txt，同時將${file}作為其返回值；否則，file已設定(為空值或非空值)，則返回${file}。

- `${file:=my.file.txt}` #如果file未設定或者${file}為空值, 則my.file.txt作為其返回值，
同時，將${file}賦值為my.file.txt，否則，(非空值時)不作處理。

- `${file?my.file.txt}` #如果file沒有設定，則將my.file.txt輸出至STDERR, 否側，
已設定(空值與非空值時)，不作處理。

- `${file:?my.file.txt}` #若果file未設定或者為空值，則將my.file.txt輸出至STDERR，否則，
非空值時，不作任何處理。

> **Tips:**

> 以上的理解在於，你一定要分清楚，`unset`與`null`以及non-null這三種狀態的賦值；
>一般而言，與null有關，若不帶`:`, null不受影響；
> 若帶 `:`, 則連null值也受影響。


####8. 計算shell字符串變量的長度：`${#var}`
--------------
```shell
 ${#file}  #其值為27, 因為/dir1/dir2/dir3/my.file.txt剛好為27個字符。
```

####9. bash數組(array)的處理方法
-------------------

接下來，為大家介紹一下bash的數組(array)的處理方法。
一般而言, `A="a b c def"`
這樣的變量只是將`$A`替換為一個字符串，
但是改為 `A=(a b c def)`,
則是將`$A`定義為數組....

#####1). 數組替換方法可參考如下方法：

```shell
${A[@]} #方法一
${A[*]} #方法二
```
以上兩種方法均可以得到：a b c def, 即數組的全部元素。

#####2). 訪問數組的成員:
```shell
${A[0]}
```
其中，`${A[0]}`可得到a, 即數組A的第一個元素，
而 `${A[1]}`則為數組A的第二元素，依次類推。

#####3). 數組的length：
```shell
${#A[@]} #方法一
${#A[*]} #方法二
```
以上兩種方法均可以得到數組的長度: 4, 即數組的所有元素的個數。

回憶一下，針對字符串的長度計算，使用`${#str_var}`;
我們同樣可以將該方法應用於數組的成員:
```shell
${#A[0]}
```
其中，`${#A[0]}`可以得到：1，即數組A的第一個元素(a)的長度;
同理，`${#A[3]}`可以得到: 3, 即數組A的第4個元素(def)的長度。

#####4). 數組元素的重新賦值：
```shell
A[3]=xyz
```
將數組A的第四個元素重新定義為xyz。

> **Tips:**

> 諸如此類的...

> 能夠善用bash的$()與${}可以大大提高及
> 簡化shell在變量上的處理能力哦~~~^_^


####10. $(())作用:
----
好了，最後為大家介紹`$(())`的用途吧：
**`$(())`是用來作整數運算的**。

在bash中， `$(())`的整數運算符號大致有這些：

-  \+\- *  /    #分別為"加、減、乘、除"。
-  %            #餘數運算,(模數運算)
-  & | ^ !      #分別為"AND、OR、XOR、NOT"運算。

例如：
```shell
$ a=5; b=7; c=2;
$ echo $(( a + b * c ))
19
$ echo $(( (a + b)/c ))
6
$ echo $(( (a * b) % c ))
1
```
在`$(())`中的變量名稱,
可以在其前面加 `$`符號來替換，
也可以不用，如：
`$(( $a + $b * $c ))` 也可以得到19的結果。

此外，`$(())`還可作不同進制(如二進制、八進制、十六進制)的運算，
只是輸出結果均為十進制的。
```shell
echo $(( 16#2a )) #輸出結果為：42，(16進制的2a)
```
以一個實用的例子來看看吧 :
假如當前的umask是022,那麼新建文件的權限即為：
```shell
$ umask 022
$ echo "obase=8; $(( 8#666 & (8#777 ^ 8#$(umask)) ))" | bc
644
```
事實上，單純用`(())`也可以重定義變量值，或作testing：
```shell
a=5; ((a++)) #可將$a 重定義為6
a=5; ((a--)) #可將$a 重定義為4
a=5; b=7; ((a< b)) #會得到0 (true)返回值。
```
常見的用於`(())`的測試符號有如下這些：

|符號|符號名稱|
|----|--------|
| <  | 小於號 |
| >  | 大於號 |
| <= | 小於或等於|
| >= | 大於或等於|
| == | 等於|
| != | 不等於|

> **Note:**

> 使用`(())`作整數測試時，
> 請不要跟`[]`的整數測試搞混亂了。

> 更多的測試，我們將於第10章為大家介紹。

怎樣？ 好玩吧... ^_^

okay,這次暫時說這麼多...

上面的介紹，並沒有詳列每一種可用的狀態，
更多的，就請讀者參考手冊文件(man)吧...
