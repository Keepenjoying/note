# 卡爾曼濾波 配合程式 講解


```c
#define PI 3.14159
//角度参数
float Angle, Angle_dot;   //小车最终倾斜角度、角速度
float Angle_aYZ;          //由Y轴Z轴上的加速度传感器测得的数值，计算出倾斜角度
float Angle_gX;           //由X轴的陀螺仪传感器测得的数值，计算出角速度
//卡尔曼参数
float  Q_angle = 0.01; //陀螺儀噪聲的協方差
float  Q_gyro = 0.01;     //陀螺儀漂移噪聲的協方差
float  R_angle = 0.003;           // 加速度計的協方差
float  dt = 0.005;         //dt为kalman滤波器采样时间;
char   C_0 = 1;
float  Q_bias, Angle_err;   //Q_bias為陀螺儀漂移
float  PCt_0, PCt_1, E;
float  K_0, K_1, t_0, t_1;
float  Pdot[4] = {0, 0, 0, 0};
float  PP[2][2] = { { 1, 0 }, { 0, 1 } };
// 卡尔曼滤波
void Kalman_Filter(float Accel, float Gyro)
{
    Angle += (Gyro - Q_bias) * dt; //先验估计

    Pdot[0] = Q_angle - PP[0][1] -
              PP[1][0]; // Pk-先验估计误差协方差的微分

    Pdot[1] = - PP[1][1];
    Pdot[2] = - PP[1][1];
    Pdot[3] = Q_gyro;

    PP[0][0] += Pdot[0] * dt;   // Pk-先验估计误差协方差微分的积分
    PP[0][1] += Pdot[1] * dt;   // =先验估计误差协方差
    PP[1][0] += Pdot[2] * dt;
    PP[1][1] += Pdot[3] * dt;

    Angle_err = Accel - Angle;  //zk-先验估计

    PCt_0 = C_0 * PP[0][0];
    PCt_1 = C_0 * PP[1][0];

    E = R_angle + C_0 * PCt_0;

    K_0 = PCt_0 / E;
    K_1 = PCt_1 / E;

    t_0 = PCt_0;
    t_1 = C_0 * PP[0][1];

    PP[0][0] -= K_0 * t_0;       //后验估计误差协方差
    PP[0][1] -= K_0 * t_1;
    PP[1][0] -= K_1 * t_0;
    PP[1][1] -= K_1 * t_1;

    Angle   += K_0 * Angle_err;  //后验估计
    Q_bias  += K_1 * Angle_err;  //后验估计
    Angle_dot = Gyro - Q_bias; //输出值(后验估计)的微分=角速度
}

//倾角计算（卡尔曼融合）
void Angle_Calcu(void)
{
    //------根据加速度分量测得角速度--------------------------
    //不自测，加速度传感器范围设置  0  ±2g     16384 LSB/g
    Angle_aYZ = atan2((Out_Data(ACCEL_YOUT_H) - 300),
                      (Out_Data(ACCEL_ZOUT_H) - (16384 - 16450))) * 180 / PI
                ; //去除零点偏移,计算得到角度（弧度）
    //弧度转换为度,

    //-------角速度-------------------------
    //不自测，陀螺仪测量范围设置  0  ±250°/s  131LSB/(°/s)   0.00763358 (°/s)/LSB
    Angle_gX = (Out_Data(GYRO_XOUT_H) - 0) * 0.00763358
               ; //0为补偿量，在静止是测得的角速度为0LSB；

    //-------卡尔曼滤波融合-----------------------
    Kalman_Filter(Angle_aYZ - 0,
                  Angle_gX - 0);       //卡尔曼滤波计算倾角,减去零点偏移，
}
```


###首先是卡尔曼滤波的5个方程 

```sh
X(k|k-1)=A X(k-1|k-1)+B U(k) ……….. (1)//先验估计 
P(k|k-1)=A P(k-1|k-1) A’+Q ……… (2)//协方差矩阵的预测 
Kg(k)= P(k|k-1) H’ / (H P(k|k-1) H’ + R) ……… (3)//计算卡尔曼增益 
X(k|k)= X(k|k-1)+Kg(k) (Z(k) - H X(k|k-1)) ……… (4)通过卡尔曼增益进行修正 
P(k|k)=（I-Kg(k) H）P(k|k-1) ……… (5)//跟新协方差阵 
```

###卡尔曼滤波的5个方程 
1.	验估计 
2.	协方差矩阵预测 
3.	计算卡尔曼增益 
4.	通过卡尔曼增益进行修整 
5.	根新协方差阵 


5个式子比较抽象，现在直接用实例来说 
###—，对于角度来说，我们认为此时的角度可以近似认为是上一时刻的角度值加上上一时刻陀螺仪测得的角加速度值乘以时间，因为 ，角度微分等于时间的微分乘以角速度。 


但是陀螺仪有个静态漂移（而且还是变化的），静态漂移就是静止了没有角速度然后陀螺仪也会输出一个值，这个值肯定是没有意义的，计算时要把它减去。 
由此我们得到了当前角度的预测值 Angle 

```
Angle=Angle+(Gyro - Q_bias) * dt;   
```

其中等号左边Angle为此时的角度，等号右边Angle为上一时刻的角度，Gyro 为陀螺仪测的角速度的值，dt是两次滤波之间的时间间隔。 

```c
float  dt=0.005;	                  这是程序中的定义
```
同时 `Q_bias也是一个变化的量`。 


但是就预测来说认为现在的漂移跟上一时刻是相同的即 
```
Q_bias=Q_bias 
```

将两个式子写成矩阵的形式 
  
得到上式，这个式子对应于卡尔曼滤波的第一个式子 
```sh
X(k|k-1)=A X(k-1|k-1)+B U(k) ……….. (1)//先验估计 
```

X(k|k-1)为2维列向量 ，A为2维方阵 ，X(k-1|k-1)为2维列向量 ，B 为2维列向量 ，U(k) 为Gyro 


###二，这里是卡尔曼滤波的第二个式子 

接着是预测方差阵的预测值，这里首先要给出两个值，一个是漂移的噪声，一个是角度值的噪声，（所谓噪声就是数据的方差值） 
```sh
P(k|k-1)=A P(k-1|k-1) A’+Q  
```

这里的Q为向量  的协方差矩阵，即  
因为漂移噪声还有角度噪声是相互独立的，则 =0； =0 
又由性质可知cov（x，x）=D（x）即方差，所以得到的矩阵如下 
 ，这里的两个方差值是开始就给出的常数 
程序中的定义如下

```c
float  Q_angle=0.001;   
float  Q_gyro=0.003; 
```

接着是这一部分A P(k-1|k-1) A’,其中的（P（k-1）|P(k-1)）为上一时刻的预测方差阵 
卡尔曼滤波的目标就是要让这个预测方差阵最小。 
其中P(k-1|k-1)设为 ,第一式已知A为 	
则计算A P(k-1|k-1) A’+Q（就是个矩阵乘法和加法，算算吧）结果如下 
  
 很小为了计算简便忽略不计。 
于是得到 
  
a,b,c,d分别和矩阵的P[0][0],P[0][1],P[1][0],P[1][1] 
计算过程转化为如下程序，代换即可 

```sh
Pdot[0]=Q_angle - PP[0][1] - PP[1][0];  
Pdot[1]= - PP[1][1]; 
Pdot[2]= - PP[1][1];/ 
Pdot[3]=Q_gyro; 

PP[0][0] += Pdot[0] * dt;    
PP[0][1] += Pdot[1] * dt;  
PP[1][0] += Pdot[2] * dt; 
PP[1][1] += Pdot[3] * dt;   
```

###三，这里是卡尔曼滤波的第三个式子 
```sh
Kg(k)= P(k|k-1) H’ / (H P(k|k-1) H’ + R) ……… (3)//计算卡尔曼增益 
```


即计算卡尔曼增益，这是个二维向量设为 ，这里的      =  为由此kg= 
P(K|K-1)+R，这里又有一个常数R，程序中的定义如下 
float  R_angle=0.5; 
这个指的是角度测量噪声值，则式子的`分母=P[0][0]+R_angle` 
即程序中的 
```c
PCt_0 = C_0 * PP[0][0]; 
PCt_1 = C_0 * PP[1][0]; 
E = R_angle + C_0 * PCt_0; 
```

分子	  
于是求出  
```
K_0 = PCt_0 / E; 
K_1 = PCt_1 / E; 
```

###四，用误差还有卡尔曼增益来修正 
```
X(k|k)= X(k|k-1)+Kg(k) (Z(k) - H X(k|k-1)) ……… (4)通过卡尔曼增益进行修正 
```

这个矩阵带进去就行了Z（k)=Accel.....注意这个是加速度计算出来的角度 
```c
Angle_err = Accel - Angle; 
```

对应程序如下 
```c
Angle	+= K_0 * Angle_err; 
Q_bias	+= K_1 * Angle_err;	
```

同时为了PID控制还有下次的使用把角速度算出来了 
```c
Gyro_x   = Gyro - Q_bias;	
```

###五，最后一步对矩阵P进行更新，因为下一次滤波时要用到 
```c
PP[0][0] -= K_0 * t_0; 
PP[0][1] -= K_0 * t_1; 
PP[1][0] -= K_1 * t_0; 
PP[1][1] -= K_1 * t_1; 
```
```
P(k|k)=（I-Kg(k) H）P(k|k-1) ……… (5)//跟预测方差阵 
```

这个很简单，矩阵带进去算就行了 
###六，总结 
卡尔曼滤波一共只需要给很少的初始值量，
```c
float  Q_angle=0.001;   
float  Q_gyro=0.003; 
float  R_angle=0.5; 
```

以及系统的初始量angle还有Q_bias 
还有预测误差矩阵P，程序里给的是0（数组） 

理论上由于`卡尔曼滤波是迭代的算法`，`当时间充分长以后。滤波估值将与初始值的选取无关。` 

`但是实际上并不是如此，比如测量方差值一直在变化。` 

其实卡尔曼的程序相当的简单， 
只要你理解了他的那5条公式。

