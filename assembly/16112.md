# 字符串的存储与加载

字符串的存储与加载是指，将字符串的值加载到寄存器和将其传回内存位置中。其使用指令**lods指令和stos指令**。

- lods指令用于把内存中的字符串值传送到eax寄存器中，该指令有三种不同格式：lodsb（1字节）、lodsw（2字节）、lodsl（4字节）。lods指令使用esi寄存器作为隐含的源操作数。esi寄存器必须包含要加载的字符串所在的内存地址。

- 在使用lods指令把字符串值存放到eax寄存器之后，可以使用stos指令把它存放到另一个内存位置。

- stos也有3种格式：stosb、stosw、stosl。stos指令使用edi寄存器作为隐含的目标操作数，执行stos指令时，根据长度递增或递减edi寄存器的值。
- stos指令最大的用处在于和rep指令一起使用，多次把一个字符串值复制到大型字符串值中的时候，比如把空格字符复制到256字节的缓冲区区域。如下示例：

```
# stos.s

.section .data
space:
    .ascii " "
.section .bss
    .lcomm buffer, 256
.section .text
.globl _start
_start:
    nop
    leal space, %esi
    leal buffer, %edi
    movl $256, %ecx

    cld
    lodsb
    rep stosb

    movl $1, %eax
    movl $0, %ebx
    int $0x80
```
make之后调试运行如下：
```
Breakpoint 1, _start () at stos.s:11
11    nop
(gdb) print/x $eax
$1 = 0x0
(gdb) x/16b &buffer
0x80490a0 <buffer>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x80490a8 <buffer+8>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
(gdb) s
12    leal space, %esi
(gdb) s
13    leal buffer, %edi
(gdb) s
14    movl $256, %ecx
(gdb) s
16    cld
(gdb) s
17    lodsb
(gdb) s
18    rep stosb
(gdb) print/x $eax
$4 = 0x20
(gdb) s
20    movl $1, %eax
(gdb) s
21    movl $0, %ebx
(gdb) x/16b &buffer
0x80490a0 <buffer>: 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20
0x80490a8 <buffer+8>: 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20
(gdb)
```

输出结果显示程序达到了我们预期，stosb指令执行之后，内存位置buffer包含的都是空格。
