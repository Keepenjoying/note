# 在汇编语言中调用C库函数

其实在汇编语言中也是可以使用C库函数的，这一节我们来看一下如何在汇编语言中调用C库函数以使得我们的程序看上去很方便地和用户交互。


C库包括C程序通用的喝多函数，如printf和exit等，下面我们紧接着上一节的知识来实现一个两整数想加的计算并输出计算结果的程序。
```
# libc.s
.section .data
output:
    .asciz "The result is %d. \n"     # printf 函数需要空字符结尾的字符串

.section .bss
    .lcomm result, 4

.section .text
.globl _start
_start:
    nop
    movl $0, result
    movl %esp, %ebp

    pushl 8(%ebp)           # 把第一个命令行参数指针压入堆栈
    call atoi               # 把参数字符串转换为整型
    movl %eax, result       # atoi函数返回值返回到eax寄存器中

    pushl 12(%ebp)          # 把第二个命令行参数指针压入堆栈
    call atoi
    addl %eax, result

    pushl result            # 把参数传递给函数printf，必须把他们压入堆栈。
    pushl $output            # 参数放入顺序和printf获取的顺序相反。
    call printf

    pushl $0
    call exit
```
直接make编译链接结果：
```
$ make
as -gstabs  -o libc.o libc.s
ld -o arg libc.o
libc.o:libc.s:18: undefined reference to `atoi'
libc.o:libc.s:22: undefined reference to `atoi'
libc.o:libc.s:27: undefined reference to `printf'
libc.o:libc.s:30: undefined reference to `exit'
make: *** [arg] 错误 1
```
提示函数未定义，说明C库文件没有连接到程序目标代码。在linux系统上，把C函数连接到汇编语言有两种方法：静态链接和动态链接。静态链接会吧函数目标文件代码直接链接到应用程序的可执行文件中，这样可执行文件就会变得巨大，事实上一般我们自己写的程序库是使用静态链接，而系统的库一般使用动态链接。动态链接不把函数代码链接到可执行文件程序中，在程序启动时有操作系统调用动态链接库。

在linux系统上，标准的C动态库位于libc.so.x文件中，其中x值代表库的版本。为了链接libc.so文件，必须使用GNU连接器的-l参数，链接方式和C语言链接库的方式类似。所以在链接时使用如下方式连接：
```
ld -o $@ $(SRC_OBJ) -dynamic-linker /lib/ld-linux.so.2 -lc
修改后再编译就成功了。
$ ./libc 1 45 The result is 46.
$ ./libc 100 23
The result is 123.
$
```
这样程序就直接打印输出结果了。相比我们之前的程序，现在的程序可以直接将结果输出在终端，而不需要去查看程序的返回码。
